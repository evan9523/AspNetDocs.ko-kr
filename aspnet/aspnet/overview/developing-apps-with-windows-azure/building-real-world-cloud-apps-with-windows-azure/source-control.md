---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/source-control
title: 원본 제어 (Azure를 사용 하 여 실제 클라우드 앱 빌드) | Microsoft Docs
author: MikeWasson
description: Azure e-learning을 사용 하 여 실제 클라우드 앱 빌드는 Scott Guthrie에서 개발한 프레젠테이션을 기반으로 합니다. 여기에는 다음을 수행할 수 있는 13 개의 패턴과 사례가 설명 되어 있습니다.
ms.author: riande
ms.date: 06/23/2015
ms.assetid: 2a0370d3-c2fb-4bf3-88b8-aad5a736c793
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/source-control
msc.type: authoredcontent
ms.openlocfilehash: 5a1e0d7cd3c396d4be79c8958422602055eb3db1
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/19/2020
ms.locfileid: "77457104"
---
# <a name="source-control-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="39526-104">원본 제어 (Azure를 사용 하 여 실제 클라우드 앱 빌드)</span><span class="sxs-lookup"><span data-stu-id="39526-104">Source Control (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="39526-105">사람, [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://twitter.com/RickAndMSFT), [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="39526-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://twitter.com/RickAndMSFT), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="39526-106">[Fix It 프로젝트 다운로드](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) 또는 [전자 서적 다운로드](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="39526-106">[Download Fix It Project](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="39526-107">Azure e-learning을 **사용 하 여 실제 클라우드 앱 빌드** 는 Scott Guthrie에서 개발한 프레젠테이션을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="39526-108">클라우드의 웹 앱을 성공적으로 개발 하는 데 도움이 되는 13 개의 패턴 및 사례에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="39526-109">전자 문서에 대 한 자세한 내용은 [첫 번째 챕터](introduction.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>

<span data-ttu-id="39526-110">원본 제어는 팀 환경 뿐만 아니라 모든 클라우드 개발 프로젝트에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-110">Source control is essential for all cloud development projects, not just team environments.</span></span> <span data-ttu-id="39526-111">실행 취소 함수 및 자동 백업 없이 소스 코드를 편집 하거나 Word 문서를 편집 하는 것은 좋지 않으며, 소스 제어는 프로젝트 수준에서 이러한 기능을 제공 하므로 문제가 발생할 경우 훨씬 더 많은 시간을 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-111">You wouldn't think of editing source code or even a Word document without an undo function and automatic backups, and source control gives you those functions at a project level where they can save even more time when something goes wrong.</span></span> <span data-ttu-id="39526-112">클라우드 소스 제어 서비스를 사용 하면 복잡 한 설정에 대해 더 이상 걱정할 필요가 없으며 최대 5 명의 사용자에 게 Azure Repos 소스 제어를 무료로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-112">With cloud source control services, you no longer have to worry about complicated set-up, and you can use Azure Repos source control free for up to 5 users.</span></span>

<span data-ttu-id="39526-113">이 챕터의 첫 번째 부분에서는 다음에 유의 해야 하는 세 가지 주요 모범 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-113">The first part of this chapter explains three key best practices to keep in mind:</span></span>

- <span data-ttu-id="39526-114">[자동화 스크립트를 소스 코드로 처리](#scripts) 하 고 응용 프로그램 코드와 함께 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-114">[Treat automation scripts as source code](#scripts) and version them together with your application code.</span></span>
- <span data-ttu-id="39526-115">비밀 (자격 증명과 같은 중요 한 데이터)을 소스 코드 리포지토리로 [체크 인 하지 마십시오](#secrets) .</span><span class="sxs-lookup"><span data-stu-id="39526-115">[Never check in secrets](#secrets) (sensitive data such as credentials) into a source code repository.</span></span>
- <span data-ttu-id="39526-116">DevOps 워크플로를 사용 하도록 [원본 분기를 설정](#devops) 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-116">[Set up source branches](#devops) to enable the DevOps workflow.</span></span>

<span data-ttu-id="39526-117">이 장의 나머지 부분에서는 Visual Studio, Azure 및 Azure Repos에서 이러한 패턴을 구현 하는 몇 가지 샘플을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-117">The remainder of the chapter gives some sample implementations of these patterns in Visual Studio, Azure, and Azure Repos:</span></span>

- [<span data-ttu-id="39526-118">Visual Studio에서 소스 제어에 스크립트 추가</span><span class="sxs-lookup"><span data-stu-id="39526-118">Add scripts to source control in Visual Studio</span></span>](#vsscripts)
- [<span data-ttu-id="39526-119">중요 한 데이터를 Azure에 저장</span><span class="sxs-lookup"><span data-stu-id="39526-119">Store sensitive data in Azure</span></span>](#appsettings)
- [<span data-ttu-id="39526-120">Visual Studio 및 Azure Repos에서 Git 사용</span><span class="sxs-lookup"><span data-stu-id="39526-120">Use Git in Visual Studio and Azure Repos</span></span>](#gittfs)

<a id="scripts"></a>
## <a name="treat-automation-scripts-as-source-code"></a><span data-ttu-id="39526-121">자동화 스크립트를 소스 코드로 처리</span><span class="sxs-lookup"><span data-stu-id="39526-121">Treat automation scripts as source code</span></span>

<span data-ttu-id="39526-122">클라우드 프로젝트에서 작업 하는 경우 자주 변경 하 고 고객이 보고 한 문제에 신속 하 게 대응할 수 있도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-122">When you're working on a cloud project you're changing things frequently and you want to be able to react quickly to issues reported by your customers.</span></span> <span data-ttu-id="39526-123">[모든 기능 자동화](automate-everything.md) 의 설명에 따라 자동화 스크립트를 사용 하 여 신속 하 게 응답 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-123">Responding quickly involves using automation scripts, as explained in the [Automate Everything](automate-everything.md) chapter.</span></span> <span data-ttu-id="39526-124">환경을 만들고, 배포 하 고, 크기를 조정 하는 데 사용 하는 모든 스크립트는 응용 프로그램 소스 코드와 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-124">All of the scripts that you use to create your environment, deploy to it, scale it, etc., need to be in sync with your application source code.</span></span>

<span data-ttu-id="39526-125">스크립트를 코드와 동기화 상태로 유지 하려면 소스 제어 시스템에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-125">To keep scripts in sync with code, store them in your source control system.</span></span> <span data-ttu-id="39526-126">그런 다음 변경 내용을 롤백하거나 개발 코드와 다른 프로덕션 코드를 신속 하 게 수정 해야 하는 경우 변경 된 설정이 나 필요한 버전의 복사본이 있는 팀 멤버를 추적 하는 데 걸리는 시간을 낭비 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-126">Then if you ever need to roll back changes or make a quick fix to production code which is different from development code, you don't have to waste time trying to track down which settings have changed or which team members have copies of the version you need.</span></span> <span data-ttu-id="39526-127">필요한 스크립트가 필요한 코드 베이스와 동기화 되 고 모든 팀 멤버가 동일한 스크립트를 사용 하 고 있다고 확신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-127">You're assured that the scripts you need are in sync with the code base that you need them for, and you're assured that all team members are working with the same scripts.</span></span> <span data-ttu-id="39526-128">그런 다음 프로덕션 또는 새로운 기능 개발에 대 한 핫 픽스 테스트 및 배포를 자동화 해야 하는지 여부에 관계 없이 업데이트 해야 하는 코드에 대 한 올바른 스크립트가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-128">Then whether you need to automate testing and deployment of a hot fix to production or new feature development, you'll have the right script for the code that needs to be updated.</span></span>

<a id="secrets"></a>
## <a name="dont-check-in-secrets"></a><span data-ttu-id="39526-129">암호 체크 인 안 함</span><span class="sxs-lookup"><span data-stu-id="39526-129">Don't check in secrets</span></span>

<span data-ttu-id="39526-130">소스 코드 리포지토리는 일반적으로 암호와 같은 중요 한 데이터를 적절 하 게 보호 하기 위해 너무 많은 사람이 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-130">A source code repository is typically accessible to too many people for it to be an appropriately secure place for sensitive data such as passwords.</span></span> <span data-ttu-id="39526-131">스크립트에서 암호와 같은 암호를 사용 하는 경우 소스 코드에 저장 되지 않도록 해당 설정을 매개 변수화 하 고 다른 위치에 암호를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-131">If scripts rely on secrets such as passwords, parameterize those settings so that they don't get saved in source code, and store your secrets somewhere else.</span></span>

<span data-ttu-id="39526-132">예를 들어 Azure에서는 게시 프로필 생성을 자동화 하기 위해 게시 설정이 포함 된 파일을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-132">For example, Azure lets you download files that contain publish settings in order to automate the creation of publish profiles.</span></span> <span data-ttu-id="39526-133">이러한 파일에는 Azure 서비스를 관리할 수 있는 권한이 있는 사용자 이름 및 암호가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-133">These files include user names and passwords that are authorized to manage your Azure services.</span></span> <span data-ttu-id="39526-134">이 방법을 사용 하 여 게시 프로필을 만들 때 이러한 파일을 원본 제어에 체크 인하면 모든 사용자가 해당 사용자 이름과 암호를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-134">If you use this method to create publish profiles, and if you check in these files to source control, anyone with access to your repository can see those user names and passwords.</span></span> <span data-ttu-id="39526-135">암호는 암호화 되어 있으며 기본적으로 소스 제어에 포함 되지 않는 *pubxml 사용자* 파일에 있기 때문에 게시 프로필 자체에 안전 하 게 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-135">You can safely store the password in the publish profile itself because it's encrypted and it's in a *.pubxml.user* file that by default is not included in source control.</span></span>

<a id="devops"></a>
## <a name="structure-source-branches-to-facilitate-devops-workflow"></a><span data-ttu-id="39526-136">DevOps 워크플로를 용이 하 게 하는 구조 소스 분기</span><span class="sxs-lookup"><span data-stu-id="39526-136">Structure source branches to facilitate DevOps workflow</span></span>

<span data-ttu-id="39526-137">리포지토리에서 분기를 구현 하는 방법은 새 기능을 개발 하 고 프로덕션에서 문제를 해결 하는 기능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="39526-137">How you implement branches in your repository affects your ability to both develop new features and fix issues in production.</span></span> <span data-ttu-id="39526-138">다음은 많은 중간 규모 팀에서 사용 하는 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-138">Here is a pattern that a lot of medium sized teams use:</span></span>

![소스 분기 구조](source-control/_static/image1.png)

<span data-ttu-id="39526-140">마스터 분기는 항상 프로덕션에 있는 코드와 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-140">The master branch always matches code that is in production.</span></span> <span data-ttu-id="39526-141">마스터 아래의 분기는 개발 수명 주기의 다른 단계에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-141">Branches underneath master correspond to different stages in the development life cycle.</span></span> <span data-ttu-id="39526-142">개발 분기에서는 새 기능을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-142">The development branch is where you implement new features.</span></span> <span data-ttu-id="39526-143">소규모 팀의 경우 마스터 및 개발을 사용할 수 있지만, 사용자에 게 개발과 마스터 사이에 스테이징 분기가 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-143">For a small team you might just have master and development, but we often recommend that people have a staging branch between development and master.</span></span> <span data-ttu-id="39526-144">업데이트를 프로덕션으로 이동 하기 전에 최종 통합 테스트에 대해 준비를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-144">You can use staging for final integration testing before an update is moved to production.</span></span>

<span data-ttu-id="39526-145">큰 팀의 경우에는 각각의 새로운 기능에 대해 별도의 분기가 있을 수 있습니다. 소규모 팀의 경우 모든 사용자가 개발 분기에 체크 인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-145">For big teams there may be separate branches for each new feature; for a smaller team you might have everyone checking in to the development branch.</span></span>

<span data-ttu-id="39526-146">각 기능에 대 한 분기가 있는 경우 기능 A가 준비 되 면 소스 코드 변경 내용을 개발 분기에 병합 하 고 다른 기능 분기에 병합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-146">If you have a branch for each feature, when Feature A is ready you merge its source code changes up into the development branch and down into the other feature branches.</span></span> <span data-ttu-id="39526-147">이 소스 코드 병합 프로세스는 시간이 많이 소요 될 수 있으며, 기능을 별도로 유지 하면서 이러한 작업을 방지 하기 위해 일부 팀은 기능 *[설정/해제](http://en.wikipedia.org/wiki/Feature_toggle)* ( *기능 플래그*라고도 함) 라는 대체를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-147">This source code merging process can be time-consuming, and to avoid that work while still keeping features separate, some teams implement an alternative called *[feature toggles](http://en.wikipedia.org/wiki/Feature_toggle)* (also known as *feature flags*).</span></span> <span data-ttu-id="39526-148">즉, 모든 기능의 모든 코드가 동일한 분기에 있지만 코드에서 스위치를 사용 하 여 각 기능을 사용 하거나 사용 하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-148">This means all of the code for all of the features is in the same branch, but you enable or disable each feature by using switches in the code.</span></span> <span data-ttu-id="39526-149">예를 들어 기능 A가 Fix It 앱 작업의 새 필드이 고 기능 B가 캐싱 기능을 추가 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-149">For example, suppose Feature A is a new field for Fix It app tasks, and Feature B adds caching functionality.</span></span> <span data-ttu-id="39526-150">두 기능의 코드는 모두 개발 분기에 있을 수 있지만 앱은 변수가 true로 설정 된 경우에만 새 필드를 표시 하며, 다른 변수가 true로 설정 된 경우에만 캐싱을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-150">The code for both features can be in the development branch, but the app will only display the new field when a variable is set to true, and it will only use caching when a different variable is set to true.</span></span> <span data-ttu-id="39526-151">기능 A를 승격할 준비가 되지 않았지만 기능 B가 준비 된 경우 기능 A 스위치를 사용 하 고 기능 B 스위치를 사용 하 여 모든 코드를 프로덕션으로 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-151">If Feature A isn't ready to be promoted but the Feature B is ready, you can promote all of the code to Production with the Feature A switch off and the Feature B switch on.</span></span> <span data-ttu-id="39526-152">그런 다음 기능 A를 마무리 하 고 나중에 소스 코드를 병합 하지 않고 모두 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-152">You can then finish Feature A and promote it later, all with no source code merging.</span></span>

<span data-ttu-id="39526-153">기능에 대 한 분기 또는 토글을 사용 하는지 여부에 관계 없이 이와 같은 분기 구조를 사용 하면 민첩 하 고 반복 가능한 방식으로 코드를 개발 환경에서 프로덕션으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-153">Whether or not you use branches or toggles for features, a branching structure like this enables you to flow your code from development into production in an agile and repeatable way.</span></span>

<span data-ttu-id="39526-154">이 구조를 사용 하 여 고객 피드백에 신속 하 게 대응할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-154">This structure also enables you to react quickly to customer feedback.</span></span> <span data-ttu-id="39526-155">프로덕션에 대 한 빠른 수정 작업을 수행 해야 하는 경우 agile 방식으로 효율적으로 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-155">If you need to make a quick fix to production, you can also do that efficiently in an agile way.</span></span> <span data-ttu-id="39526-156">Master 또는 스테이징의 분기를 만들 수 있으며,이 분기를 마스터에 병합 하 고 개발 및 기능 분기로 배포할 준비가 되었을 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-156">You can create a branch off of master or staging, and when it's ready merge it up into master and down into development and feature branches.</span></span>

![핫픽스 분기](source-control/_static/image2.png)

<span data-ttu-id="39526-158">프로덕션 및 개발 분기를 분리 하 여 이와 같은 분기 구조가 없는 경우 프로덕션 문제는 프로덕션 수정과 함께 새로운 기능 코드를 승격할 수 있는 위치에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-158">Without a branching structure like this with its separation of production and development branches, a production problem could put you in the position of having to promote new feature code along with your production fix.</span></span> <span data-ttu-id="39526-159">새 기능 코드는 완전 하 게 테스트 및 프로덕션 준비가 되지 않았을 수 있으며, 준비 되지 않은 변경 작업을 수행 해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-159">The new feature code might not be fully tested and ready for production and you might have to do a lot of work backing out changes that aren't ready.</span></span> <span data-ttu-id="39526-160">또는 변경을 테스트 하 고 배포 준비를 완료 하기 위해 픽스를 지연 해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-160">Or you might have to delay your fix in order to test changes and get them ready to deploy.</span></span>

<span data-ttu-id="39526-161">다음에는 Visual Studio, Azure 및 Azure Repos에서 이러한 세 가지 패턴을 구현 하는 방법에 대 한 예제가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-161">Next you'll see examples of how to implement these three patterns in Visual Studio, Azure, and Azure Repos.</span></span> <span data-ttu-id="39526-162">이에 대 한 자세한 단계별 방법에 대 한 지침은 다음과 같습니다. 필요한 모든 컨텍스트를 제공 하는 자세한 지침은 챕터의 끝에 있는 [리소스](#resources) 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-162">These are examples rather than detailed step-by-step how-to-do-it instructions; for detailed instructions that provide all of the context necessary, see the [Resources](#resources) section at the end of the chapter.</span></span>

<a id="vsscripts"></a>
## <a name="add-scripts-to-source-control-in-visual-studio"></a><span data-ttu-id="39526-163">Visual Studio에서 소스 제어에 스크립트 추가</span><span class="sxs-lookup"><span data-stu-id="39526-163">Add scripts to source control in Visual Studio</span></span>

<span data-ttu-id="39526-164">Visual studio 솔루션 폴더 (프로젝트가 소스 제어에 있다고 가정)에 포함 하 여 Visual Studio의 소스 제어에 스크립트를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-164">You can add scripts to source control in Visual Studio by including them in a Visual Studio solution folder (assuming your project is in source control).</span></span> <span data-ttu-id="39526-165">이 작업을 수행 하는 한 가지 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-165">Here's one way to do it.</span></span>

<span data-ttu-id="39526-166">솔루션 폴더 ( *.sln* 파일이 있는 동일한 폴더)에 스크립트에 대 한 폴더를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="39526-166">Create a folder for the scripts in your solution folder (the same folder that has your *.sln* file).</span></span>

![자동화 폴더](source-control/_static/image3.png)

<span data-ttu-id="39526-168">스크립트 파일을 폴더에 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-168">Copy the script files into the folder.</span></span>

![자동화 폴더 내용](source-control/_static/image4.png)

<span data-ttu-id="39526-170">Visual Studio에서 솔루션 폴더를 프로젝트에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-170">In Visual Studio, add a solution folder to the project.</span></span>

![새 솔루션 폴더 메뉴 선택](source-control/_static/image5.png)

<span data-ttu-id="39526-172">스크립트 파일을 솔루션 폴더에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-172">And add the script files to the solution folder.</span></span>

![기존 항목 추가 메뉴 선택](source-control/_static/image6.png)

![기존 항목 추가 대화 상자](source-control/_static/image7.png)

<span data-ttu-id="39526-175">이제 스크립트 파일이 프로젝트에 포함 되 고 소스 제어는 해당 소스 코드 변경 내용과 함께 버전 변경 내용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-175">The script files are now included in your project and source control is tracking their version changes along with corresponding source code changes.</span></span>

<a id="appsettings"></a>
## <a name="store-sensitive-data-in-azure"></a><span data-ttu-id="39526-176">중요 한 데이터를 Azure에 저장</span><span class="sxs-lookup"><span data-stu-id="39526-176">Store sensitive data in Azure</span></span>

<span data-ttu-id="39526-177">Azure 웹 사이트에서 응용 프로그램을 실행 하는 경우 소스 제어에 자격 증명을 저장 하지 않는 한 가지 방법은 대신 Azure에 저장 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-177">If you run your application in an Azure Web Site, one way to avoid storing credentials in source control is to store them in Azure instead.</span></span>

<span data-ttu-id="39526-178">예를 들어 Fix It 응용 프로그램은 해당 Web.config 파일에 저장 되는 두 개의 연결 문자열을 프로덕션에 저장 하 고 Azure 저장소 계정에 대 한 액세스를 제공 하는 키를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-178">For example, the Fix It application stores in its Web.config file two connection strings that will have passwords in production and a key that gives access to your Azure storage account.</span></span>

[!code-xml[Main](source-control/samples/sample1.xml?highlight=2-3,11)]

<span data-ttu-id="39526-179">이러한 설정에 대 한 실제 프로덕션 값을 *web.config 파일에* 배치 하거나 web.config 파일에 배치 하 여 배포 중에 삽입 하 *는 web.config 변환을* 구성 하면 원본 리포지토리에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-179">If you put actual production values for these settings in your *Web.config* file, or if you put them in the *Web.Release.config* file to configure a Web.config transform to insert them during deployment, they'll be stored in the source repository.</span></span> <span data-ttu-id="39526-180">프로덕션 게시 프로필에 데이터베이스 연결 문자열을 입력 하면 *pubxml* 파일에 암호가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-180">If you enter the database connection strings into the production publish profile, the password will be in your *.pubxml* file.</span></span> <span data-ttu-id="39526-181">원본 제어에서 *pubxml* 파일을 제외할 수 있지만 다른 모든 배포 설정을 공유 하는 경우의 이점을 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-181">(You could exclude the *.pubxml* file from source control, but then you lose the benefit of sharing all the other deployment settings.)</span></span>

<span data-ttu-id="39526-182">Azure *는 web.config 파일의* **appSettings** 및 연결 문자열 섹션에 대 한 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-182">Azure gives you an alternative for the **appSettings** and connection strings sections of the *Web.config* file.</span></span> <span data-ttu-id="39526-183">Azure 관리 포털에서 웹 사이트에 대 한 **구성** 탭의 관련 부분은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-183">Here is the relevant part of the **Configuration** tab for a web site in the Azure management portal:</span></span>

![포털의 appSettings 및 connectionStrings](source-control/_static/image8.png)

<span data-ttu-id="39526-185">이 웹 사이트에 프로젝트를 배포 하 고 응용 프로그램이 실행 되는 경우 Azure에 저장 한 값은 web.config 파일에 있는 값에 관계 없이 재정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-185">When you deploy a project to this web site and the application runs, whatever values you have stored in Azure override whatever values are in the Web.config file.</span></span>

<span data-ttu-id="39526-186">관리 포털을 사용 하거나 스크립트를 사용 하 여 Azure에서 이러한 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-186">You can set these values in Azure by using either the management portal or scripts.</span></span> <span data-ttu-id="39526-187">[모두 자동화](automate-everything.md) 단원에서 확인 한 환경 만들기 자동화 스크립트는 Azure SQL Database 만들고, 저장소 및 SQL Database 연결 문자열을 가져오고, 이러한 비밀을 웹 사이트의 설정에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-187">The environment creation automation script you saw in the [Automate Everything](automate-everything.md) chapter creates an Azure SQL Database, gets the storage and SQL Database connection strings, and stores these secrets in the settings for your web site.</span></span>

[!code-powershell[Main](source-control/samples/sample2.ps1)]

[!code-powershell[Main](source-control/samples/sample3.ps1)]

<span data-ttu-id="39526-188">실제 값이 소스 리포지토리에 유지 되지 않도록 스크립트에 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-188">Notice that the scripts are parameterized so that actual values don't get persisted to the source repository.</span></span>

<span data-ttu-id="39526-189">개발 환경에서 로컬로 실행 하는 경우 앱은 로컬 web.config 파일을 읽고 연결 문자열은 웹 프로젝트의 *app\_Data* 폴더에 있는 LocalDB SQL Server 데이터베이스를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="39526-189">When you run locally in your development environment, the app reads your local Web.config file and your connection string points to a LocalDB SQL Server database in the *App\_Data* folder of your web project.</span></span> <span data-ttu-id="39526-190">Azure에서 앱을 실행 하는 경우 앱이 web.config 파일에서 이러한 값을 읽으려고 시도 하 고,이 값은 web.config 파일에 실제로 있는 것이 아니라 웹 사이트에 대해 저장 된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-190">When you run the app in Azure and the app tries to read these values from the Web.config file, what it gets back and uses are the values stored for the Web Site, not what's actually in Web.config file.</span></span>

<a id="gittfs"></a>
## <a name="use-git-in-visual-studio-and-azure-devops"></a><span data-ttu-id="39526-191">Visual Studio 및 Azure DevOps에서 Git 사용</span><span class="sxs-lookup"><span data-stu-id="39526-191">Use Git in Visual Studio and Azure DevOps</span></span>

<span data-ttu-id="39526-192">모든 원본 제어 환경을 사용 하 여 앞에서 제공 된 DevOps 분기 구조를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-192">You can use any source control environment to implement the DevOps branching structure presented earlier.</span></span> <span data-ttu-id="39526-193">분산 된 팀의 경우 dvcs ( [distributed version control system](http://en.wikipedia.org/wiki/Distributed_revision_control) )를 사용 하는 것이 가장 좋습니다. 다른 팀의 경우 [중앙 집중식 시스템이](http://en.wikipedia.org/wiki/Revision_control) 더 효율적으로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-193">For distributed teams a [distributed version control system](http://en.wikipedia.org/wiki/Distributed_revision_control) (DVCS) might work best; for other teams a [centralized system](http://en.wikipedia.org/wiki/Revision_control) might work better.</span></span>

<span data-ttu-id="39526-194">[Git](http://git-scm.com/) 는 널리 사용 되는 분산 버전 제어 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-194">[Git](http://git-scm.com/) is a popular distributed version control system.</span></span> <span data-ttu-id="39526-195">원본 제어에 Git를 사용 하는 경우 로컬 컴퓨터의 모든 기록과 함께 리포지토리의 전체 복사본을 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-195">When you use Git for source control, you have a complete copy of the repository with all of its history on your local computer.</span></span> <span data-ttu-id="39526-196">네트워크에 연결 되지 않은 경우 계속 해 서 작업을 수행할 수 있기 때문에 많은 사람들이 선호 하는 것이 좋습니다. 계속 해 서 커밋 및 롤백을 수행 하 고, 분기를 만들고 전환 하는 등의 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-196">Many people prefer that because it's easier to continue working when you're not connected to the network -- you can continue to do commits and rollbacks, create and switch branches, and so forth.</span></span> <span data-ttu-id="39526-197">네트워크에 연결 된 경우에도 모든 것이 로컬 인 경우 분기를 만들고 분기를 전환 하는 것이 더 쉽고 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="39526-197">Even when you're connected to the network, it's easier and quicker to create branches and switch branches when everything is local.</span></span> <span data-ttu-id="39526-198">다른 개발자에 게 영향을 주지 않고 로컬 커밋 및 롤백을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-198">You can also do local commits and rollbacks without having an impact on other developers.</span></span> <span data-ttu-id="39526-199">그리고 서버에 보내기 전에 커밋을 일괄 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-199">And you can batch commits before sending them to the server.</span></span>

<span data-ttu-id="39526-200">[Azure Repos](/azure/devops/repos/index?view=vsts) 는 [Git](/azure/devops/repos/git/?view=vsts) 및 [Team Foundation 버전 제어](/azure/devops/repos/tfvc/index?view=vsts) (TFVC; 중앙화 된 원본 제어)를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-200">[Azure Repos](/azure/devops/repos/index?view=vsts) offers both [Git](/azure/devops/repos/git/?view=vsts) and [Team Foundation Version Control](/azure/devops/repos/tfvc/index?view=vsts) (TFVC; centralized source control).</span></span> <span data-ttu-id="39526-201">[여기](https://app.vsaex.visualstudio.com/signup)에서 Azure devops를 시작 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-201">Get started with Azure DevOps [here](https://app.vsaex.visualstudio.com/signup).</span></span>

<span data-ttu-id="39526-202">Visual Studio 2017에는 기본 제공, 최고 수준의 [Git 지원](https://msdn.microsoft.com/library/hh850437.aspx)기능이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-202">Visual Studio 2017 includes built-in, first-class [Git support](https://msdn.microsoft.com/library/hh850437.aspx).</span></span> <span data-ttu-id="39526-203">이 작업을 수행 하는 방법에 대 한 간단한 데모는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-203">Here's a quick demo of how that works.</span></span>

<span data-ttu-id="39526-204">Visual Studio에서 프로젝트를 열고 **솔루션 탐색기**에서 솔루션을 마우스 오른쪽 단추로 클릭 한 다음 **소스 제어에 솔루션 추가**를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-204">With a project open in Visual Studio, right-click the solution in **Solution Explorer**, and then choose **Add Solution to Source Control**.</span></span>

![소스 제어에 솔루션 추가](source-control/_static/image9.png)

<span data-ttu-id="39526-206">Visual Studio는 TFVC (중앙 집중식 버전 제어) 또는 Git를 사용할지 여부를 묻습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-206">Visual Studio asks if you want to use TFVC (centralized version control) or Git.</span></span>

![소스 제어 선택](source-control/_static/image10.png)

<span data-ttu-id="39526-208">Git를 선택 하 고 **확인**을 클릭 하면 Visual Studio에서 솔루션 폴더에 새 로컬 Git 리포지토리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="39526-208">When you select Git and click **OK**, Visual Studio creates a new local Git repository in your solution folder.</span></span> <span data-ttu-id="39526-209">새 리포지토리에 파일이 아직 없습니다. Git 커밋을 수행 하 여 리포지토리에 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-209">The new repository has no files yet; you have to add them to the repository by doing a Git commit.</span></span> <span data-ttu-id="39526-210">**솔루션 탐색기**에서 솔루션을 마우스 오른쪽 단추로 클릭 한 다음 **커밋**을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-210">Right-click the solution in **Solution Explorer**, and then click **Commit**.</span></span>

![Commit](source-control/_static/image11.png)

<span data-ttu-id="39526-212">Visual Studio는 커밋에 대 한 모든 프로젝트 파일을 자동으로 준비 하 고 **포함 된 변경 내용** 창에 **팀 탐색기** 에 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-212">Visual Studio automatically stages all of the project files for the commit and lists them in **Team Explorer** in the **Included Changes** pane.</span></span> <span data-ttu-id="39526-213">커밋에 포함 하지 않으려는 항목이 있는 경우 해당 항목을 선택 하 고 마우스 오른쪽 단추를 클릭 한 다음 **제외**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-213">(If there were some you didn't want to include in the commit, you could select them, right-click, and click **Exclude**.)</span></span>

![팀 탐색기](source-control/_static/image12.png)

<span data-ttu-id="39526-215">커밋 주석을 입력 하 고 **커밋**을 클릭 하면 Visual Studio에서 커밋을 실행 하 고 커밋 ID를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-215">Enter a commit comment and click **Commit**, and Visual Studio executes the commit and displays the commit ID.</span></span>

![변경 내용 팀 탐색기](source-control/_static/image13.png)

<span data-ttu-id="39526-217">이제 리포지토리의 항목과 다른 코드를 변경 하는 경우 차이점을 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-217">Now if you change some code so that it's different from what's in the repository, you can easily view the differences.</span></span> <span data-ttu-id="39526-218">변경한 파일을 마우스 오른쪽 단추로 클릭 하 고, 수정 되지 않은 항목과 **비교**를 선택 하 고, 커밋되지 않은 변경 내용을 보여 주는 비교 표시를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="39526-218">Right-click a file that you've changed, select **Compare with Unmodified**, and you get a comparison display that shows your uncommitted change.</span></span>

![수정 되지 않은 항목과 비교](source-control/_static/image14.png)

![변경 내용을 표시 하는 Diff](source-control/_static/image15.png)

<span data-ttu-id="39526-221">변경 내용을 쉽게 확인 하 고 체크 인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-221">You can easily see what changes you're making and check them in.</span></span>

<span data-ttu-id="39526-222">분기를 만들어야 한다고 가정 합니다. Visual Studio 에서도이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-222">Suppose you need to make a branch – you can do that in Visual Studio too.</span></span> <span data-ttu-id="39526-223">**팀 탐색기**에서 **새 분기**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-223">In **Team Explorer**, click **New Branch**.</span></span>

![새 분기 팀 탐색기](source-control/_static/image16.png)

<span data-ttu-id="39526-225">분기 이름을 입력 하 고 **분기 만들기**를 클릭 합니다. **분기 체크 아웃**을 선택 하면 Visual Studio에서 새 분기가 자동으로 체크 아웃 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39526-225">Enter a branch name, click **Create Branch**, and if you selected **Checkout branch**, Visual Studio automatically checks out the new branch.</span></span>

![새 분기 팀 탐색기](source-control/_static/image17.png)

<span data-ttu-id="39526-227">이제 파일을 변경 하 고이 분기에 체크 인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-227">You can now make changes to files and check them in to this branch.</span></span> <span data-ttu-id="39526-228">분기 간을 쉽게 전환할 수 있으며 Visual Studio에서 체크 아웃 한 분기에 파일을 자동으로 동기화 합니다. 이 예제에서는 *\_레이아웃* 의 웹 페이지 제목을 HotFix1 branch의 "Hot Fix 1"로 변경 했습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-228">And you can easily switch between branches and Visual Studio automatically syncs the files to whichever branch you have checked out. In this example the web page title in *\_Layout.cshtml* has been changed to "Hot Fix 1" in HotFix1 branch.</span></span>

![Hotfix1 분기](source-control/_static/image18.png)

<span data-ttu-id="39526-230">마스터 분기로 다시 전환 하면 *\_Layout* 파일의 내용이 마스터 분기에 있는 것으로 자동으로 되돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="39526-230">If you switch back to the master branch, the contents of the *\_Layout.cshtml* file automatically revert to what they are in the master branch.</span></span>

![Master 분기](source-control/_static/image19.png)

<span data-ttu-id="39526-232">이를 통해 분기를 신속 하 게 만들고 분기 간에 대칭 이동 하는 방법에 대 한 간단한 예를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-232">This a simple example of how you can quickly create a branch and flip back and forth between branches.</span></span> <span data-ttu-id="39526-233">이 기능을 사용 하면 [모든 항목 자동](automate-everything.md) 구성 장에 제공 된 자동화 스크립트 및 분기 구조를 사용 하 여 매우 민첩 한 워크플로를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-233">This feature enables a highly agile workflow using the branch structure and automation scripts presented in the [Automate Everything](automate-everything.md) chapter.</span></span> <span data-ttu-id="39526-234">예를 들어 개발 분기에서 작업 하 고, master에서 핫 픽스 분기를 만들고, 새 분기로 전환 하 고, 변경 내용을 적용 하 고, 변경 내용을 적용 하 고, 다시 개발 분기로 전환 하 고, 수행한 작업을 계속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-234">For example, you can be working in the Development branch, create a hot fix branch off of master, switch to the new branch, make your changes there and commit them, and then switch back to the Development branch and continue what you were doing.</span></span>

<span data-ttu-id="39526-235">Visual Studio에서 로컬 Git 리포지토리로 작업 하는 방법은 여기에서 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-235">What you've seen here is how you work with a local Git repository in Visual Studio.</span></span> <span data-ttu-id="39526-236">팀 환경에서는 일반적으로 변경 내용을 공통 리포지토리로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-236">In a team environment you typically also push changes up to a common repository.</span></span> <span data-ttu-id="39526-237">Visual Studio 도구를 사용 하 여 원격 Git 리포지토리를 가리킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-237">The Visual Studio tools also enable you to point to a remote Git repository.</span></span> <span data-ttu-id="39526-238">이 목적을 위해 GitHub.com를 사용 하거나, [Git 및 Azure Repos](/azure/devops/repos/git/overview?view=vsts) 를 사용 하 여 작업 항목 및 버그 추적과 같은 다른 모든 Azure devops 기능과 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-238">You can use GitHub.com for that purpose, or you can use [Git and Azure Repos](/azure/devops/repos/git/overview?view=vsts) integrated with all the other Azure DevOps capabilities such as work item and bug tracking.</span></span>

<span data-ttu-id="39526-239">물론 agile 분기 전략을 구현할 수 있는 유일한 방법은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="39526-239">This isn't the only way you can implement an agile branching strategy, of course.</span></span> <span data-ttu-id="39526-240">중앙 집중식 원본 제어 리포지토리를 사용 하 여 동일한 agile 워크플로를 사용 하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-240">You can enable the same agile workflow using a centralized source control repository.</span></span>

## <a name="summary"></a><span data-ttu-id="39526-241">요약</span><span class="sxs-lookup"><span data-stu-id="39526-241">Summary</span></span>

<span data-ttu-id="39526-242">언제 든 지 변경 하 여 안전 하 고 예측 가능한 방식으로 사용할 수 있는 방법에 따라 원본 제어 시스템의 성공 여부를 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-242">Measure the success of your source control system based on how quickly you can make a change and get it live in a safe and predictable way.</span></span> <span data-ttu-id="39526-243">1 일 또는 2 개의 수동 테스트를 수행 해야 하기 때문에 변경 하는 것을 알게 되 면 몇 분 내에 또는 최악의 경우에 변경 내용을 적용할 수 있도록 프로세스 또는 테스트를 수행 해야 하는 작업을 사용자에 게 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39526-243">If you find yourself scared to make a change because you have to do a day or two of manual testing on it, you might ask yourself what you have to do process-wise or test-wise so that you can make that change in minutes or at worst no longer than an hour.</span></span> <span data-ttu-id="39526-244">이 작업을 수행 하는 한 가지 전략은 연속 통합 및 지속적인 업데이트를 구현 하는 것입니다 .이에 대해서는 [다음 장에서](continuous-integration-and-continuous-delivery.md)다룰 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-244">One strategy for doing that is to implement continuous integration and continuous delivery, which we'll cover in the [next chapter](continuous-integration-and-continuous-delivery.md).</span></span>

<a id="resources"></a>
## <a name="resources"></a><span data-ttu-id="39526-245">리소스</span><span class="sxs-lookup"><span data-stu-id="39526-245">Resources</span></span>

<span data-ttu-id="39526-246">분기 전략에 대 한 자세한 내용은 다음 리소스를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-246">For more information about branching strategies, see the following resources:</span></span>

- <span data-ttu-id="39526-247">[Team Foundation Server 2012를 사용 하 여 릴리스 파이프라인 빌드](https://msdn.microsoft.com/library/dn449957.aspx)</span><span class="sxs-lookup"><span data-stu-id="39526-247">[Building a Release Pipeline with Team Foundation Server 2012](https://msdn.microsoft.com/library/dn449957.aspx).</span></span> <span data-ttu-id="39526-248">Microsoft 패턴 및 사례 설명서</span><span class="sxs-lookup"><span data-stu-id="39526-248">Microsoft Patterns and Practices documentation.</span></span> <span data-ttu-id="39526-249">분기 전략에 대 한 설명은 6 장을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-249">See chapter 6 for a discussion of branching strategies.</span></span> <span data-ttu-id="39526-250">기능은 기능 분기를 전환 하 고 기능에 대 한 분기를 사용 하는 경우 단기 (몇 시간 또는 며칠)를 유지 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-250">Advocates feature toggles over feature branches, and if branches for features are used, advocates keeping them short-lived (hours or days at most).</span></span>
- <span data-ttu-id="39526-251">[버전 제어 가이드](https://aka.ms/vsarsolutions).</span><span class="sxs-lookup"><span data-stu-id="39526-251">[Version Control Guide](https://aka.ms/vsarsolutions).</span></span> <span data-ttu-id="39526-252">ALM Rangers의 분기 전략에 대 한 가이드입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-252">Guide to branching strategies by the ALM Rangers.</span></span> <span data-ttu-id="39526-253">다운로드 탭에서 분기 전략 .pdf를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-253">See Branching Strategies.pdf on the Downloads tab.</span></span>
- <span data-ttu-id="39526-254">[소프트웨어 개발 기능 전환](https://msdn.microsoft.com/magazine/dn683796.aspx)</span><span class="sxs-lookup"><span data-stu-id="39526-254">[Software Development with Feature Toggles](https://msdn.microsoft.com/magazine/dn683796.aspx).</span></span> <span data-ttu-id="39526-255">MSDN Magazine 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-255">MSDN Magazine article.</span></span>
- <span data-ttu-id="39526-256">[기능을 설정/해제](http://martinfowler.com/bliki/FeatureToggle.html)합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-256">[Feature Toggle](http://martinfowler.com/bliki/FeatureToggle.html).</span></span> <span data-ttu-id="39526-257">Martin Fowler의 블로그에서 기능 설정/해제/기능 플래그를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-257">Introduction to feature toggles / feature flags on Martin Fowler's blog.</span></span>
- <span data-ttu-id="39526-258">[기능이 Vs 기능 분기를 전환](http://geekswithblogs.net/Optikal/archive/2013/02/10/152069.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-258">[Feature Toggles vs Feature Branches](http://geekswithblogs.net/Optikal/archive/2013/02/10/152069.aspx).</span></span> <span data-ttu-id="39526-259">다른 블로그 게시물의 기능을 설정 하는 방법에 대 한 자세한 내용은 Dylan Smith.</span><span class="sxs-lookup"><span data-stu-id="39526-259">Another blog post about feature toggles, by Dylan Smith.</span></span>

<span data-ttu-id="39526-260">원본 제어 리포지토리에 유지 하지 않아야 하는 중요 한 정보를 처리 하는 방법에 대 한 자세한 내용은 다음 리소스를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-260">For more information about how to handle sensitive information that should not be kept in source control repositories, see the following resources:</span></span>

- <span data-ttu-id="39526-261">[ASP.NET 및 Azure App Service에 암호 및 기타 중요 한 데이터를 배포 하기 위한 모범 사례](../../../../identity/overview/features-api/best-practices-for-deploying-passwords-and-other-sensitive-data-to-aspnet-and-azure.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-261">[Best practices for deploying passwords and other sensitive data to ASP.NET and Azure App Service](../../../../identity/overview/features-api/best-practices-for-deploying-passwords-and-other-sensitive-data-to-aspnet-and-azure.md).</span></span>
- <span data-ttu-id="39526-262">[Azure 웹 사이트: 응용 프로그램 문자열 및 연결 문자열 작동 방식](https://azure.microsoft.com/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/)입니다.</span><span class="sxs-lookup"><span data-stu-id="39526-262">[Azure Web Sites: How Application Strings and Connection Strings Work](https://azure.microsoft.com/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/).</span></span> <span data-ttu-id="39526-263">*Web.config 파일의* `appSettings` 및 `connectionStrings` 데이터를 재정의 하는 Azure 기능을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="39526-263">Explains the Azure feature that overrides `appSettings` and `connectionStrings` data in the *Web.config* file.</span></span>
- <span data-ttu-id="39526-264">[Stefan Schackow를 사용 하 여 Azure 웹 사이트의 사용자 지정 구성 및 응용 프로그램 설정](https://azure.microsoft.com/documentation/videos/configuration-and-app-settings-of-azure-web-sites/)</span><span class="sxs-lookup"><span data-stu-id="39526-264">[Custom configuration and application settings in Azure Web Sites - with Stefan Schackow](https://azure.microsoft.com/documentation/videos/configuration-and-app-settings-of-azure-web-sites/).</span></span>

<span data-ttu-id="39526-265">중요 한 정보를 소스 제어에서 제외 하는 다른 방법에 대 한 자세한 내용은 [ASP.NET MVC: 소스 제어에서 비공개 설정 유지](http://typecastexception.com/post/2014/04/06/ASPNET-MVC-Keep-Private-Settings-Out-of-Source-Control.aspx)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="39526-265">For information about other methods for keeping sensitive information out of source control, see [ASP.NET MVC: Keep Private Settings Out of Source Control](http://typecastexception.com/post/2014/04/06/ASPNET-MVC-Keep-Private-Settings-Out-of-Source-Control.aspx).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="39526-266">[이전](automate-everything.md)
> [다음](continuous-integration-and-continuous-delivery.md)</span><span class="sxs-lookup"><span data-stu-id="39526-266">[Previous](automate-everything.md)
[Next](continuous-integration-and-continuous-delivery.md)</span></span>
