---
uid: signalr/overview/performance/signalr-connection-density-testing-with-crank
title: 크랭크를 사용 하 여 연결 밀도 테스트 SignalR Microsoft Docs
author: bradygaster
description: Crank를 사용하여 SignalR 연결 밀도 테스트
ms.author: bradyg
ms.date: 02/22/2015
ms.assetid: 148d9ca7-1af1-44b6-a9fb-91e261b9b463
msc.legacyurl: /signalr/overview/performance/signalr-connection-density-testing-with-crank
msc.type: authoredcontent
ms.openlocfilehash: 901e039fbb81651ed18d560c99745b7e7f716e01
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78449873"
---
# <a name="signalr-connection-density-testing-with-crank"></a><span data-ttu-id="c7c7d-103">Crank를 사용하여 SignalR 연결 밀도 테스트</span><span class="sxs-lookup"><span data-stu-id="c7c7d-103">SignalR Connection Density Testing with Crank</span></span>

<span data-ttu-id="c7c7d-104">만든 사람 [Tom FitzMacken](https://github.com/tfitzmac)</span><span class="sxs-lookup"><span data-stu-id="c7c7d-104">by [Tom FitzMacken](https://github.com/tfitzmac)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="c7c7d-105">이 문서에서는 크랭크 도구를 사용 하 여 여러 시뮬레이트된 클라이언트를 사용 하 여 응용 프로그램을 테스트 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-105">This article describes how to use the Crank tool to test an application with multiple simulated clients.</span></span>

<span data-ttu-id="c7c7d-106">응용 프로그램이 호스팅 환경 (Azure 웹 역할, IIS 또는 Owin를 사용 하 여 자체 호스팅)에서 실행 되 면 크랭크 도구를 사용 하 여 응용 프로그램의 응답을 높은 수준의 연결 밀도로 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-106">Once your application is running in its hosting environment (either an Azure web role, IIS, or self-hosted using Owin), you can test application's response to a high level of connection density using the Crank tool.</span></span> <span data-ttu-id="c7c7d-107">호스팅 환경은 인터넷 정보 서비스 (IIS) 서버, Owin 호스트 또는 Azure 웹 역할 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-107">The hosting environment can be an Internet Information Services (IIS) server, an Owin host, or an Azure web role.</span></span> <span data-ttu-id="c7c7d-108">참고: Azure App Service Web Apps에는 성능 카운터를 사용할 수 없으므로 연결 밀도 테스트에서 성능 데이터를 가져올 수 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="c7c7d-108">(Note: Performance counters are not available on Azure App Service Web Apps, so you will not be able to get performance data from a connection density test.)</span></span>

<span data-ttu-id="c7c7d-109">연결 밀도는 서버에서 설정할 수 있는 동시 TCP 연결 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-109">Connection Density refers to the number of simultaneous TCP connections that can be established on a server.</span></span> <span data-ttu-id="c7c7d-110">각 TCP 연결에는 자체 오버 헤드가 발생 하 고 많은 수의 유휴 연결을 열면 결국 메모리 병목 현상이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-110">Each TCP connection incurs its own overhead, and opening a large number of idle connections will eventually create a memory bottleneck.</span></span>

<span data-ttu-id="c7c7d-111">[SignalR 코드 베이스](https://github.com/signalr/signalr) 에는 **크랭크**라는 부하 테스트 도구가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-111">[The SignalR codebase](https://github.com/signalr/signalr) includes a load-testing tool called **Crank**.</span></span> <span data-ttu-id="c7c7d-112">최신 버전의 크랭크는 GitHub의 [Dev 분기](https://github.com/SignalR/signalr/tree/dev) 에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-112">The latest version of Crank can be found in [the Dev branch](https://github.com/SignalR/signalr/tree/dev) on GitHub.</span></span> <span data-ttu-id="c7c7d-113">[여기](https://github.com/SignalR/SignalR/archive/dev.zip)에서 SignalR Codebase의 Dev 분기의 Zip 보관 파일을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-113">You can download a Zip archive of the Dev branch of the SignalR codebase [here](https://github.com/SignalR/SignalR/archive/dev.zip).</span></span>

<span data-ttu-id="c7c7d-114">크랭크는 서버 하드웨어에서 가능한 유휴 연결의 총 수를 계산 하기 위해 서버 메모리를 완전히 포화 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-114">Crank may be used to fully saturate the server's memory in order to calculate the total number of idle connections possible on the server hardware.</span></span> <span data-ttu-id="c7c7d-115">또는 크랭크를 사용 하 여 특정 수 또는 특정 메모리 임계값에 도달할 때까지 연결을 설정 하 여 특정 메모리 압력의 양에 따라 서버를 부하 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-115">Alternatively, you may also use Crank to load test the server under a certain amount of memory pressure, by ramping up connections until a specific count or a specific memory threshold is reached.</span></span>

<span data-ttu-id="c7c7d-116">테스트할 때 원격 클라이언트를 사용 하 여 리소스 (예: TCP 연결 및 메모리)에 대 한 경쟁을 방지 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-116">When testing, it is important to use remote client(s) to avoid any competition for resources (i.e., TCP connections and memory).</span></span> <span data-ttu-id="c7c7d-117">클라이언트를 모니터링 하 여 서버가 전체 용량 (메모리 또는 CPU)에 도달 하는 것을 방해할 수 있는 병목 현상이 발생 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-117">Monitor the client(s) to ensure that they are not hitting any bottlenecks that may prevent the server from reaching its full capacity (memory or CPU).</span></span> <span data-ttu-id="c7c7d-118">서버를 완전히 로드 하기 위해 클라이언트 수를 늘려야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-118">You may need to increase the number of clients in order to fully load the server.</span></span>

### <a name="running-a-connection-density-test"></a><span data-ttu-id="c7c7d-119">연결 밀도 테스트 실행</span><span class="sxs-lookup"><span data-stu-id="c7c7d-119">Running a Connection Density Test</span></span>

<span data-ttu-id="c7c7d-120">이 섹션에서는 SignalR 응용 프로그램에서 연결 밀도 테스트를 실행 하는 데 필요한 단계에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-120">This section describes the steps needed to run a connection density test on a SignalR application.</span></span>

1. <span data-ttu-id="c7c7d-121">[SignalR codebase의 Dev 분기](https://github.com/SignalR/SignalR/archive/dev.zip)를 다운로드 하 여 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-121">Download and build the [Dev branch of the SignalR codebase](https://github.com/SignalR/SignalR/archive/dev.zip).</span></span> <span data-ttu-id="c7c7d-122">명령 프롬프트에서 &lt;프로젝트 디렉터리로 이동 하&gt;\src\Microsoft.AspNet.SignalR.Crank\bin\debug.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-122">In a command prompt, navigate to &lt;project directory&gt;\src\Microsoft.AspNet.SignalR.Crank\bin\debug.</span></span>
2. <span data-ttu-id="c7c7d-123">응용 프로그램을 원하는 호스팅 환경에 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-123">Deploy your application to its intended hosting environment.</span></span> <span data-ttu-id="c7c7d-124">응용 프로그램에서 사용 하는 끝점을 기록해 둡니다. 예를 들어 [시작 자습서](../getting-started/tutorial-getting-started-with-signalr.md)에서 만든 응용 프로그램에서 끝점이 `http://<yourhost>:8080/signalr`됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-124">Make a note of the endpoint that your application uses; for example, in the application created in the [Getting Started tutorial](../getting-started/tutorial-getting-started-with-signalr.md), the endpoint is `http://<yourhost>:8080/signalr`.</span></span>
3. <span data-ttu-id="c7c7d-125">서버에 [SignalR 성능 카운터](signalr-performance.md#perfcounters) 를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-125">Install [SignalR performance counters](signalr-performance.md#perfcounters) on the server.</span></span> <span data-ttu-id="c7c7d-126">응용 프로그램이 Azure에서 실행 되는 경우 [Azure 웹 역할에서 SignalR 성능 카운터 사용](using-signalr-performance-counters-in-an-azure-web-role.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-126">If your application is running on Azure, see [Using SignalR Performance Counters in an Azure Web Role](using-signalr-performance-counters-in-an-azure-web-role.md).</span></span>

<span data-ttu-id="c7c7d-127">코드 베이스를 다운로드 하 여 빌드하고 호스트에서 성능 카운터를 설치 하 고 나면 `src\Microsoft.AspNet.SignalR.Crank\bin\Debug` 폴더에서 크랭크 명령줄 도구를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-127">Once you've downloaded and built the codebase, and installed performance counters on your host, the Crank command-line tool can be found in the `src\Microsoft.AspNet.SignalR.Crank\bin\Debug` folder.</span></span>

<span data-ttu-id="c7c7d-128">크랭크 도구에 사용할 수 있는 옵션은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-128">Available options for the Crank tool include:</span></span>

- <span data-ttu-id="c7c7d-129">**/?** : 도움말 화면을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-129">**/?**: Shows the help screen.</span></span> <span data-ttu-id="c7c7d-130">**Url** 매개 변수가 생략 된 경우에도 사용 가능한 옵션이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-130">The available options are also displayed if the **Url** parameter is omitted.</span></span>
- <span data-ttu-id="c7c7d-131">**/Url**: SignalR 연결에 대 한 Url입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-131">**/Url**: The URL for SignalR connections.</span></span> <span data-ttu-id="c7c7d-132">이 매개 변수는 필수 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-132">This parameter is required.</span></span> <span data-ttu-id="c7c7d-133">기본 매핑을 사용 하는 SignalR 응용 프로그램의 경우 경로는 "/signalr"로 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-133">For a SignalR application using the default mapping, the path will end in "/signalr".</span></span>
- <span data-ttu-id="c7c7d-134">**/Ctransport**: 사용 된 전송의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-134">**/Transport**: The name of the transport used.</span></span> <span data-ttu-id="c7c7d-135">기본값은 사용 가능한 가장 적합 한 프로토콜을 선택 하는 `auto`입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-135">The default is `auto`, which will select the best available protocol.</span></span> <span data-ttu-id="c7c7d-136">옵션에는 `WebSockets`, `ServerSentEvents`및 `LongPolling`가 포함 됩니다. Internet Explorer가 아닌 .NET 클라이언트를 사용 하므로`ForeverFrame`는 크랭크에 대 한 옵션이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-136">Options include `WebSockets`, `ServerSentEvents`, and `LongPolling` (`ForeverFrame` is not an option for Crank, since the .NET client rather than Internet Explorer is used).</span></span> <span data-ttu-id="c7c7d-137">SignalR에서 전송을 선택 하는 방법에 대 한 자세한 내용은 [전송 및 대체](../getting-started/introduction-to-signalr.md#transports)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-137">For more information on how SignalR selects transports, see [Transports and Fallbacks](../getting-started/introduction-to-signalr.md#transports).</span></span>
- <span data-ttu-id="c7c7d-138">**/BatchSize**: 각 일괄 처리에 추가 된 클라이언트의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-138">**/BatchSize**: The number of clients added in each batch.</span></span> <span data-ttu-id="c7c7d-139">기본값은 50입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-139">The default is 50.</span></span>
- <span data-ttu-id="c7c7d-140">**/Connectinterval**: 연결을 추가 하는 간격 (밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-140">**/ConnectInterval**: The interval in milliseconds between adding connections.</span></span> <span data-ttu-id="c7c7d-141">기본값은 500입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-141">The default is 500.</span></span>
- <span data-ttu-id="c7c7d-142">**/Sconnections**: 응용 프로그램을 로드 테스트 하는 데 사용 되는 연결 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-142">**/Connections**: The number of connections used to load-test the application.</span></span> <span data-ttu-id="c7c7d-143">기본값은 10만입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-143">The default is 100,000.</span></span>
- <span data-ttu-id="c7c7d-144">**/Connecttimeout**: 테스트를 중단 하기 전 까지의 제한 시간 (초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-144">**/ConnectTimeout**: The timeout in seconds before aborting the test.</span></span> <span data-ttu-id="c7c7d-145">기본값은 300입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-145">The default is 300.</span></span>
- <span data-ttu-id="c7c7d-146">**Minservermbytes**: 도달할 최소 서버 메가바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-146">**MinServerMBytes**: The minimum server megabytes to reach.</span></span> <span data-ttu-id="c7c7d-147">기본값은 500입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-147">The default is 500.</span></span>
- <span data-ttu-id="c7c7d-148">**Sendbytes**: 서버에 전송 된 페이로드의 크기 (바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-148">**SendBytes**: The size of the payload sent to the server in bytes.</span></span> <span data-ttu-id="c7c7d-149">기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-149">The default is 0.</span></span>
- <span data-ttu-id="c7c7d-150">**Sendinterval**: 서버에 대 한 메시지 간의 지연 시간 (밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-150">**SendInterval**: The delay in milliseconds between messages to the server.</span></span> <span data-ttu-id="c7c7d-151">기본값은 500입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-151">The default is 500.</span></span>
- <span data-ttu-id="c7c7d-152">**SendTimeout**: 서버에 대 한 메시지의 제한 시간 (밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-152">**SendTimeout**: The timeout in milliseconds for messages to the server.</span></span> <span data-ttu-id="c7c7d-153">기본값은 300입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-153">The default is 300.</span></span>
- <span data-ttu-id="c7c7d-154">**Controllerurl**: 한 클라이언트가 컨트롤러 허브를 호스트 하는 url입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-154">**ControllerUrl**: The Url where one client will host a controller hub.</span></span> <span data-ttu-id="c7c7d-155">기본값은 null (컨트롤러 허브 없음)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-155">The default is null (no controller hub).</span></span> <span data-ttu-id="c7c7d-156">크랭크 세션이 시작 되 면 컨트롤러 허브가 시작 됩니다. 컨트롤러 허브와 크랭크에 대 한 추가 접촉은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-156">The controller hub is started when the Crank session starts; no further contact between the controller hub and Crank is made.</span></span>
- <span data-ttu-id="c7c7d-157">**Numclients**: 응용 프로그램에 연결할 시뮬레이트된 클라이언트의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-157">**NumClients**: The number of simulated clients to connect to the application.</span></span> <span data-ttu-id="c7c7d-158">기본값은 1입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-158">The default is one.</span></span>
- <span data-ttu-id="c7c7d-159">**Logfile**: 테스트 실행에 대 한 로그 파일의 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-159">**Logfile**: The filename for the logfile for the test run.</span></span> <span data-ttu-id="c7c7d-160">기본값은 `crank.csv`입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-160">The default is `crank.csv`.</span></span>
- <span data-ttu-id="c7c7d-161">**SampleInterval**: 성능 카운터 샘플 사이의 시간 (밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-161">**SampleInterval**: The time in milliseconds between performance counter samples.</span></span> <span data-ttu-id="c7c7d-162">기본값은 1000입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-162">The default is 1000.</span></span>
- <span data-ttu-id="c7c7d-163">**SignalRInstance**: 서버의 성능 카운터에 대 한 인스턴스 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-163">**SignalRInstance**: The instance name for the performance counters on the server.</span></span> <span data-ttu-id="c7c7d-164">기본값은 클라이언트 연결 상태를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-164">The default is to use the client connection state.</span></span>

### <a name="example"></a><span data-ttu-id="c7c7d-165">예제</span><span class="sxs-lookup"><span data-stu-id="c7c7d-165">Example</span></span>

<span data-ttu-id="c7c7d-166">다음 명령은 100 연결을 사용 하 여 "ControllerHub" 라는 허브를 사용 하 여 포트 8080에서 응용 프로그램을 호스트 하는 Azure에서 `pfsignalr` 이라는 사이트를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7c7d-166">The following command will test a site called `pfsignalr` on Azure that hosts an application on port 8080 with a hub named "ControllerHub", using 100 connections.</span></span>

`crank /Connections:100 /Url:http://pfsignalr.cloudapp.net:8080/signalr`
