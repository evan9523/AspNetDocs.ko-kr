---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: SignalR의 연결 수명 이벤트 이해 및 처리 | Microsoft Docs
author: bradygaster
description: 이 문서에서는 허브 API에 의해 노출 되는 이벤트를 사용 하는 방법을 설명 합니다.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: c62ec20b453cee3249eb894ecd75013b57d078f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/21/2020
ms.locfileid: "92345224"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="fc3bb-103">SignalR의 연결 수명 이벤트 이해 및 처리</span><span class="sxs-lookup"><span data-stu-id="fc3bb-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="fc3bb-104">이 문서에서는 사용자가 처리할 수 있는 SignalR 연결, 다시 연결 및 연결 끊기 이벤트와, 구성할 수 있는 시간 제한 및 keepalive 설정에 대 한 개요를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="fc3bb-105">이 문서에서는 SignalR 및 연결 수명 이벤트를 이미 알고 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="fc3bb-106">SignalR에 대 한 소개는 [SignalR 소개](../getting-started/introduction-to-signalr.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="fc3bb-107">연결 수명 이벤트 목록은 다음 리소스를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="fc3bb-108">허브 클래스에서 연결 수명 이벤트를 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="fc3bb-109">JavaScript 클라이언트에서 연결 수명 이벤트를 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="fc3bb-110">.NET 클라이언트에서 연결 수명 이벤트를 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="fc3bb-111">이 항목에서 사용 되는 소프트웨어 버전</span><span class="sxs-lookup"><span data-stu-id="fc3bb-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="fc3bb-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="fc3bb-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="fc3bb-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="fc3bb-113">.NET 4.5</span></span>
> - <span data-ttu-id="fc3bb-114">SignalR 버전 2</span><span class="sxs-lookup"><span data-stu-id="fc3bb-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="fc3bb-115">이 항목의 이전 버전</span><span class="sxs-lookup"><span data-stu-id="fc3bb-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="fc3bb-116">이전 버전의 SignalR에 대 한 자세한 내용은 [SignalR 이전 버전](../older-versions/index.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="fc3bb-117">질문 및 설명</span><span class="sxs-lookup"><span data-stu-id="fc3bb-117">Questions and comments</span></span>
>
> <span data-ttu-id="fc3bb-118">이 자습서와 페이지 맨 아래에 있는 의견에서 개선할 수 있는 방법에 대 한 의견을 남겨 주세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="fc3bb-119">자습서와 직접 관련 되지 않은 질문이 있는 경우 [ASP.NET SignalR 포럼](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) 또는 [StackOverflow.com](http://stackoverflow.com/)에 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="fc3bb-120">개요</span><span class="sxs-lookup"><span data-stu-id="fc3bb-120">Overview</span></span>

<span data-ttu-id="fc3bb-121">이 자료에는 다음과 같은 섹션이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="fc3bb-122">연결 수명 용어 및 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="fc3bb-123">SignalR 연결, 전송 연결 및 실제 연결</span><span class="sxs-lookup"><span data-stu-id="fc3bb-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="fc3bb-124">전송 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="fc3bb-125">클라이언트 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="fc3bb-126">서버 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="fc3bb-127">시간 제한 및 keepalive 설정</span><span class="sxs-lookup"><span data-stu-id="fc3bb-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="fc3bb-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="fc3bb-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="fc3bb-129">Disconnecttimeout은</span><span class="sxs-lookup"><span data-stu-id="fc3bb-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="fc3bb-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="fc3bb-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="fc3bb-131">시간 제한 및 keepalive 설정을 변경 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="fc3bb-132">사용자에 게 연결이 끊어지지 않도록 알리는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="fc3bb-133">지속적으로 다시 연결 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="fc3bb-134">서버 코드에서 클라이언트의 연결을 끊는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="fc3bb-135">연결 끊기 이유 검색</span><span class="sxs-lookup"><span data-stu-id="fc3bb-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="fc3bb-136">API 참조 항목에 대 한 링크는 .NET 4.5 버전의 API에 대 한 링크입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="fc3bb-137">.NET 4를 사용 하 [는 경우 .net 4 버전의 API 항목](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="fc3bb-138">연결 수명 용어 및 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="fc3bb-139">`OnReconnected`SignalR Hub의 이벤트 처리기는 `OnConnected` `OnDisconnected` 지정 된 클라이언트에 대해 바로 다음에 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="fc3bb-140">연결을 끊지 않고 다시 연결할 수 있는 이유는 SignalR에서 "연결" 이라는 단어를 사용 하는 몇 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="fc3bb-141">SignalR 연결, 전송 연결 및 실제 연결</span><span class="sxs-lookup"><span data-stu-id="fc3bb-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="fc3bb-142">이 문서는 *SignalR 연결*, *전송 연결*및 *실제 연결*을 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="fc3bb-143">**SignalR 연결은** SignalR API에서 유지 관리 되 고 연결 ID에 의해 고유 하 게 식별 되는 클라이언트와 서버 URL 간의 논리적 관계를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="fc3bb-144">이 관계에 대 한 데이터는 SignalR에서 유지 관리 되며 전송 연결을 설정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="fc3bb-145">`Stop`SignalR가 손실 된 전송 연결을 다시 설정 하려고 시도 하는 동안 클라이언트에서 메서드를 호출 하거나 시간 제한에 도달할 때 관계는 end 및 SignalR 데이터를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="fc3bb-146">**전송 연결은** 클라이언트와 서버 간의 논리적 관계를 나타내며,이는 네 가지 전송 Api (websocket, 서버에서 보낸 이벤트, 무한 프레임 또는 긴 폴링) 중 하나에서 유지 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="fc3bb-147">SignalR는 전송 API를 사용 하 여 전송 연결을 만들며 전송 API는 전송 연결을 만들기 위해 실제 네트워크 연결이 있는지 여부에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="fc3bb-148">SignalR가 종료 되거나 전송 API가 물리적 연결이 끊어지는 것을 감지 하면 전송 연결이 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="fc3bb-149">**물리적 연결은** 클라이언트 컴퓨터와 서버 컴퓨터 간의 통신을 용이 하 게 하는 실제 네트워크 링크 (와이어, 무선 신호, 라우터 등)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="fc3bb-150">전송 연결을 설정 하려면 물리적 연결이 있어야 하며 SignalR 연결을 설정 하려면 전송 연결을 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="fc3bb-151">그러나이 항목의 뒷부분에서 설명 하는 것 처럼 물리적 연결의 중단은 항상 전송 연결 또는 SignalR 연결을 즉시 종료 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="fc3bb-152">다음 다이어그램에서 SignalR 연결은 허브 API 및 PersistentConnection API SignalR 계층으로 표시 되 고 전송 연결은 전송 계층으로 표시 되며 실제 연결은 서버와 클라이언트 사이의 줄로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 아키텍처 다이어그램](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="fc3bb-154">`Start`SignalR client에서 메서드를 호출 하면 서버에 대 한 실제 연결을 설정 하는 데 필요한 모든 정보가 포함 된 SignalR 클라이언트 코드를 제공 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="fc3bb-155">SignalR client 코드는이 정보를 사용 하 여 HTTP 요청을 수행 하 고 네 가지 전송 방법 중 하나를 사용 하는 실제 연결을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="fc3bb-156">전송 연결에 실패 하거나 서버에 오류가 발생 하면 클라이언트에 동일한 SignalR URL에 대 한 새 전송 연결을 자동으로 다시 설정 하는 데 필요한 정보가 여전히 있으므로 SignalR 연결이 즉시 중단 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="fc3bb-157">이 시나리오에서는 사용자 응용 프로그램의 개입이 관여 하지 않으며, SignalR 클라이언트 코드가 새 전송 연결을 설정 하는 경우 새 SignalR 연결을 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="fc3bb-158">SignalR 연결의 연속성은 메서드를 호출할 때 생성 되는 연결 ID가 변경 되지 않는다는 사실에 반영 됩니다 `Start` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="fc3bb-159">`OnReconnected`전송 연결이 손실 된 후 자동으로 다시 설정 되 면 허브의 이벤트 처리기가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="fc3bb-160">`OnDisconnected`이벤트 처리기는 SignalR 연결이 끝날 때 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="fc3bb-161">SignalR 연결은 다음과 같은 방법으로 끝날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="fc3bb-162">클라이언트에서 메서드를 호출 하면 `Stop` 중지 메시지가 서버로 전송 되 고 클라이언트와 서버 모두 SignalR 연결을 즉시 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="fc3bb-163">클라이언트와 서버 간의 연결이 끊어진 후 클라이언트는 다시 연결을 시도 하 고 클라이언트가 다시 연결 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="fc3bb-164">다시 연결 하려는 시도가 실패 하 고 연결 끊기 제한 시간이 종료 되 면 클라이언트와 서버 모두 SignalR 연결을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="fc3bb-165">클라이언트에서 다시 연결 시도를 중지 하 고 서버가 SignalR 연결의 표시를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="fc3bb-166">클라이언트에서 메서드를 호출 하지 않고 실행을 중지 하면 `Stop` 서버는 클라이언트가 다시 연결 될 때까지 기다린 후 연결 끊기 제한 시간 후에 SignalR 연결을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="fc3bb-167">서버 실행이 중지 되 면 클라이언트는 다시 연결 (전송 연결 다시 만들기) 한 후 연결 끊기 시간 제한 기간 후에 SignalR 연결을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="fc3bb-168">연결 문제가 없고 사용자 응용 프로그램이 메서드를 호출 하 여 SignalR 연결을 종료 하는 경우 `Stop` SignalR 연결과 전송 연결이 동시에 시작 되 고 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="fc3bb-169">다음 섹션에서는 다른 시나리오에 대해 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="fc3bb-170">전송 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="fc3bb-171">실제 연결이 느리거나 연결 중단이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="fc3bb-172">중단의 길이와 같은 요인에 따라 전송 연결이 끊어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="fc3bb-173">그런 다음 SignalR는 전송 연결을 다시 설정 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="fc3bb-174">경우에 따라 전송 연결 API는 중단을 감지 하 여 전송 연결을 삭제 하 고 SignalR는 연결이 끊어지는 것을 즉시 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="fc3bb-175">다른 시나리오에서는 전송 연결 API와 SignalR 모두 연결이 끊어지는 즉시 인식 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="fc3bb-176">긴 폴링을 제외한 모든 전송의 경우 SignalR 클라이언트는 *keepalive* 이라는 함수를 사용 하 여 전송 API에서 검색할 수 없는 연결의 손실을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="fc3bb-177">긴 폴링 연결에 대 한 자세한 내용은이 항목의 뒷부분에 있는 [Timeout 및 keepalive settings](#timeoutkeepalive) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="fc3bb-178">연결이 비활성 상태인 경우 서버는 주기적으로 keepalive 패킷을 클라이언트에 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="fc3bb-179">이 문서를 작성 하는 날짜부터 기본 빈도는 10 초 마다입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="fc3bb-180">클라이언트는 이러한 패킷을 수신 하 여 연결 문제가 있는지를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="fc3bb-181">예상 되는 경우 keepalive 패킷이 수신 되지 않으면 잠시 후 클라이언트에서 속도 저하 또는 중단 같은 연결 문제가 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="fc3bb-182">계속 해 서 keepalive를 수신 하지 않으면 클라이언트에서 연결이 끊어진 것으로 간주 하 고 다시 연결을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="fc3bb-183">다음 다이어그램은 전송 API에서 즉시 인식 되지 않는 실제 연결에 문제가 있는 경우 일반적인 시나리오에서 발생 하는 클라이언트 및 서버 이벤트를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="fc3bb-184">다이어그램은 다음과 같은 경우에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="fc3bb-185">전송은 Websocket, 영원히 프레임 또는 서버에서 보낸 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="fc3bb-186">실제 네트워크 연결의 중단 기간이 다양 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="fc3bb-187">전송 API는 중단을 인식 하지 못하므로 SignalR는 keepalive 기능을 사용 하 여 해당 기능을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![전송 연결이 끊김](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="fc3bb-189">클라이언트가 다시 연결 모드로 전환 되지만 연결 끊기 제한 시간 내에 전송 연결을 설정할 수 없는 경우 서버는 SignalR 연결을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="fc3bb-190">이 경우 서버는 허브의 메서드를 실행 하 `OnDisconnected` 고 클라이언트가 나중에 연결을 관리 하는 경우 클라이언트에 보낼 연결 끊기 메시지를 큐에 대기 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="fc3bb-191">그런 다음 클라이언트가 다시 연결 하면 연결 끊기 명령을 수신 하 고 메서드를 호출 합니다 `Stop` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="fc3bb-192">이 시나리오에서 `OnReconnected` 는 클라이언트가 다시 연결 될 때 실행 되지 않으며 `OnDisconnected` 클라이언트가를 호출할 때 실행 되지 않습니다 `Stop` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="fc3bb-193">다음 다이어그램에서는이 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-193">The following diagram illustrates this scenario.</span></span>

![전송 장애-서버 제한 시간](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="fc3bb-195">클라이언트에서 발생할 수 있는 SignalR 연결 수명 이벤트는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="fc3bb-196">`ConnectionSlow` 클라이언트 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="fc3bb-197">마지막 메시지 또는 keepalive ping을 받은 이후 keepalive 시간 제한 기간의 미리 설정 된 비율이 경과 된 경우 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="fc3bb-198">기본 keepalive 시간 제한 경고 기간은 keepalive 시간 제한의 2/3입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="fc3bb-199">Keepalive 시간 제한은 20 초 이므로 약 13 초에 경고가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="fc3bb-200">기본적으로 서버는 10 초 마다 keepalive ping을 보내고 클라이언트는 2 초 마다 keepalive ping을 확인 합니다 (keepalive 시간 제한 값과 keepalive 시간 제한 경고 값 간의 차이점 중 하나).</span><span class="sxs-lookup"><span data-stu-id="fc3bb-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="fc3bb-201">전송 API가 연결 끊기를 인식 하는 경우 keepalive 시간 제한 경고 기간이 전달 되기 전에 연결 끊기에 대 한 알림이 SignalR 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="fc3bb-202">이 경우 `ConnectionSlow` 이벤트가 발생 하지 않고 SignalR가 이벤트로 직접 이동 `Reconnecting` 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="fc3bb-203">`Reconnecting` 클라이언트 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="fc3bb-204">(A) 전송 API에서 연결이 끊어진 것을 감지 하거나 (b) 마지막 메시지 또는 keepalive ping을 받은 이후 keepalive 시간 제한 기간이 경과 하면 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="fc3bb-205">SignalR 클라이언트 코드를 다시 연결 하는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="fc3bb-206">전송 연결이 끊어질 때 응용 프로그램이 몇 가지 작업을 수행 하도록 하려면이 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="fc3bb-207">기본 keepalive 제한 시간은 현재 20 초입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="fc3bb-208">SignalR이 다시 연결 모드에 있는 동안 클라이언트 코드에서 허브 메서드를 호출 하려고 하면 SignalR가 명령을 보내려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="fc3bb-209">대부분의 경우 이러한 시도는 실패 하지만 경우에 따라 성공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="fc3bb-210">서버에서 전송 되는 이벤트, 영원히 프레임 및 긴 폴링 전송의 경우 SignalR는 두 통신 채널을 사용 합니다. 하나는 클라이언트에서 메시지를 전송 하는 데 사용 하 고 다른 하나는 메시지를 수신 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="fc3bb-211">수신 하는 데 사용 되는 채널은 영구적으로 열린 채널 이며 실제 연결이 중단 될 때 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="fc3bb-212">전송에 사용 되는 채널을 계속 사용할 수 있으므로 물리적 연결이 복원 되 면 수신 채널이 다시 설정 되기 전에 클라이언트에서 서버로의 메서드 호출이 성공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="fc3bb-213">반환 값은 SignalR가 수신에 사용 되는 채널을 다시 열 때까지 수신 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="fc3bb-214">`Reconnected` 클라이언트 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="fc3bb-215">전송 연결이 다시 설정 될 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="fc3bb-216">`OnReconnected`허브에 있는 이벤트 처리기가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="fc3bb-217">`Closed` 클라이언트 이벤트 ( `disconnected` JavaScript의 이벤트)</span><span class="sxs-lookup"><span data-stu-id="fc3bb-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="fc3bb-218">SignalR 클라이언트 코드가 전송 연결을 잃은 후 다시 연결을 시도 하는 동안 연결 끊기 제한 시간이 만료 되 면 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="fc3bb-219">기본 연결 끊기 제한 시간은 30 초입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="fc3bb-220">이 이벤트는 메서드가 호출 되기 때문에 연결이 종료 되는 경우에도 발생 `Stop` 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="fc3bb-221">전송 API에서 검색 되지 않으며 keepalive 시간 제한 경고 기간 보다 오랫동안 서버에서 keepalive ping 수신을 지연 하지 않아 연결 수명 이벤트가 발생 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="fc3bb-222">일부 네트워크 환경은 의도적으로 유휴 연결을 종료 하 고 keepalive 패킷의 또 다른 기능은 이러한 네트워크에서 SignalR 연결이 사용 되 고 있음을 알 수 있도록 하 여이를 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="fc3bb-223">극단적인 경우 기본적으로 keepalive ping의 기본 빈도는 닫힌 연결을 방지 하기에 충분 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="fc3bb-224">이 경우 keepalive ping을 더 자주 전송 하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="fc3bb-225">자세한 내용은이 항목의 뒷부분에 있는 [Timeout 및 keepalive settings](#timeoutkeepalive) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="fc3bb-226">**중요**: 여기에 설명 된 이벤트 시퀀스는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="fc3bb-227">SignalR는이 체계에 따라 예측 가능한 방식으로 연결 수명 이벤트를 발생 시 키 려 하지만 네트워크 이벤트의 많은 변형이 있으며, 전송 Api와 같은 기본 통신 프레임 워크에서이를 처리 하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="fc3bb-228">예를 들어 클라이언트가 다시 연결 하는 `Reconnected` 경우 이벤트가 발생 하지 않을 수도 있고, `OnConnected` 연결을 설정 하지 못한 경우 서버의 처리기가 실행 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="fc3bb-229">이 항목에서는 일반적인 특정 상황에서 일반적으로 생성 되는 효과에 대해서만 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="fc3bb-230">클라이언트 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-230">Client disconnection scenarios</span></span>

<span data-ttu-id="fc3bb-231">브라우저 클라이언트에서 SignalR 연결을 유지 관리 하는 SignalR 클라이언트 코드는 웹 페이지의 JavaScript 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="fc3bb-232">이는 한 페이지에서 다른 페이지로 이동할 때 SignalR 연결이 종료 되어야 하는 이유 이며, 여러 브라우저 창이 나 탭에서 연결 하는 경우 여러 연결 Id를 사용 하 여 여러 연결을 사용 하는 이유입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="fc3bb-233">사용자가 브라우저 창이 나 탭을 닫거나 새 페이지로 이동 하거나 페이지를 새로 고치면 SignalR 클라이언트 코드에서 브라우저 이벤트를 처리 하 고 메서드를 호출 하기 때문에 SignalR 연결이 즉시 종료 됩니다 `Stop` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="fc3bb-234">이러한 시나리오 또는 응용 프로그램에서 메서드를 호출할 때 클라이언트 플랫폼에서 `Stop` `OnDisconnected` 이벤트 처리기가 서버에서 즉시 실행 되 고 클라이언트가 이벤트를 발생 시킵니다 `Closed` .이 이벤트의 이름은 `disconnected` JavaScript로 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="fc3bb-235">클라이언트 응용 프로그램이 나 실행 중인 컴퓨터가 충돌 하거나 절전 모드로 전환 되는 경우 (예: 사용자가 랩톱을 닫을 때) 서버에 발생 한 상황에 대 한 정보가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="fc3bb-236">서버에서 알 수 있듯이, 연결이 중단 되어 클라이언트가 다시 연결 하려고 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="fc3bb-237">따라서 이러한 시나리오에서는 서버가 다시 연결할 수 있는 기회를 제공 하기 위해 대기 하 고, `OnDisconnected` 연결 끊기 제한 시간이 만료 될 때까지 (기본적으로 약 30 초) 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="fc3bb-238">다음 다이어그램에서는이 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-238">The following diagram illustrates this scenario.</span></span>

![클라이언트 컴퓨터 오류](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="fc3bb-240">서버 연결 끊기 시나리오</span><span class="sxs-lookup"><span data-stu-id="fc3bb-240">Server disconnection scenarios</span></span>

<span data-ttu-id="fc3bb-241">서버를 오프 라인으로 전환 하는 경우-다시 부팅 하는 작업이 실패 하 고, 앱 도메인 재활용 등이 발생할 수 있습니다. 또는 전송 API와 SignalR는 서버가 없다는 것을 즉시 알 수 있으며 SignalR는 이벤트를 발생 시 키 지 않고 다시 연결 하려고 시도할 수 있습니다. `ConnectionSlow`</span><span class="sxs-lookup"><span data-stu-id="fc3bb-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="fc3bb-242">클라이언트가 다시 연결 모드로 전환 되는 경우 및 서버를 복구 또는 다시 시작 하거나 새 서버를 온라인 상태로 전환 하는 경우 연결이 끊긴 시간 제한이 만료 되기 전에 클라이언트는 복원 된 서버나 새 서버에 다시 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="fc3bb-243">이 경우 SignalR 연결은 클라이언트에서 계속 진행 `Reconnected` 되 고 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="fc3bb-244">첫 번째 서버에서가 `OnDisconnected` 실행 되지 않으며 새 서버에서는이 이전에 해당 `OnReconnected` `OnConnected` 서버에서 해당 클라이언트에 대해 실행 되지 않은 경우에도이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="fc3bb-245">다시 부팅 또는 앱 도메인 재활용 후 클라이언트에서 동일한 서버에 다시 연결 하는 경우 서버를 다시 시작할 때 이전 연결 작업의 메모리가 없는 경우에도 결과가 동일 하 게 됩니다. 다음 다이어그램에서는 전송 API가 손실 된 연결을 즉시 인식 하 게 되는 것으로 가정 하므로 `ConnectionSlow` 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![서버 오류 및 다시 연결](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="fc3bb-247">연결 끊기 제한 시간 내에 서버를 사용할 수 없게 되 면 SignalR 연결이 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="fc3bb-248">이 시나리오에서 `Closed` `disconnected` JavaScript 클라이언트의 이벤트는 클라이언트에서 발생 하지만 `OnDisconnected` 서버에서 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="fc3bb-249">다음 다이어그램에서는 전송 API가 손실 된 연결을 인식 하지 못하는 것으로 가정 하므로 SignalR keepalive 기능을 통해 감지 되 고 `ConnectionSlow` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![서버 오류 및 시간 제한](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="fc3bb-251">시간 제한 및 keepalive 설정</span><span class="sxs-lookup"><span data-stu-id="fc3bb-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="fc3bb-252">기본 `ConnectionTimeout` , `DisconnectTimeout` 및 값은 `KeepAlive` 대부분의 시나리오에 적합 하지만 환경에 특별 한 요구 사항이 있는 경우 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="fc3bb-253">예를 들어 네트워크 환경에서 5 초 동안 유휴 상태인 연결을 닫으면 keepalive 값을 줄여야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="fc3bb-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="fc3bb-254">ConnectionTimeout</span></span>

<span data-ttu-id="fc3bb-255">이 설정은 전송 연결을 열고 응답을 기다린 후 닫은 후 새 연결을 여는 데 걸리는 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="fc3bb-256">기본값은 110 초입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="fc3bb-257">이 설정은 일반적으로 긴 폴링 전송에만 적용 되는 keepalive 기능이 사용 하지 않도록 설정 된 경우에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="fc3bb-258">다음 다이어그램에서는 긴 폴링 전송 연결에 대 한이 설정의 효과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![긴 폴링 전송 연결](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="fc3bb-260">Disconnecttimeout은</span><span class="sxs-lookup"><span data-stu-id="fc3bb-260">DisconnectTimeout</span></span>

<span data-ttu-id="fc3bb-261">이 설정은 이벤트를 발생 시키기 전에 전송 연결이 끊어진 후 대기 하는 시간을 나타냅니다 `Disconnected` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="fc3bb-262">기본값은 30초입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-262">The default value is 30 seconds.</span></span> <span data-ttu-id="fc3bb-263">를 설정 하면 `DisconnectTimeout` `KeepAlive` 값이 자동으로 1/3로 설정 됩니다 `DisconnectTimeout` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="fc3bb-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="fc3bb-264">KeepAlive</span></span>

<span data-ttu-id="fc3bb-265">이 설정은 유휴 연결을 통해 keepalive 패킷을 보내기 전에 대기 하는 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="fc3bb-266">기본값은 10초입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-266">The default value is 10 seconds.</span></span> <span data-ttu-id="fc3bb-267">이 값은 1/3 보다 커야 합니다 `DisconnectTimeout` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="fc3bb-268">및를 둘 다 설정 하려면 `DisconnectTimeout` `KeepAlive` 다음을 설정 `KeepAlive` `DisconnectTimeout` 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="fc3bb-269">그렇지 않으면 `KeepAlive` `DisconnectTimeout` 시간 제한 값을 자동으로 1/3로 설정 하는 경우 설정을 덮어씁니다 `KeepAlive` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="fc3bb-270">Keepalive 기능을 사용 하지 않도록 설정 하려면를 `KeepAlive` null로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="fc3bb-271">자동으로 Keepalive 기능을 사용 하지 않도록 설정 하는 긴 폴링 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="fc3bb-272">시간 제한 및 keepalive 설정을 변경 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="fc3bb-273">이러한 설정에 대 한 기본값을 변경 하려면 `Application_Start` 다음 예제와 같이 *global.asax* 파일의에 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="fc3bb-274">예제 코드에 표시 된 값은 기본값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="fc3bb-275">사용자에 게 연결이 끊어지지 않도록 알리는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="fc3bb-276">일부 응용 프로그램에서는 연결 문제가 있는 경우 사용자에 게 메시지를 표시 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="fc3bb-277">이 작업을 수행 하는 방법 및 시기에 대 한 몇 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="fc3bb-278">다음 코드 샘플은 생성 된 프록시를 사용 하는 JavaScript 클라이언트를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="fc3bb-279">`connectionSlow`SignalR가 연결 문제를 인식 한 후 다시 연결 모드로 전환 되기 전에 메시지를 표시 하는 이벤트를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="fc3bb-280">`reconnecting`SignalR가 연결 끊기를 인식 하 고 다시 연결 모드로 전환 될 때 메시지를 표시 하는 이벤트를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="fc3bb-281">이벤트를 처리 `disconnected` 하 여 다시 연결 하려는 시도가 시간 초과 되었을 때 메시지를 표시 합니다. 이 시나리오에서 서버와의 연결을 다시 설정 하는 유일한 방법은 `Start` 새 연결 ID를 만드는 메서드를 호출 하 여 SignalR 연결을 다시 시작 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="fc3bb-282">다음 코드 샘플에서는 플래그를 사용 하 여 메서드를 호출 하 여 SignalR 연결에 대 한 일반적인 종료 이후가 아니라 다시 연결 제한 시간 후에만 알림을 실행 하도록 합니다 `Stop` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="fc3bb-283">지속적으로 다시 연결 하는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-283">How to continuously reconnect</span></span>

<span data-ttu-id="fc3bb-284">일부 응용 프로그램에서는 연결이 끊어졌거나 다시 연결 하려는 시도가 시간 초과 된 후 자동으로 다시 설정 하는 것이 좋습니다. 이렇게 하려면 `Start` `Closed` 이벤트 처리기 ( `disconnected` JavaScript 클라이언트의 이벤트 처리기)에서 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="fc3bb-285">`Start`서버 또는 실제 연결을 사용할 수 없을 때이를 너무 자주 수행 하지 않도록 하기 위해를 호출 하기 전에 시간을 기다려야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="fc3bb-286">다음 코드 샘플은 생성 된 프록시를 사용 하는 JavaScript 클라이언트를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="fc3bb-287">모바일 클라이언트에서 알아야 할 잠재적인 문제는 서버 또는 물리적 연결을 사용할 수 없을 때 연속 다시 연결을 시도 하면 불필요 한 배터리가 소모 될 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="fc3bb-288">서버 코드에서 클라이언트의 연결을 끊는 방법</span><span class="sxs-lookup"><span data-stu-id="fc3bb-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="fc3bb-289">SignalR 버전 2에는 클라이언트 연결을 끊는 기본 제공 서버 API가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="fc3bb-290">[나중에이 기능을 추가할 계획이](https://github.com/SignalR/SignalR/issues/2101)있습니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="fc3bb-291">현재 SignalR 릴리스에서 서버와 클라이언트의 연결을 끊는 가장 간단한 방법은 클라이언트에서 disconnect 메서드를 구현 하 고 서버에서 해당 메서드를 호출 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="fc3bb-292">다음 코드 샘플에서는 생성 된 프록시를 사용 하는 JavaScript 클라이언트에 대 한 연결 끊기 메서드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="fc3bb-293">보안-클라이언트 연결 끊기 또는 제안 된 기본 제공 API에 대 한이 방법은 악성 코드를 실행 하는 해킹 클라이언트의 시나리오를 해결 합니다. 클라이언트는 다시 연결 하거나 해킹 당한 코드에서 메서드를 제거 `stopClient` 하거나 수행 하는 작업을 변경할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="fc3bb-294">상태 저장 DOS (서비스 거부) 보호를 구현 하는 적절 한 장소는 프레임 워크 또는 서버 계층이 아니라 프런트 엔드 인프라에 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="fc3bb-295">연결 끊기 이유 검색</span><span class="sxs-lookup"><span data-stu-id="fc3bb-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="fc3bb-296">SignalR 2.1 `OnDisconnect` 은 클라이언트의 제한 시간이 초과 되는 것이 아니라 의도적으로 해제 되었는지 여부를 나타내는 오버 로드를 서버 이벤트에 추가 합니다. `StopCalled` 클라이언트에서 연결을 명시적으로 닫은 경우 매개 변수는 true입니다.</span><span class="sxs-lookup"><span data-stu-id="fc3bb-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="fc3bb-297">JavaScript에서 서버 오류가 발생 하면 클라이언트에서 연결을 끊을 수 있습니다. 오류 정보는로 클라이언트에 전달 됩니다 `$.connection.hub.lastError` .</span><span class="sxs-lookup"><span data-stu-id="fc3bb-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="fc3bb-298">**C # 서버 코드: `stopCalled` 매개 변수**</span><span class="sxs-lookup"><span data-stu-id="fc3bb-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="fc3bb-299">**JavaScript 클라이언트 코드: `lastError` 이벤트에서 액세스 `disconnect` 합니다.**</span><span class="sxs-lookup"><span data-stu-id="fc3bb-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
