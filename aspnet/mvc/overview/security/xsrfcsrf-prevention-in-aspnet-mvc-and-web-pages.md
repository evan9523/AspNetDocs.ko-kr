---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC 및 웹 페이지에서 XSRF/CSRF 방지 | Microsoft Docs
author: Rick-Anderson
description: 교차 사이트 요청 위조 (XSRF 또는 CSRF 라고도 함)은 악의적인 웹 사이트는 interacti 영향을 줄 수는 여기서 웹 호스팅 응용 프로그램에 대 한 공격 하는 중...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: de0e9cc168b9f18fd2bd83329106df45d7551b1a
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59386562"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="b3095-103">ASP.NET MVC 및 웹 페이지에서 XSRF/CSRF 방지</span><span class="sxs-lookup"><span data-stu-id="b3095-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="b3095-104">[Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="b3095-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="b3095-105">교차 사이트 요청 위조 (XSRF 또는 CSRF 라고도 함)은 악의적인 웹 사이트는 클라이언트 브라우저와 해당 브라우저에서 신뢰할 수 있는 웹 사이트 간의 상호 작용에 영향을 줄 가능해 집니다 웹 호스팅 응용 프로그램에 대 한 공격입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="b3095-106">이러한 공격은 웹 사이트로 웹 브라우저 인증 토큰이 모든 요청에 자동으로 보내기 때문에 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="b3095-107">정식 예로 ASP와 같은 인증 쿠키가 있습니다. NET의 폼 인증 티켓입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="b3095-108">그러나 웹 사이트 (예: Windows 인증, 기본 및 등) 영구적 인증 메커니즘을 사용 하는 이러한 공격 대상이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="b3095-109">XSRF 공격은 피싱 공격과 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="b3095-110">피싱 공격 피해자의 상호 작용을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="b3095-111">피싱 공격, 악의적인 웹 사이트는 대상 웹 사이트를 모방 하 고 피해자는 공격자에 게 중요 한 정보를 제공 속일 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="b3095-112">XSRF 공격에서는 종종 피해자의 필요한 없습니다 상호 작용이입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="b3095-113">대신, 공격자가 자동으로 대상 웹 사이트에 모든 관련 쿠키를 전송 하는 브라우저에서 신뢰 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="b3095-114">자세한 내용은 참조는 [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="b3095-115">공격 분석</span><span class="sxs-lookup"><span data-stu-id="b3095-115">Anatomy of an attack</span></span>

<span data-ttu-id="b3095-116">XSRF 공격을 단계별로 사용자를 일부 온라인 뱅킹 트랜잭션을 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="b3095-117">이 사용자는 WoodgroveBank.com 및에서는 로그 응답 헤더는 인증 쿠키를 포함 하는 데이 시점에서 먼저 방문:</span><span class="sxs-lookup"><span data-stu-id="b3095-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="b3095-118">인증 쿠키는 세션 쿠키 이기 때문에 자동으로 지워집니다 브라우저에서 브라우저 프로세스가 종료 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="b3095-119">그러나 그 전 까지는 브라우저 자동으로 포함 됩니다 WoodgroveBank.com 각 요청과 함께 쿠키입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="b3095-120">이제 사용자가 자신이 은행 사이트의 양식을 작성 하 고 브라우저 요청이 서버에 다른 계정에 1000 달러를 전송 하려는:</span><span class="sxs-lookup"><span data-stu-id="b3095-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="b3095-121">이 작업에 부작용 (현금 트랜잭션 시작 함)에 있으므로 은행 사이트는이 작업을 시작 하기 위해 HTTP POST를 요구 하도록 선택 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="b3095-122">서버 요청에서 인증 토큰을 읽습니다, 그리고 현재 사용자의 계정 번호 조회, 자금이 충분 존재 하는 대상 계정에 트랜잭션 시작을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="b3095-123">온라인 완료를 은행 만듭니다 사용자 은행 사이트에서 떨어진 이동 하 고 웹에서 다른 위치를 방문.</span><span class="sxs-lookup"><span data-stu-id="b3095-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="b3095-124">내에 포함 된 페이지에 다음 태그를 포함 하는 – fabrikam.com – 이러한 사이트 중 하나는 &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="b3095-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="b3095-125">그러면이이 요청에 브라우저를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="b3095-126">공격자가 악용 사용자 대상 웹 사이트에 대 한 유효한 인증 토큰이 있을 수 있습니다 하 고 자신이 사용 하 여 Javascript의 작은 코드 조각을 브라우저가 자동으로 대상 사이트에 HTTP POST를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="b3095-127">인증 토큰이 여전히 유효한 경우 은행 사이트 공격자의 계정으로 250 달러의 전송을 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="b3095-128">비효율적인 완화</span><span class="sxs-lookup"><span data-stu-id="b3095-128">Ineffective mitigations</span></span>

<span data-ttu-id="b3095-129">위 시나리오에서 WoodgroveBank.com SSL을 통해 액세스 하 고 있던 하는 SSL 전용 인증 쿠키가 팩트 없음을 공격을 차단할 수 있는 충분 한 흥미로운 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="b3095-130">공격자는 지정할 수는 [URI 체계](http://en.wikipedia.org/wiki/URI_scheme) (https)에 만듭니다 &lt;폼&gt; 요소와 브라우저 계속 전송 됩니다 만료 되지 않은 쿠키 대상 사이트에 이러한 쿠키는 URI와 일치 의도 한 대상의 체계입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="b3095-131">주장할 수 사용자 하지 신뢰할 수 있는 사이트 온라인 안전 하 게 유지 하는 데 도움이 됩니다만 방문으로 신뢰할 수 없는 사이트를 방문 하 고 단순히 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="b3095-132">몇 가지 사실, 이지만 불행히도이 권장 사항은 사실상 불가능 항상.</span><span class="sxs-lookup"><span data-stu-id="b3095-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="b3095-133">아마도 사용자 "신뢰" 지역 뉴스 사이트 ConsolidatedMessenger 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="b3095-134">ConsolidatedMessenger.com 및 이동 하는 대신, 사이트 방문 있지만 해당 사이트는 XSS 취약점으로 인 한 공격자가 fabrikam.com에서 실행 되는 코드의 같은 조각을 삽입할 수 있는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="b3095-135">들어오는 요청이 있는지 확인할 수 있습니다는 [Referer 헤더](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) 도메인을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="b3095-136">타사 도메인에서 모르게 제출 된 요청이 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="b3095-137">그러나 일부 사용자 개인 정보 보호를 위해 브라우저의 Referer 헤더를 사용 하지 않도록 설정 하 고 공격자가 희생자 안전 하지 않은 특정 소프트웨어가 설치 되어 있으면 해당 헤더를 스푸핑할 경우에 따라 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="b3095-138">확인 합니다 [Referer 헤더](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) XSRF 공격을 방지 하는 보안 방법으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="b3095-139">웹 스택 런타임 XSRF 완화</span><span class="sxs-lookup"><span data-stu-id="b3095-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="b3095-140">ASP.NET 웹 스택 런타임에서의 변형을 사용 하 여 [동기화 장치 토큰 패턴이](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) XSRF 공격 으로부터 보호 하기.</span><span class="sxs-lookup"><span data-stu-id="b3095-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="b3095-141">일반 동기화 장치 토큰 패턴의 형식은 두 ANTI-XSRF 토큰 (인증 토큰) 외에도 각 HTTP POST를 사용 하 여 서버에 제출 되는: 쿠키 및 형식 값으로 다른 하나의 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="b3095-142">ASP.NET 런타임에 의해 생성 된 토큰 값이 결정적 또는 공격자가 예측 가능한있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="b3095-143">토큰을 제출 되 면 서버에서 토큰이 모두 비교 확인을 전달 하는 경우에 계속 진행 하는 요청을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="b3095-144">XSRF 요청 인증 *세션 토큰* 현재 해당 페이로드의 다음 정보를 포함 하는 HTTP 쿠키로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="b3095-145">구성 된 임의의 128 비트 식별자를 보안 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="b3095-146">다음 이미지에서는 XSRF 요청 확인 세션 토큰을 Internet Explorer F12 개발자 도구를 사용 하 여 표시를 보여 줍니다. (이 현재 구현 하며 제목은 변경 될 가능성이 훨씬.)</span><span class="sxs-lookup"><span data-stu-id="b3095-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="b3095-147">*필드 토큰* 으로 저장 되는 `<input type="hidden" />` 페이로드는 다음 정보를 포함 하 고:</span><span class="sxs-lookup"><span data-stu-id="b3095-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="b3095-148">로그인 한 사용자의 사용자 이름 (인증) 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="b3095-149">제공한 모든 추가 데이터를 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="b3095-150">ANTI-XSRF 토큰의 페이로드는 암호화 되 고 서명, 토큰을 검사 하려면 도구를 사용 하는 경우에 사용자를 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="b3095-151">암호화 서비스에서 제공 하는 웹 응용 프로그램을 ASP.NET 4.0을 대상으로 하는 경우는 [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="b3095-152">ASP.NET 4.5를 대상으로 웹 응용 프로그램 또는 더 높은 암호화 서비스에서 제공 하는 경우는 [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) 더 나은 성능, 확장성 및 보안을 제공 하는 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="b3095-153">자세한 내용은 다음 블로그 게시물을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3095-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="b3095-154">ASP.NET 4.5의에서 향상 된 암호화 기능, (태평양 표준시)입니다. 1</span><span class="sxs-lookup"><span data-stu-id="b3095-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="b3095-155">ASP.NET 4.5의에서 향상 된 암호화 기능, (태평양 표준시)입니다. 2</span><span class="sxs-lookup"><span data-stu-id="b3095-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="b3095-156">ASP.NET 4.5의에서 향상 된 암호화 기능, (태평양 표준시)입니다. 3</span><span class="sxs-lookup"><span data-stu-id="b3095-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="b3095-157">토큰 생성</span><span class="sxs-lookup"><span data-stu-id="b3095-157">Generating the tokens</span></span>

<span data-ttu-id="b3095-158">ANTI-XSRF 토큰을 생성 하기 위해 호출 된 [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC 뷰에서 메서드 또는 @AntiForgery.GetHtmlRazor 페이지에서 ().</span><span class="sxs-lookup"><span data-stu-id="b3095-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="b3095-159">런타임에서 다음 단계를 수행 다음 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="b3095-160">현재 HTTP 요청은 이미 ANTI-XSRF 세션 토큰을 포함 하는 경우 (ANTI-XSRF 쿠키 \_ \_RequestVerificationToken), 보안 토큰에서 추출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="b3095-161">ANTI-XSRF 세션 토큰을 HTTP 요청에 없으면, 보안 토큰의 추출이 실패할 경우 새 임의 ANTI-XSRF 토큰 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="b3095-162">ANTI-XSRF 필드 토큰을 보안 토큰 (1) 위의 단계에서 현재 로그인 한 사용자의 id를 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="b3095-163">(사용자 id를 확인 하는 방법은 참조 합니다 **[특별 한 지원 사용 하 여 시나리오](#_Scenarios_with_special)** 섹션 아래.) 또한 경우는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) 은 구성, 런타임에서 호출 됩니다 해당 [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) 메서드 필드 토큰에서 반환된 된 문자열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="b3095-164">(참조를 **[구성 및 확장성](#_Configuration_and_extensibility)** 자세한 내용은 섹션입니다.)</span><span class="sxs-lookup"><span data-stu-id="b3095-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="b3095-165">새 ANTI-XSRF 토큰 (1) 단계에서 생성 된 경우 새 세션 토큰을 포함 하기 위해 만들어지고 아웃 바운드 HTTP 쿠키 컬렉션에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="b3095-166">단계 (2)에서 필드 토큰에서 래핑될를 `<input type="hidden" />` 요소와이 HTML 태그의 반환 값이 됩니다 `Html.AntiForgeryToken()` 또는 `AntiForgery.GetHtml()`합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="b3095-167">토큰 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="b3095-167">Validating the tokens</span></span>

<span data-ttu-id="b3095-168">들어오는 ANTI-XSRF 토큰의 유효성을 검사 하려면 개발자는 다음과 같이 포함 됩니다.는 [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) 게 MVC 작업 또는 컨트롤러 그녀는 호출 특성 `@AntiForgery.Validate()` 그녀의 Razor 페이지에서.</span><span class="sxs-lookup"><span data-stu-id="b3095-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="b3095-169">런타임에서 다음 단계를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="b3095-170">들어오는 세션 토큰 및 필드 토큰을 읽고 각 ANTI-XSRF 토큰을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="b3095-171">ANTI-XSRF 토큰을 생성 하는 루틴의 단계 (2) 당 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="b3095-172">현재 사용자가 인증 되 면 자신의 사용자 이름 토큰을 필드에 저장 된 사용자 이름으로 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="b3095-173">사용자 이름 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-173">The usernames must match.</span></span>
3. <span data-ttu-id="b3095-174">경우는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 구성 된 런타임 호출 해당 *ValidateAdditionalData* 메서드.</span><span class="sxs-lookup"><span data-stu-id="b3095-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="b3095-175">이 메서드는 부울 값을 반환 해야 *true*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="b3095-176">유효성 검사는 성공 하는 경우 계속 하려면 요청은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="b3095-177">유효성 검사에 실패 하는 경우 프레임 워크를 throw 합니다는 *HttpAntiForgeryException*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="b3095-178">오류 상태</span><span class="sxs-lookup"><span data-stu-id="b3095-178">Failure conditions</span></span>

<span data-ttu-id="b3095-179">모든 ASP.NET 웹 스택 런타임에서 v2를 사용 하 여 시작 *HttpAntiForgeryException* 하는 동안 throw 되는 유효성 검사에는 무엇이 잘못 되었는지에 대 한 자세한 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="b3095-180">현재 정의 된 오류 조건은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="b3095-181">세션 토큰 또는 폼 토큰을 요청에 나타나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="b3095-182">세션 토큰 또는 폼 토큰을 읽을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b3095-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="b3095-183">이 가장 일반적인 원인은 일치 하지 않는 버전의 ASP.NET 웹 스택 런타임에서 또는 팜을 실행 하는 팜에서 여기서 합니다 &lt;machineKey&gt; Web.config의 요소는 컴퓨터 간에 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="b3095-184">ANTI-XSRF 토큰 중 하나를 사용 하 여 변조 하 여이 예외를 강제로 Fiddler와 같은 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="b3095-185">세션 토큰 및 필드 토큰을 전환 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="b3095-186">세션 토큰 및 필드 토큰을 일치 하지 않는 보안 토큰을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="b3095-187">필드 토큰 내에 포함 된 사용자 이름에는 현재 로그인 한 사용자의 사용자 이름을 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="b3095-188">합니다 *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 반환 하는 메서드 *false*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="b3095-189">ANTI-XSRF 기능 토큰 생성 또는 유효성 검사 중 추가 검사를 수행할 수도 있습니다 및 이러한 검사 중에 오류가 throw 된 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="b3095-190">참조를 [WIF / ACS 클레임 기반 인증](#_WIF_ACS) 하 고 **[구성 및 확장성](#_Configuration_and_extensibility)** 자세한 내용은 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="b3095-191">특별 한 지원 사용 하 여 시나리오</span><span class="sxs-lookup"><span data-stu-id="b3095-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="b3095-192">익명 인증</span><span class="sxs-lookup"><span data-stu-id="b3095-192">Anonymous authentication</span></span>

<span data-ttu-id="b3095-193">ANTI-XSRF 시스템에는 "anonymous"가 정의 되어 있는 사용자로 익명 사용자에 대 한 특별 한 지원이 포함 되어 있습니다. 여기서는 *IIdentity.IsAuthenticated* 속성이 반환 *false*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="b3095-194">XSRF 보호 (사용자가 인증) 전에 로그인 페이지 및 응용 프로그램 사용 하는 메커니즘을 이외의 사용자 지정 인증 체계를 제공 하는 것이 시나리오로 *IIdentity* 사용자를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="b3095-195">이러한 시나리오를 지원 하려면 해당 세션 및 필드 토큰 128 비트 임의로 생성 된 불투명 식별자는 보안 토큰으로 가입 되어을 기억 하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3095-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="b3095-196">이 보안 토큰이 익명 식별자의 용도로 효과적으로 사용 하도록 사이트를 이동 하는 개별 사용자의 세션 추적 하기 위해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="b3095-197">빈 문자열은 위에서 설명한 생성 및 유효성 검사 루틴에 대 한 사용자 이름 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="b3095-198">WIF / ACS 클레임 기반 인증</span><span class="sxs-lookup"><span data-stu-id="b3095-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="b3095-199">일반적으로 *IIdentity* .NET Framework에 기본 제공 하는 클래스 속성에는 *IIdentity.Name* 는 특정 응용 프로그램 내에서 특정 사용자를 고유 하 게 식별 하는 데 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="b3095-200">예를 들어 *FormsIdentity.Name* (이 해당 데이터베이스에 따라 모든 응용 프로그램에 대해 고유) 멤버 자격 데이터베이스에 저장 된 사용자 이름을 반환 *WindowsIdentity.Name* 반환 합니다 사용자 및 등의 정규화 된 도메인 id입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="b3095-201">이러한 시스템 제공 인증 뿐 아니라 또한 *식별* 응용 프로그램에 대 한 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="b3095-202">클레임 기반 인증 일 경우 다른 한편으로 필요는 없습니다 특정 사용자를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="b3095-203">대신 합니다 *ClaimsPrincipal* 하 고 *ClaimsIdentity* 종류의 집합과 연결 되 *클레임* 인스턴스를 개별 클레임 수 있는 "is 18 + 세 이상인" 또는 " 관리자가 "다른 사용자 계정으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="b3095-204">사용자 식별 필요 하지 않은 이후 런타임에서 사용할 수 없습니다는 *ClaimsIdentity.Name* 이 특정 사용자에 대 한 고유 식별자로는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="b3095-205">팀에서 실제 예제에 표시 위치 *ClaimsIdentity.Name* 반환 *null*(표시) 친숙 한 이름을 반환, 그렇지 않으면 고유 식별자로 사용 하기에 적합 하지 않은 문자열을 반환 합니다. 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="b3095-206">사용 하는 다양 한 클레임 기반 인증을 사용 하는 배포 [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) 특히 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="b3095-207">ACS 개별 개발자가 구성할 수 있습니다 *id 공급자* (ADFS, Microsoft 계정 공급자와 같은 OpenID 공급자 예: yahoo! 등), id 공급자를 반환 하 고 *식별자이름지정*.</span><span class="sxs-lookup"><span data-stu-id="b3095-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="b3095-208">이러한 이름 식별자는 전자 메일 주소와 같은 개인 식별이 가능한 정보 (PII)를 포함할 수 있습니다 또는 같은 개인 식별자 PPID (Private)를 익명화 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="b3095-209">그럼에도 불구 하 고 (id 공급자, 이름 식별자) 튜플 충분히 역할을 특정 사용자에 대 한 적절 한 추적 토큰 그녀는 ASP.NET 웹 스택 런타임에 생성 하는 경우 사용자 이름 대신 튜플을 사용할 수 있도록 사이트를 검색 하는 동안 및 ANTI-XSRF 필드 토큰 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="b3095-210">Id 공급자와 이름 식별자의 특정 Uri는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="b3095-211">(이 참조 하세요 [ACS doc 페이지](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) 자세한.)</span><span class="sxs-lookup"><span data-stu-id="b3095-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="b3095-212">를 생성 하거나 토큰 유효성을 검사할 때 ASP.NET 웹 스택 런타임은 런타임에 시도 형식에 바인딩:</span><span class="sxs-lookup"><span data-stu-id="b3095-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="b3095-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (SDK에 대 한는 WIF.)</span><span class="sxs-lookup"><span data-stu-id="b3095-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="b3095-214">`System.Security.Claims.ClaimsIdentity` (예:.NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="b3095-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="b3095-215">이러한 형식은 존재 하는 경우 현재 사용자의 *IIIIdentity* 구현 또는 서브 클래스 중 형식, ANTI-XSRF 기능 사용 (id 공급자, 이름 식별자)를 생성할 때 사용자 이름 대신 튜플 및 토큰의 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="b3095-216">이러한 튜플이 있는 경우 요청에서 사용 하 여 특정 클레임 기반 인증 메커니즘을 이해 하려면 ANTI-XSRF 시스템을 구성 하는 방법을 개발자에 게 설명 하는 오류와 함께 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="b3095-217">참조 된 **[구성 및 확장성](#_Configuration_and_extensibility)** 자세한 내용은 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="b3095-218">OAuth / OpenID 인증</span><span class="sxs-lookup"><span data-stu-id="b3095-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="b3095-219">마지막으로, ANTI-XSRF 시설에 OAuth 또는 OpenID 인증을 사용 하는 응용 프로그램에 대 한 특별 한 지원이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="b3095-220">이 지원은 추론 기반: 경우 현재 *IIdentity.Name* username 비교를 수행할 수는 다음에 http:// 또는 https:// 로 시작 기본 OrdinalIgnoreCase 비교자를 사용 하지 않고 서 수는 비교자를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="b3095-221">구성 및 확장성</span><span class="sxs-lookup"><span data-stu-id="b3095-221">Configuration and extensibility</span></span>

<span data-ttu-id="b3095-222">경우에 따라 개발자는 엄격 하 게 제어할 ANTI-XSRF 생성 및 유효성 검사 동작을 원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="b3095-223">예를 들어, 아마도 응답에 HTTP 쿠키를 자동으로 추가 하는 MVC 및 Web Pages 도우미의 기본 동작, 아니며 개발자 토큰을 다른 위치를 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="b3095-224">이 지원 하기 위해 두 개의 Api가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="b3095-225">합니다 *GetTokens* 으로 메서드는 입력을 기존 XSRF 요청 확인 세션 토큰 (null 일 수 있음) 및 새 XSRF 요청 확인 세션 토큰 및 필드 토큰을 생성으로 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="b3095-226">토큰은; 장식이 없는 단순히 불투명 문자열 합니다 *formToken* 값은 예를 들어에 래핑되지 않습니다는 &lt;입력&gt; 태그입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="b3095-227">합니다 *newCookieToken* 값이 문제가 발생 하는 경우 null; 일 수는 *oldCookieToken* 값 여전히 유효 하며 없는 새 응답 쿠키를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="b3095-228">호출자 *GetTokens* 는 모든 필요한 응답 쿠키를 유지 하거나; 필요한 태그를 생성 하는 일을 담당 합니다 *GetTokens* 메서드 자체은 부작용으로 응답을 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="b3095-229">합니다 *유효성 검사* 메서드는 들어오는 세션을 사용 하 고 필드 토큰에 대해 앞에서 언급 한 유효성 검사 논리를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="b3095-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="b3095-230">AntiForgeryConfig</span></span>

<span data-ttu-id="b3095-231">개발자는 응용 프로그램에서 ANTI-XSRF 시스템을 구성할 수 있습니다\_시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="b3095-232">구성은은 프로그래밍 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-232">Configuration is programmatic.</span></span> <span data-ttu-id="b3095-233">정적 속성 *AntiForgeryConfig* 종류는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="b3095-234">대부분의 사용자 클레임을 사용 하 여 UniqueClaimTypeIdentifier 속성을 설정 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="b3095-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="b3095-235">**Property**</span></span> | <span data-ttu-id="b3095-236">**설명**</span><span class="sxs-lookup"><span data-stu-id="b3095-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="b3095-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="b3095-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="b3095-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 토큰 생성 하는 동안 추가 데이터를 제공 하 고 토큰 유효성 검사 중 추가 데이터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="b3095-239">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-239">The default value is *null*.</span></span> <span data-ttu-id="b3095-240">자세한 내용은 참조는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="b3095-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="b3095-241">**CookieName**</span></span> | <span data-ttu-id="b3095-242">ANTI-XSRF 세션 토큰은 저장에 사용 되는 HTTP 쿠키의 이름을 제공 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="b3095-243">이 값을 설정 하지 않으면 하는 경우 응용 프로그램의 배포 된 가상 경로 기준으로 이름은 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="b3095-244">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-244">The default value is *null*.</span></span> |
| <span data-ttu-id="b3095-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="b3095-245">**RequireSsl**</span></span> | <span data-ttu-id="b3095-246">ANTI-XSRF 토큰 SSL 보안 채널을 통해 전송할 필요한 지 여부를 결정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="b3095-247">이 값이 *true*, 자동으로 생성 된 쿠키는 "secure" 플래그를 설정 하 고, 있고 ANTI-XSRF Api는 SSL을 통해 전송 되지 않습니다 하는 요청 내에서 호출 된 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="b3095-248">기본값은 *false*입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-248">The default value is *false*.</span></span> |
| <span data-ttu-id="b3095-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="b3095-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="b3095-250">ANTI-XSRF 시스템 클레임 기반 id에 대 한 지원을 비활성화 해야 하는지 여부를 결정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="b3095-251">이 값이 *true*, 시스템은 가정 *IIdentity.Name* 고유한 사용자 식별자로 사용 하기에 적합 한 특수 사례를 시도 하지 것입니다 *IClaimsIdentity*나 *ClClaimsIdentity* 에 설명 된 대로 합니다 [WIF / ACS 클레임 기반 인증](#_WIF_ACS) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="b3095-252">기본값은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-252">The default value is `false`.</span></span> |
| <span data-ttu-id="b3095-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="b3095-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="b3095-254">입력 클레임을 나타내는 문자열입니다는 고유한 사용자 식별자로 사용 하기에 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="b3095-255">이 값이 설정 및 현재 *IIdentity* 여 된 클레임을 기반으로 시스템 형식의 클레임을 추출 하려고 *UniqueClaimTypeIdentifier*, 및 해당 값이 사용 됩니다 대신 사용자의 사용자 이름 필드 토큰을 생성 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="b3095-256">클레임 유형이 없는 경우 시스템 요청에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="b3095-257">기본값은 *null*, 시스템에서 (id 공급자, 이름 식별자)를 사용 해야 함을 나타내는 앞에서 설명한 대로 사용자의 사용자 이름 대신 튜플.</span><span class="sxs-lookup"><span data-stu-id="b3095-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="b3095-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="b3095-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="b3095-259">합니다 *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 형식 개발자가 각 토큰의 추가 데이터를 왕복 하 여 ANTI-XSRF 시스템의 동작을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="b3095-260">*GetAdditionalData* 때마다 메서드는 필드 토큰 생성 되 고 반환 값은 생성 된 토큰에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="b3095-261">구현자는 타임 스탬프, nonce, 또는 하려는 그녀는 다른 값이 메서드에서 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="b3095-262">마찬가지로, 합니다 *ValidateAdditionalData* 때마다 메서드는 필드 토큰의 유효성을 검사 하 고 토큰에 포함 된 "데이터 추가" 문자열 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="b3095-263">유효성 검사 루틴 (토큰을 만들 때 저장 된 시간에 대해 현재 인하여) 시간 초과 구현할 수 있습니다, 그리고 루틴 또는 기타 검사 nonce 원하는 논리입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="b3095-264">설계 결정 사항 및 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="b3095-264">Design decisions and security considerations</span></span>

<span data-ttu-id="b3095-265">세션 및 필드 토큰을 연결 하는 보안 토큰은 기술적으로 필요한 경우에 XSRF 공격에 대 한 익명 / 인증 되지 않은 사용자를 보호 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="b3095-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="b3095-266">하나로 (아마도 쿠키의 형태로 제출) 자체 인증 토큰을 사용할 수 있습니다 사용자가 인증 될 때 동기화 프로그램의 절반 토큰 쌍입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="b3095-267">그러나 인증 되지 않은 사용자에서 로그인 페이지를 보호 하는 데에 유효한 시나리오가 있으며 항상 생성 하 고 보안 토큰 인증 된 사용자에 대해서도 유효성을 검사 하 여 ANTI-XSRF 논리는 간단 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="b3095-268">또한 필드 토큰을 설정 하거나 세션 토큰을 극복 하기 위해 공격자에 대 한 다른 장애물 것 추측 공격자가 손상 되는 몇 가지 추가 보호를 제공지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="b3095-269">개발자가 여러 응용 프로그램은 단일 도메인에서 호스트 되는 경우 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="b3095-270">예를 들어, 경우에 *example1.cloudapp.net* 및 *example2.cloudapp.net* 다른 호스트에서 모든 호스트 간에 암시적 신뢰 관계가 없는  *\*. cloudapp.net* 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="b3095-271">이 암시적 신뢰 관계가 [신뢰할 수 없는 다른 사용자의 쿠키에 적용할 수 있습니다](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (AJAX 요청을 제어 하는 동일 원본 정책을 반드시에 적용 되지 않습니다 HTTP 쿠키).</span><span class="sxs-lookup"><span data-stu-id="b3095-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="b3095-272">ASP.NET 웹 스택 런타임 악의적인 하위 도메인을 세션 토큰을 덮어쓰기 할 경우에 되지 것입니다 사용자에 대 한 유효한 필드 토큰을 생성할 수 있도록 사용자 이름 필드 토큰에 포함 되는 몇 가지 완화 조치를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="b3095-273">그러나 이러한 환경에서 호스트 되는 경우 기본 제공 ANTI-XSRF 루틴은 여전히 없습니다 방어 세션 하이재킹 또는 XSRF 로그인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="b3095-274">ANTI-XSRF 루틴 현재 않습니다 하지 프로그램 방어 [클릭 재 킹](https://www.owasp.org/index.php/Clickjacking)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b3095-275">클릭 재 킹을 방어 자체 하려는 응용 프로그램 수 쉽게 보내서는 X 프레임 옵션: 각 응답 헤더는 SAMEORIGIN입니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="b3095-276">이 헤더는 모든 최신 브라우저에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="b3095-277">자세한 내용은 참조는 [IE 블로그](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [SDL 블로그](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), 및 [OWASP](https://www.owasp.org/index.php/Clickjacking)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b3095-278">웹 페이지 ANTI-XSRF 도우미는 자동으로이 헤더를 설정할 응용 프로그램은 자동으로이 공격 으로부터 보호 하 고 일부 릴리스에서 확인 MVC에서 ASP.NET 웹 스택 런타임 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="b3095-279">웹 개발자 계속 해당 사이트 XSS 공격에 취약 하지 않는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="b3095-280">XSS 공격은 매우 강력한 및 공격 성공 XSRF 공격 으로부터 ASP.NET 웹 스택 런타임 방어 중단도 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="b3095-281">승인</span><span class="sxs-lookup"><span data-stu-id="b3095-281">Acknowledgment</span></span>

<span data-ttu-id="b3095-282">[@LeviBroderick](https://twitter.com/LeviBroderick)에서이 정보 대량의 대부분 ASP.NET 보안 코드를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3095-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
