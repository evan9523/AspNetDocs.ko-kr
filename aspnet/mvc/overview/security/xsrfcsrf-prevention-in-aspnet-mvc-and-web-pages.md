---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC 및 웹 페이지에서 XSRF/CSRF 방지 | Microsoft Docs
author: Rick-Anderson
description: 사이트 간 요청 위조 (XSRF 또는 CSRF 라고도 함)는 악의적인 웹 사이트가 interacti에 영향을 줄 수 있는 웹 호스팅 응용 프로그램에 대 한 공격입니다.
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6fcfcda5b95e5844f7d357ac0cbb6d1fd2e215ac
ms.sourcegitcommit: 84b1681d4e6253e30468c8df8a09fe03beea9309
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/02/2019
ms.locfileid: "73445771"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="7d63e-103">ASP.NET MVC 및 웹 페이지에서 XSRF/CSRF 방지</span><span class="sxs-lookup"><span data-stu-id="7d63e-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="7d63e-104">[Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="7d63e-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="7d63e-105">사이트 간 요청 위조 (XSRF 또는 CSRF 라고도 함)는 악의적인 웹 사이트가 클라이언트 브라우저와 해당 브라우저가 신뢰 하는 웹 사이트 간의 상호 작용에 영향을 줄 수 있는 웹 호스팅 응용 프로그램에 대 한 공격입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="7d63e-106">웹 브라우저에서 웹 사이트에 대 한 모든 요청과 함께 인증 토큰을 자동으로 보내기 때문에 이러한 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="7d63e-107">정식 예제는 ASP와 같은 인증 쿠키입니다. NET의 폼 인증 티켓입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="7d63e-108">그러나 모든 영구 인증 메커니즘 (예: Windows 인증, 기본 등)을 사용 하는 웹 사이트는 이러한 공격의 대상이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="7d63e-109">XSRF 공격은 피싱 공격과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="7d63e-110">피싱 공격에는 교착 상태가 발생 한 상호 작용이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="7d63e-111">피싱 공격에서 악의적인 웹 사이트는 대상 웹 사이트를 모방 하 고, 공격자에 게 중요 한 정보를 제공 하는 것이 속기 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="7d63e-112">XSRF 공격으로 인해 일반적으로 교착 상태가 발생 하는 경우에는 상호 작용이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="7d63e-113">대신 공격자가 모든 관련 쿠키를 대상 웹 사이트로 자동으로 보내는 브라우저에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="7d63e-114">자세한 내용은 [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="7d63e-115">공격 분석</span><span class="sxs-lookup"><span data-stu-id="7d63e-115">Anatomy of an attack</span></span>

<span data-ttu-id="7d63e-116">XSRF 공격을 안내 하려면 온라인 뱅킹 거래를 수행 하려는 사용자를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="7d63e-117">이 사용자는 먼저 WoodgroveBank.com를 방문 하 고 로그인 합니다 .이 시점에서 응답 헤더에는 해당 인증 쿠키가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="7d63e-118">인증 쿠키는 세션 쿠키 이므로 브라우저 프로세스가 종료 되 면 브라우저에서 자동으로 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="7d63e-119">그러나 해당 시간 까지는 브라우저가 WoodgroveBank.com에 대 한 각 요청과 함께 쿠키를 자동으로 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="7d63e-120">이제 사용자가 $1000을 다른 계정으로 전송 하 여 은행 사이트에서 양식을 작성 하 고 브라우저에서 서버에이 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="7d63e-121">이 작업에는 부작용이 있으므로 (통화 트랜잭션이 시작 됨) 뱅킹 사이트에서이 작업을 시작 하기 위해 HTTP POST를 요구 하도록 선택 했습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="7d63e-122">서버는 요청에서 인증 토큰을 읽고, 현재 사용자의 계정 번호를 조회 하 고, 충분 한 자금이 있는지 확인 한 후 대상 계정으로 트랜잭션을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="7d63e-123">자신의 온라인 뱅킹이 완료 되 면 사용자가 뱅킹 사이트에서 다른 곳으로 이동 하 여 웹의 다른 위치를 방문 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="7d63e-124">이러한 사이트 중 하나 – fabrikam.com – &lt;iframe&gt;내에 포함 된 페이지에 대해 다음 태그를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="7d63e-125">그러면 브라우저에서이 요청을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="7d63e-126">공격자는 사용자에 게 대상 웹 사이트에 대 한 유효한 인증 토큰이 남아 있을 수 있음을 알고 있으며 Javascript의 작은 조각을 사용 하 여 브라우저에서 대상 사이트에 대 한 HTTP POST를 자동으로 수행 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="7d63e-127">인증 토큰이 여전히 유효한 경우 은행 사이트에서 공격자가 선택한 계정으로 $250를 전송 하기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="7d63e-128">비효율적인 완화</span><span class="sxs-lookup"><span data-stu-id="7d63e-128">Ineffective mitigations</span></span>

<span data-ttu-id="7d63e-129">위의 시나리오에서 WoodgroveBank.com는 SSL을 통해 액세스 되 고 있으며 SSL 전용 인증 쿠키가 있으므로 공격을 차단할 수 없다는 사실을 기억해 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="7d63e-130">공격자는 &lt;form&gt; 요소에 [URI 체계](http://en.wikipedia.org/wiki/URI_scheme) (https)를 지정할 수 있으며, 해당 쿠키가 의도 한 대상의 uri 체계와 일치 하는 경우 브라우저는 계속 해 서 대상 사이트에 만료 되지 않은 쿠키를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="7d63e-131">신뢰할 수 있는 사이트만 방문 하면 안전 하 게 온라인 상태를 유지 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="7d63e-132">이에 대 한 몇 가지 사항이 있지만 아쉽게도이는 실용적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="7d63e-133">아마도 사용자는 로컬 뉴스 사이트 ConsolidatedMessenger을 "신뢰" 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="7d63e-134">대신 해당 사이트를 방문 하는 것이 ConsolidatedMessenger.com,이 사이트에는 공격자가 fabrikam.com에서 실행 되는 것과 동일한 코드 조각을 삽입할 수 있는 XSS 취약성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="7d63e-135">들어오는 요청에 도메인을 참조 하는 [Referer 헤더가](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="7d63e-136">그러면 타사 도메인에서 알지 못하는 요청이 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="7d63e-137">그러나 일부 사람들은 개인 정보 보호를 위해 브라우저의 Referer 헤더를 사용 하지 않도록 설정 하 고, 공격자가 안전 하지 않은 특정 소프트웨어를 설치한 경우 해당 헤더를 스푸핑할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="7d63e-138">[Referer 헤더](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) 를 확인 하는 것은 XSRF 공격을 방지 하는 안전한 방법으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="7d63e-139">웹 스택 런타임 XSRF 완화</span><span class="sxs-lookup"><span data-stu-id="7d63e-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="7d63e-140">ASP.NET 웹 스택 런타임은 [동기화 토큰 패턴](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) 의 변형을 사용 하 여 XSRF 공격 으로부터 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="7d63e-141">동기화 토큰 패턴의 일반적인 형태는 인증 토큰 외에도 각 HTTP POST를 사용 하 여 서버에 두 개의 XSRF 토큰을 제출 하는 것입니다. 하나는 쿠키로, 다른 하나는 폼 값입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="7d63e-142">공격자가 ASP.NET 런타임에 의해 생성 된 토큰 값을 결정적 이거나 예측 가능 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="7d63e-143">토큰을 제출할 때 서버는 두 토큰이 비교 검사를 통과 하는 경우에만 요청을 계속할 수 있도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="7d63e-144">XSRF 요청 확인 *세션 토큰* 은 HTTP 쿠키로 저장 되며 현재 페이로드에 다음 정보가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="7d63e-145">임의의 128 비트 식별자로 구성 된 보안 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="7d63e-146">다음 이미지는 Internet Explorer F12 개발자 도구를 사용 하 여 표시 되는 XSRF 요청 확인 세션 토큰을 보여 줍니다 .이는 현재 구현 이며 변경 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="7d63e-147">*필드 토큰* 은 `<input type="hidden" />` 저장 되며 해당 페이로드에 다음 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="7d63e-148">로그인 한 사용자의 사용자 이름입니다 (인증 된 경우).</span><span class="sxs-lookup"><span data-stu-id="7d63e-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="7d63e-149">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)에서 제공 하는 추가 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="7d63e-150">XSRF 토큰의 페이로드는 암호화 되 고 서명 되므로 도구를 사용 하 여 토큰을 검사할 때 사용자 이름을 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="7d63e-151">웹 응용 프로그램에서 ASP.NET 4.0를 대상으로 하는 경우에는 [MachineKey](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) 루틴이 암호화 서비스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="7d63e-152">웹 응용 프로그램이 ASP.NET 4.5 이상을 대상으로 하는 경우 암호화 서비스는 더 나은 성능, 확장성 및 보안을 제공 하는 [MachineKey 보호](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) 루틴에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="7d63e-153">자세한 내용은 다음 블로그 게시물을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="7d63e-154">ASP.NET 4.5, pt. 1의 암호화 기능 향상</span><span class="sxs-lookup"><span data-stu-id="7d63e-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="7d63e-155">ASP.NET 4.5, pt. 2의 암호화 기능 향상</span><span class="sxs-lookup"><span data-stu-id="7d63e-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="7d63e-156">ASP.NET 4.5, pt. 3의 암호화 기능 향상</span><span class="sxs-lookup"><span data-stu-id="7d63e-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="7d63e-157">토큰 생성</span><span class="sxs-lookup"><span data-stu-id="7d63e-157">Generating the tokens</span></span>

<span data-ttu-id="7d63e-158">XSRF 토큰을 생성 하려면 MVC 뷰에서 [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) 메서드를 호출 하거나 Razor 페이지에서 @AntiForgery.GetHtml()를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="7d63e-159">런타임은 다음 단계를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="7d63e-160">현재 HTTP 요청에 XSRF 세션 토큰 (XSRF 쿠키 \_\_)이 이미 포함 되어 있는 경우 보안 토큰이 해당 토큰에서 추출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="7d63e-161">HTTP 요청에 XSRF 세션 토큰이 포함 되어 있지 않거나 보안 토큰의 추출이 실패 하면 새로운 임의 XSRF 토큰이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="7d63e-162">XSRF 필드 토큰은 위의 보안 토큰 (1) 및 현재 로그인 한 사용자의 id를 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="7d63e-163">사용자 id를 확인 하는 방법에 대 한 자세한 내용은 아래의 **[특수 지원이 있는 시나리오](#_Scenarios_with_special)** 섹션을 참조 하세요. 또한 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) 가 구성 된 경우 런타임은 [getadditionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) 메서드를 호출 하 고 반환 된 문자열을 필드 토큰에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="7d63e-164">자세한 내용은 **[구성 및 확장성](#_Configuration_and_extensibility)** 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="7d63e-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="7d63e-165">새 XSRF 토큰이 단계 (1)에서 생성 된 경우이를 포함 하는 새 세션 토큰이 만들어지고 아웃 바운드 HTTP 쿠키 컬렉션에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="7d63e-166">단계 (2)의 필드 토큰은 `<input type="hidden" />` 요소에 래핑됩니다 .이 HTML 태그는 `Html.AntiForgeryToken()` 또는 `AntiForgery.GetHtml()`의 반환 값이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="7d63e-167">토큰 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="7d63e-167">Validating the tokens</span></span>

<span data-ttu-id="7d63e-168">수신 방지 된 XSRF 토큰의 유효성을 검사 하기 위해 개발자는 MVC 작업 또는 컨트롤러에 [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) 특성을 포함 하거나 해당 Razor 페이지에서 `@AntiForgery.Validate()`를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="7d63e-169">런타임은 다음 단계를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="7d63e-170">들어오는 세션 토큰 및 필드 토큰을 읽고 각 토큰에서 추출 된 XSRF 토큰을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="7d63e-171">XSRF 토큰은 생성 루틴에서 단계 마다 동일 해야 합니다 (2).</span><span class="sxs-lookup"><span data-stu-id="7d63e-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="7d63e-172">현재 사용자가 인증 된 경우 사용자의 사용자 이름은 필드 토큰에 저장 된 사용자 이름과 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="7d63e-173">사용자 이름은와 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-173">The usernames must match.</span></span>
3. <span data-ttu-id="7d63e-174">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 가 구성 된 경우 런타임은 *validateadditionaldata* 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="7d63e-175">메서드는 부울 값 *true*를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="7d63e-176">유효성 검사가 성공 하면 요청을 계속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="7d63e-177">유효성 검사가 실패 하면 프레임 워크에서 *HttpAntiForgeryException*를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="7d63e-178">오류 조건</span><span class="sxs-lookup"><span data-stu-id="7d63e-178">Failure conditions</span></span>

<span data-ttu-id="7d63e-179">ASP.NET 웹 Stack Runtime v2부터 유효성 검사 중에 발생 하는 모든 *HttpAntiForgeryException* 에는 무엇이 잘못 되었는지에 대 한 자세한 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="7d63e-180">현재 정의 된 오류 조건은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="7d63e-181">세션 토큰 또는 폼 토큰이 요청에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="7d63e-182">세션 토큰 또는 폼 토큰을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="7d63e-183">가장 가능성이 높은 원인은 ASP.NET 웹 스택 런타임의 일치 하지 않는 버전을 실행 하는 팜 이거나 Web.config의 &lt;machineKey&gt; 요소가 컴퓨터 간에 서로 다른 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="7d63e-184">Fiddler와 같은 도구를 사용 하 여 XSRF 토큰으로 변조 하 여이 예외를 강제로 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="7d63e-185">세션 토큰 및 필드 토큰이 교환 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="7d63e-186">세션 토큰과 필드 토큰에 일치 하지 않는 보안 토큰이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="7d63e-187">필드 토큰에 포함 된 사용자 이름이 현재 로그인 한 사용자의 사용자 이름과 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="7d63e-188">*[IAntiForgeryAdditionalDataProvider Additionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 메서드에서 *false*를 반환 했습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="7d63e-189">XSRF 기능을 통해 토큰을 생성 하거나 유효성을 검사 하는 동안 추가 검사를 수행할 수도 있으며, 이러한 검사 중에 오류가 발생 하면 예외가 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="7d63e-190">자세한 내용은 [WIF/ACS/클레임 기반 인증](#_WIF_ACS) 및 **[구성 및 확장성](#_Configuration_and_extensibility)** 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="7d63e-191">특별 한 지원이 있는 시나리오</span><span class="sxs-lookup"><span data-stu-id="7d63e-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="7d63e-192">익명 인증</span><span class="sxs-lookup"><span data-stu-id="7d63e-192">Anonymous authentication</span></span>

<span data-ttu-id="7d63e-193">XSRF 시스템은 익명 사용자에 대 한 특별 한 지원을 포함 합니다. 여기서 "anonymous"는 *IIdentity* 속성이 *false*를 반환 하는 사용자로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="7d63e-194">시나리오에는 사용자를 식별 하기 위해 응용 프로그램이 *IIdentity* 이외의 메커니즘을 사용 하는 사용자 지정 인증 스키마 및 로그인 페이지에 XSRF 보호를 제공 하는 작업이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="7d63e-195">이러한 시나리오를 지원 하기 위해 세션 및 필드 토큰이 임의로 생성 된 128 비트 불투명 식별자 인 보안 토큰으로 조인 됨을 기억 하십시오.</span><span class="sxs-lookup"><span data-stu-id="7d63e-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="7d63e-196">이 보안 토큰은 사용자가 사이트를 탐색할 때 개별 사용자의 세션을 추적 하는 데 사용 되므로 익명 식별자의 용도를 효과적으로 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="7d63e-197">위에서 설명한 생성 및 유효성 검사 루틴의 사용자 이름 대신 빈 문자열이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="7d63e-198">WIF/ACS/클레임 기반 인증</span><span class="sxs-lookup"><span data-stu-id="7d63e-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="7d63e-199">일반적으로 .NET Framework에 기본 제공 된 *IIdentity* 클래스에는 특정 응용 프로그램 내에서 특정 사용자를 고유 하 게 식별 하기에 충분 한 *IIdentity.Name* 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="7d63e-200">예를 들어 *FormsIdentity.Name* 는 해당 데이터베이스에 따라 모든 응용 프로그램에 대해 고유한 멤버 자격 데이터베이스에 저장 된 사용자 이름을 반환 하 고 *WindowsIdentity.Name* 는 사용자의 도메인 정규화 된 id를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="7d63e-201">이러한 시스템은 인증을 제공 하지 않습니다. 또한 응용 프로그램에 대 한 사용자를 *식별* 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="7d63e-202">반면 클레임 기반 인증은 반드시 특정 사용자를 식별 해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="7d63e-203">대신, *ClaimsPrincipal* 및 *ClaimsIdentity* 형식은 *클레임* 인스턴스 집합에 연결 됩니다. 여기서 개별 클레임은 "is 18 + years of age" 또는 "관리자입니다." 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="7d63e-204">사용자가 반드시 식별 되지 않았기 때문에 런타임은 *ClaimsIdentity.Name* 속성을이 특정 사용자의 고유 식별자로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="7d63e-205">팀에서는 *ClaimsIdentity.Name* 가 *null*을 반환 하거나, 친숙 한 (표시) 이름을 반환 하거나, 사용자의 고유 식별자로 사용 하기에 적합 하지 않은 문자열을 반환 하는 실제 예를 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="7d63e-206">클레임 기반 인증을 사용 하는 대부분의 배포는 특히 ACS ( [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) )를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="7d63e-207">개발자는 ACS를 사용 하 여 개별 *id 공급자* (예: ADFS, Microsoft 계정 공급자, yahoo!와 같은 openid connect 공급자 등)를 구성 하 고 id 공급자는 *이름 식별자*를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="7d63e-208">이러한 이름 식별자에는 전자 메일 주소와 같은 PII (개인적으로 식별이 가능한 정보)가 포함 될 수도 있고, 익명화 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="7d63e-209">에 관계 없이 튜플 (id 공급자, 이름 식별자)은 사이트를 검색 하는 동안 특정 사용자에 대 한 적절 한 추적 토큰 역할을 하기 때문에 ASP.NET 웹 스택 런타임은 및를 생성할 때 사용자 이름 대신 튜플을 사용할 수 있습니다. XSRF 필드 토큰의 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="7d63e-210">Id 공급자와 이름 식별자에 대 한 특정 Uri는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="7d63e-211">자세한 내용은이 [ACS 문서 페이지](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="7d63e-212">토큰을 생성 하거나 유효성을 검사할 때 ASP.NET 웹 스택 런타임은 런타임에 형식에 대 한 바인딩을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="7d63e-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (WIF SDK의 경우)</span><span class="sxs-lookup"><span data-stu-id="7d63e-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="7d63e-214">`System.Security.Claims.ClaimsIdentity` (.NET 4.5의 경우).</span><span class="sxs-lookup"><span data-stu-id="7d63e-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="7d63e-215">이러한 형식이 존재 하 고 현재 사용자의 *IIIIdentity* 이 이러한 형식 중 하나를 구현 하거나 서브 클래스 하는 경우 XSRF 기능은 토큰을 생성 하 고 유효성을 검사할 때 사용자 이름 대신 (id 공급자, 이름 식별자) 튜플을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="7d63e-216">이러한 튜플이 없는 경우 요청이 실패 하 고, 사용 중인 특정 클레임 기반 인증 메커니즘을 이해 하도록 XSRF 시스템을 구성 하는 방법을 개발자에 게 설명 하는 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="7d63e-217">자세한 내용은 **[구성 및 확장성](#_Configuration_and_extensibility)** 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="7d63e-218">OAuth/Openid connect 인증</span><span class="sxs-lookup"><span data-stu-id="7d63e-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="7d63e-219">마지막으로, XSRF 기능은 OAuth 또는 Openid connect 인증을 사용 하는 응용 프로그램에 대 한 특별 한 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="7d63e-220">이 지원은 추론을 기반으로 합니다. 현재 *IIdentity.Name* 가 http://또는 https://로 시작 하는 경우에는 기본 stringcomparison.ordinalignorecase 비교자 대신 서 수 비교자를 사용 하 여 사용자 이름 비교가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="7d63e-221">구성 및 확장성</span><span class="sxs-lookup"><span data-stu-id="7d63e-221">Configuration and extensibility</span></span>

<span data-ttu-id="7d63e-222">때로는 개발자가 XSRF 생성 및 유효성 검사 동작을 보다 강력 하 게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="7d63e-223">예를 들어 HTTP 쿠키를 응답에 자동으로 추가 하는 MVC 및 웹 페이지 도우미의 기본 동작은 바람직하지 않으며 개발자는 다른 곳에서 토큰을 유지 하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="7d63e-224">이를 지원 하기 위한 두 가지 Api가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="7d63e-225">*Gettokens* 메서드는 기존 XSRF request 확인 세션 토큰 (null 일 수 있음)을 입력으로 사용 하 고 새 XSRF 요청 확인 세션 토큰 및 필드 토큰을 출력으로 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="7d63e-226">토큰은 단순히 장식이 없는 불투명 문자열입니다. *Formtoken* 값은 &lt;입력&gt; 태그에 래핑되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="7d63e-227">*NewCookieToken* 값은 null 일 수 있습니다. 이 문제가 발생 하는 경우 *oldCookieToken* 값은 여전히 유효 하며 새 응답 쿠키를 설정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="7d63e-228">*Gettokens* 호출자는 필요한 모든 응답 쿠키를 유지 하거나 필요한 태그를 생성 하는 일을 담당 합니다. *Gettokens* 메서드 자체는 응답을 부작용으로 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="7d63e-229">*Validate* 메서드는 들어오는 세션과 필드 토큰을 사용 하 여 위의 유효성 검사 논리를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="7d63e-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="7d63e-230">AntiForgeryConfig</span></span>

<span data-ttu-id="7d63e-231">개발자는 응용 프로그램\_시작에서 XSRF 시스템을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="7d63e-232">구성이 프로그래밍 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-232">Configuration is programmatic.</span></span> <span data-ttu-id="7d63e-233">정적 *AntiForgeryConfig* 형식의 속성은 아래에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="7d63e-234">클레임을 사용 하는 대부분의 사용자는 UniqueClaimTypeIdentifier 속성을 설정 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="7d63e-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="7d63e-235">**Property**</span></span> | <span data-ttu-id="7d63e-236">**설명**</span><span class="sxs-lookup"><span data-stu-id="7d63e-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="7d63e-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="7d63e-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="7d63e-238">토큰을 생성 하는 동안 추가 데이터를 제공 하 고 토큰 유효성 검사 중에 추가 데이터를 사용 하는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="7d63e-239">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-239">The default value is *null*.</span></span> <span data-ttu-id="7d63e-240">자세한 내용은 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="7d63e-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="7d63e-241">**CookieName**</span></span> | <span data-ttu-id="7d63e-242">XSRF 세션 토큰을 저장 하는 데 사용 되는 HTTP 쿠키의 이름을 제공 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="7d63e-243">이 값을 설정 하지 않으면 응용 프로그램의 배포 된 가상 경로에 따라 이름이 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="7d63e-244">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-244">The default value is *null*.</span></span> |
| <span data-ttu-id="7d63e-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="7d63e-245">**RequireSsl**</span></span> | <span data-ttu-id="7d63e-246">SSL 보안 채널을 통해 XSRF 토큰을 제출 해야 하는지 여부를 지정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="7d63e-247">이 값이 *true*이면 자동으로 생성 되는 모든 쿠키에 "secure" 플래그가 설정 되 고, SSL을 통해 제출 되지 않은 요청 내에서 호출 된 경우 XSRF api가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="7d63e-248">기본값은 *false*입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-248">The default value is *false*.</span></span> |
| <span data-ttu-id="7d63e-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="7d63e-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="7d63e-250">XSRF 시스템에서 클레임 기반 id에 대 한 지원을 비활성화 해야 하는지 여부를 지정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="7d63e-251">이 값이 *true*이면 시스템은 *IIdentity.Name* 이 고유한 사용자별 식별자로 사용 하기에 적합 한 것으로 가정 하 고 WIF/ACS/에 설명 된 대로 특수 한 *IClaimsIdentity* 또는 *ClClaimsIdentity* 를 시도 하지 않습니다. [ 클레임 기반 인증](#_WIF_ACS) 섹션.</span><span class="sxs-lookup"><span data-stu-id="7d63e-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="7d63e-252">기본값은 `false`여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-252">The default value is `false`.</span></span> |
| <span data-ttu-id="7d63e-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="7d63e-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="7d63e-254">고유한 사용자별 식별자로 사용 하기에 적합 한 클레임 형식을 나타내는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="7d63e-255">이 값을 설정 하 고 현재 *IIdentity* 가 클레임 기반 인 경우 시스템은 *UniqueClaimTypeIdentifier*에 지정 된 유형의 클레임을 추출 하려고 시도 하 고, 다음과 같은 경우 사용자의 사용자 이름 대신 해당 값이 사용 됩니다. 필드 토큰을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="7d63e-256">클레임 유형을 찾을 수 없는 경우 시스템에서 요청이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="7d63e-257">기본값은 *null*입니다 .이 값은 시스템에서 사용자의 사용자 이름 대신 앞에서 설명한 대로 (id 공급자, 이름 식별자) 튜플을 사용 해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="7d63e-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="7d63e-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="7d63e-259">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 형식을 사용 하면 개발자가 각 토큰에서 추가 데이터를 라운드트립 하 여 XSRF 시스템의 동작을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="7d63e-260">*Getadditionaldata* 메서드는 필드 토큰이 생성 될 때마다 호출 되며 반환 값은 생성 된 토큰에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="7d63e-261">구현자는 타임 스탬프, nonce 또는이 메서드에서 원하는 다른 값을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="7d63e-262">마찬가지로, *Validateadditionaldata* 메서드는 필드 토큰의 유효성을 검사할 때마다 호출 되며, 토큰에 포함 된 "추가 데이터" 문자열은 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="7d63e-263">유효성 검사 루틴은 제한 시간 (토큰을 만들 때 저장 된 시간에 대해 현재 시간을 확인 하 여), nonce 검사 루틴 또는 다른 원하는 논리를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="7d63e-264">디자인 결정 및 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="7d63e-264">Design decisions and security considerations</span></span>

<span data-ttu-id="7d63e-265">세션 및 필드 토큰을 연결 하는 보안 토큰은 XSRF 공격에 대해 익명/인증 되지 않은 사용자를 보호 하려는 경우에만 기술적으로 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="7d63e-266">사용자가 인증 되 면 인증 토큰 자체 (쿠키 형식으로 전송 됨)가 동기화 장치 토큰 쌍의 절반으로 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="7d63e-267">그러나 인증 되지 않은 사용자가 적중 한 로그인 페이지를 보호 하는 유효한 시나리오가 있으며, 인증 된 사용자의 경우에도 항상 보안 토큰을 생성 하 고 유효성을 검사 하 여 XSRF 논리가 더 간단해 집니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="7d63e-268">또한 공격자가 세션 토큰을 설정 하거나 추측 하는 것이 다른 장애물 수 있으므로 공격자가 필드 토큰을 손상 시키는 경우 추가 보호 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="7d63e-269">단일 도메인에서 여러 응용 프로그램을 호스트 하는 경우에는 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="7d63e-270">예를 들어 *example1.cloudapp.net* 및 *example2.cloudapp.net* 가 서로 다른 호스트인 경우에도 *\*. cloudapp.net* 도메인에 있는 모든 호스트 간에 암시적인 신뢰 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="7d63e-271">이 암시적 트러스트 관계 [를 사용 하면 신뢰할 수 없는 호스트가 서로 다른 쿠키에 영향을 줄 수 있습니다](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) . AJAX 요청을 제어 하는 동일한 원본 정책이 반드시 HTTP 쿠키에 적용 되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="7d63e-272">ASP.NET 웹 스택 런타임은 사용자 이름이 필드 토큰에 포함 된다는 것을 완화 하는 기능을 제공 합니다. 따라서 악의적인 하위 도메인에서 세션 토큰을 덮어쓸 수 있는 경우에도 사용자에 대해 유효한 필드 토큰을 생성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="7d63e-273">그러나 이러한 환경에서 호스트 되는 경우에는 기본 제공 되는 XSRF 루틴이 여전히 세션 하이재킹 또는 로그인 XSRF에 대해 방어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="7d63e-274">XSRF 루틴은 현재 [클릭 재 킹](https://www.owasp.org/index.php/Clickjacking)으로부터 방어 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="7d63e-275">클릭 재 킹에 대해 스스로 방어 하려는 응용 프로그램은 각 응답과 함께 X 프레임 옵션: SAMEORIGIN 헤더를 전송 하 여 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="7d63e-276">이 헤더는 모든 최신 브라우저에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="7d63e-277">자세한 내용은 [IE 블로그](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [SDL 블로그](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)및 [OWASP](https://www.owasp.org/index.php/Clickjacking)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="7d63e-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="7d63e-278">ASP.NET 웹 스택 런타임은 일부 향후 릴리스에서는 응용 프로그램이이 공격 으로부터 자동으로 보호 되도록 MVC 및 웹 페이지 XSRF 도우미가이 헤더를 자동으로 설정 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="7d63e-279">웹 개발자는 사이트가 XSS 공격에 취약 하지 않은지 지속적으로 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="7d63e-280">XSS 공격은 매우 강력 하며, 성공적인 익스플로잇은 XSRF 공격에 대해 ASP.NET 웹 스택 런타임 방어를 중단 시킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="7d63e-281">승인이</span><span class="sxs-lookup"><span data-stu-id="7d63e-281">Acknowledgment</span></span>

<span data-ttu-id="7d63e-282">[@LeviBroderick](https://twitter.com/LeviBroderick), 많은 ASP.NET 보안 코드를 작성 한 사람이이 정보를 대량으로 작성 했습니다.</span><span class="sxs-lookup"><span data-stu-id="7d63e-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
