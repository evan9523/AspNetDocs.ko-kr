---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-vb
title: '반복 #5 – 단위 테스트 만들기(VB) | 마이크로 소프트 문서'
author: rick-anderson
description: 다섯 번째 반복에서는 단위 테스트를 추가하여 응용 프로그램을 보다 쉽게 유지 관리하고 수정할 수 있도록 합니다. 우리는 우리의 데이터 모델 클래스를 조롱하고 o ...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: c6e5c036-2265-4fa7-a9eb-47f197bdc262
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-vb
msc.type: authoredcontent
ms.openlocfilehash: cc5425de86e7481894fbea242fa555b5598167f6
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542341"
---
# <a name="iteration-5--create-unit-tests-vb"></a>반복 #5 - 단위 테스트 만들기(VB)

[로 마이크로 소프트](https://github.com/microsoft)

[코드 다운로드](iteration-5-create-unit-tests-vb/_static/contactmanager_5_vb1.zip)

> 다섯 번째 반복에서는 단위 테스트를 추가하여 응용 프로그램을 보다 쉽게 유지 관리하고 수정할 수 있도록 합니다. 데이터 모델 클래스를 모의하고 컨트롤러 및 유효성 검사 논리에 대한 단위 테스트를 빌드합니다.

## <a name="building-a-contact-management-aspnet-mvc-application-vb"></a>연락처 관리 ASP.NET MVC 응용 프로그램(VB) 구축

이 자습서 시리즈에서는 처음부터 끝까지 전체 연락처 관리 응용 프로그램을 빌드합니다. 연락처 관리자 응용 프로그램을 사용하면 사람 목록에 대한 연락처 정보(이름, 전화 번호 및 이메일 주소)를 저장할 수 있습니다.

여러 반복을 통해 응용 프로그램을 빌드합니다. 반복할 때마다 응용 프로그램이 점차 개선됩니다. 이 여러 반복 접근 방식의 목표는 각 변경의 이유를 이해할 수 있도록 하는 것입니다.

- 반복 #1 - 응용 프로그램을 만듭니다. 첫 번째 반복에서는 가능한 가장 간단한 방법으로 연락처 관리자를 만듭니다. 기본 데이터베이스 작업에 대한 지원을 추가합니다: CRUD 만들기, 읽기, 업데이트 및 삭제.

- 반복 #2 - 응용 프로그램을 멋지게 만듭니다. 이 반복에서는 기본 ASP.NET MVC 뷰 마스터 페이지 및 계단식 스타일 시트를 수정하여 응용 프로그램의 모양을 개선합니다.

- 반복 #3 - 양식 유효성 검사를 추가합니다. 세 번째 반복에서는 기본 양식 유효성 검사를 추가합니다. 필수 양식 필드를 작성하지 않고 양식을 제출하지 못하도록 합니다. 또한 이메일 주소와 전화 번호의 유효성을 검사합니다.

- 반복 #4 - 응용 프로그램을 느슨하게 결합합니다. 이 네 번째 반복에서는 여러 소프트웨어 디자인 패턴을 활용하여 Contact Manager 응용 프로그램을 보다 쉽게 유지 관리하고 수정할 수 있습니다. 예를 들어 리포지토리 패턴 및 종속성 주입 패턴을 사용 하 여 응용 프로그램을 리팩터링 합니다.

- 반복 #5 - 단위 테스트를 만듭니다. 다섯 번째 반복에서는 단위 테스트를 추가하여 응용 프로그램을 보다 쉽게 유지 관리하고 수정할 수 있도록 합니다. 데이터 모델 클래스를 모의하고 컨트롤러 및 유효성 검사 논리에 대한 단위 테스트를 빌드합니다.

- 반복 #6 - 테스트 기반 개발을 사용합니다. 이 여섯 번째 반복에서는 단위 테스트를 먼저 작성하고 단위 테스트에 대한 코드를 작성하여 응용 프로그램에 새로운 기능을 추가합니다. 이 반복에서는 연락처 그룹을 추가합니다.

- 반복 #7 - Ajax 기능을 추가합니다. 일곱 번째 반복에서는 Ajax에 대한 지원을 추가하여 응용 프로그램의 응답성과 성능을 향상시킵니다.

## <a name="this-iteration"></a>이 반복

연락처 관리자 응용 프로그램의 이전 반복에서 응용 프로그램을 더 느슨하게 결합하도록 리팩터링했습니다. 응용 프로그램을 고유한 컨트롤러, 서비스 및 리포지토리 계층으로 구분했습니다. 각 레이어는 인터페이스를 통해 레이어 아래에 있는 레이어와 상호 작용합니다.

응용 프로그램을 보다 쉽게 유지 관리하고 수정할 수 있도록 응용 프로그램을 리팩터링했습니다. 예를 들어 새 데이터 액세스 기술을 사용해야 하는 경우 컨트롤러 나 서비스 계층을 건드리지 않고 리포지토리 계층을 변경할 수 있습니다. 연락처 관리자를 느슨하게 결합하여 응용 프로그램을 보다 탄력적으로 변경했습니다.

그러나 연락처 관리자 응용 프로그램에 새 기능을 추가해야 할 때 어떻게 됩니까? 또는 버그를 수정하면 어떻게 됩니까? 슬프지만 잘 입증된 코드 작성의 진실은 코드를 터치할 때마다 새로운 버그가 발생할 위험이 있다는 것입니다.

예를 들어, 어느 좋은 날, 관리자는 연락처 관리자에 새 기능을 추가하도록 요청할 수 있습니다. 연락처 그룹에 대한 지원을 추가하려고 합니다. 사용자가 연락처를 친구, 비즈니스 등의 그룹으로 구성할 수 있도록 설정하려고 합니다.

이 새 기능을 구현하려면 연락처 관리자 응용 프로그램의 세 계층을 모두 수정해야 합니다. 컨트롤러, 서비스 계층 및 리포지토리에 새 기능을 추가해야 합니다. 코드 수정을 시작하자마자 이전에 작동했던 기능이 깨지는 위험이 있습니다.

이전 반복에서와 마찬가지로 응용 프로그램을 별도의 계층으로 리팩터링하는 것이 좋습니다. 응용 프로그램의 나머지 부분을 건드리지 않고 전체 레이어를 변경할 수 있기 때문에 좋은 일이었습니다. 그러나 계층 내의 코드를 보다 쉽게 유지 관리하고 수정하려면 코드에 대한 단위 테스트를 만들어야 합니다.

단위 테스트를 사용하여 개별 코드 단위를 테스트합니다. 이러한 코드 단위는 전체 응용 프로그램 계층보다 작습니다. 일반적으로 단위 테스트를 사용하여 코드의 특정 메서드가 예상대로 작동하는지 확인합니다. 예를 들어 ContactManagerService 클래스에서 노출 된 CreateContact() 메서드에 대 한 단위 테스트를 만듭니다.

응용 프로그램 작업에 대한 단위 테스트는 안전망과 같습니다. 응용 프로그램에서 코드를 수정할 때마다 단위 테스트 집합을 실행하여 수정이 기존 기능을 중단하는지 여부를 확인할 수 있습니다. 단위 테스트를 사용하면 코드를 안전하게 수정할 수 있습니다. 단위 테스트를 통해 응용 프로그램의 모든 코드를 보다 탄력적인 변경으로 만들 수 있습니다.

이 반복에서는 연락처 관리자 응용 프로그램에 단위 테스트를 추가합니다. 이렇게 하면 다음 반복에서 기존 기능을 중단하지 않고도 응용 프로그램에 연락처 그룹을 추가할 수 있습니다.

> [!NOTE] 
> 
> NUnit, xUnit.net 및 MbUnit을 포함한 다양한 단위 테스트 프레임워크가 있습니다. 이 자습서에서는 Visual Studio에 포함된 단위 테스트 프레임워크를 사용합니다. 그러나 이러한 대체 프레임워크 중 하나를 쉽게 사용할 수 있습니다.

## <a name="what-gets-tested"></a>테스트되는 내용

완벽한 세상에서는 모든 코드가 단위 테스트에서 다루어질 것입니다. 완벽한 세상에서, 당신은 완벽한 안전망을 가질 것입니다. 응용 프로그램의 코드 줄을 수정하고 단위 테스트를 실행하여 변경이 기존 기능을 위반했는지 여부를 즉시 알 수 있습니다.

그러나 우리는 완벽한 세상에 살지 않습니다. 실제로 단위 테스트를 작성할 때는 비즈니스 논리(예: 유효성 검사 논리)에 대한 테스트 작성에 집중합니다. 특히 데이터 액세스 논리 또는 뷰 논리에 대한 단위 테스트를 *작성하지 않습니다.*

유용하게 사용하려면 단위 테스트를 매우 빠르게 실행해야 합니다. 응용 프로그램에 대한 수백(또는 수천 개의 단위 테스트를) 쉽게 누적할 수 있습니다. 단위 테스트를 실행하는 데 시간이 오래 걸리는 경우 실행하지 않아도 됩니다. 즉, 장기 실행 단위 테스트는 일상적인 코딩 목적으로 쓸모가 없습니다.

따라서 일반적으로 데이터베이스와 상호 작용하는 코드에 대한 단위 테스트를 작성하지 않습니다. 라이브 데이터베이스에 대해 수백 개의 단위 테스트를 실행하는 것이 너무 느립니다. 대신 데이터베이스를 조롱하고 모의 데이터베이스와 상호 작용하는 코드를 작성합니다(아래 데이터베이스 조롱에 대해 설명합니다).

비슷한 이유로 일반적으로 뷰에 대한 단위 테스트를 작성하지 않습니다. 뷰를 테스트하려면 웹 서버를 스핀업해야 합니다. 웹 서버를 회전하는 것은 비교적 느린 프로세스이므로 뷰에 대한 단위 테스트를 만드는 것은 권장되지 않습니다.

뷰에 복잡한 논리가 포함되어 있는 경우 논리를 도우미 메서드로 이동하는 것이 좋습니다. 웹 서버를 회전하지 않고 실행되는 도우미 메서드에 대한 단위 테스트를 작성할 수 있습니다.

> [!NOTE] 
> 
> 단위 테스트를 작성할 때 데이터 액세스 논리 또는 뷰 논리에 대한 테스트를 작성하는 것은 좋지 않지만 기능 또는 통합 테스트를 작성할 때 이러한 테스트는 매우 유용할 수 있습니다.

> [!NOTE] 
> 
> ASP.NET MVC는 웹 양식 보기 엔진입니다. 웹 양식 보기 엔진은 웹 서버에 종속되어 있지만 다른 보기 엔진은 그렇지 않을 수 있습니다.

## <a name="using-a-mock-object-framework"></a>모의 개체 프레임워크 사용

단위 테스트를 빌드할 때는 거의 항상 모의 개체 프레임워크를 활용해야 합니다. 모의 개체 프레임워크를 사용하면 응용 프로그램의 클래스에 대한 모의 및 스텁을 만들 수 있습니다.

예를 들어 모의 개체 프레임워크를 사용하여 리포지토리 클래스의 모의 버전을 생성할 수 있습니다. 이렇게 하면 단위 테스트에서 실제 리포지토리 클래스 대신 모의 리포지토리 클래스를 사용할 수 있습니다. 모의 리포지토리를 사용하면 단위 테스트를 수행할 때 데이터베이스 코드를 실행하지 않도록 할 수 있습니다.

Visual Studio에는 모의 개체 프레임워크가 포함되어 있지 않습니다. 그러나 .NET 프레임워크에 사용할 수 있는 몇 가지 상용 및 오픈 소스 Mock Object 프레임워크가 있습니다.

1. Moq - 이 프레임워크는 오픈 소스 BSD 라이선스에서 사용할 수 있습니다. 에서 [https://code.google.com/p/moq/](https://code.google.com/p/moq/)Moq를 다운로드할 수 있습니다.
2. Rhino Mocks - 이 프레임워크는 오픈 소스 BSD 라이선스에서 사용할 수 있습니다. [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)에서 Rhino 모의를 다운로드할 수 있습니다.
3. Typemock Isolator - 이것은 상용 프레임워크입니다. 에서 평가판을 다운로드할 [http://www.typemock.com/](http://www.typemock.com/)수 있습니다.

이 튜토리얼에서, 나는 Moq를 사용하기로 결정했다. 그러나 Rhino 모의 또는 Typemock Isolator를 사용하여 연락처 관리자 응용 프로그램에 대한 모의 개체를 쉽게 만들 수 있습니다.

Moq를 사용하려면 다음 단계를 완료해야 합니다.

1. .
2. 다운로드 압축을 풀기 전에 파일을 마우스 오른쪽 단추로 클릭하고 **차단 해제라는** 단추를 클릭해야 합니다(그림 1 참조).
3. 다운로드 압축을 해제합니다.
4. 메뉴 옵션 프로젝트, 참조 추가 **대화** 상자를 여는 **참조 추가를** 선택하여 테스트 프로젝트에 Moq 어셈블리에 대한 참조를 추가합니다. 찾아보기 탭에서 Moq의 압축을 풀었던 폴더를 찾아Moq.dll 어셈블리를 선택합니다. **확인** 단추를 클릭합니다(그림 2 참조).

[![Moq 차단 해제](iteration-5-create-unit-tests-vb/_static/image1.jpg)](iteration-5-create-unit-tests-vb/_static/image1.png)

**그림 01**: Moq 차단 해제[(전체 크기 이미지를 보려면 클릭)](iteration-5-create-unit-tests-vb/_static/image2.png)

[![Moq를 추가한 후 참조](iteration-5-create-unit-tests-vb/_static/image2.jpg)](iteration-5-create-unit-tests-vb/_static/image3.png)

**그림 02**: Moq를 추가한 후[참조(클릭하여 전체 크기 이미지 보기)](iteration-5-create-unit-tests-vb/_static/image4.png)

## <a name="creating-unit-tests-for-the-service-layer"></a>서비스 계층에 대한 단위 테스트 만들기

먼저 연락처 관리자 응용 프로그램 서비스 계층에 대한 단위 테스트 집합을 만듭니다. 이러한 테스트를 사용하여 유효성 검사 논리를 확인합니다.

ContactManager.Test 프로젝트에서 모델이라는 새 폴더를 만듭니다. 다음으로 모델 폴더를 마우스 오른쪽 단추로 클릭하고 **새 테스트 추가를**선택합니다. 그림 3에 표시된 **새 테스트 추가** 대화 상자가 나타납니다. 단위 **테스트** 템플릿을 선택하고 새 테스트 의 이름을 지정하는 ContactManagerServiceTest.vb입니다. **확인** 버튼을 클릭하여 테스트 프로젝트에 새 테스트를 추가합니다.

> [!NOTE] 
> 
> 일반적으로 테스트 프로젝트의 폴더 구조가 ASP.NET MVC 프로젝트의 폴더 구조와 일치하도록 할 수 있습니다. 예를 들어 컨트롤러 폴더에 컨트롤러 테스트를 배치하고 모델 폴더에서 모델 테스트를 배치하는 등의 작업입니다.

[![모델\컨택관리자서비스테스트.cs](iteration-5-create-unit-tests-vb/_static/image3.jpg)](iteration-5-create-unit-tests-vb/_static/image5.png)

**그림 03**: 모델\컨택매니저서비스Test.cs[(전체 크기 이미지를 보려면 클릭)](iteration-5-create-unit-tests-vb/_static/image6.png)

처음에 ContactManagerService 클래스에서 노출 된 CreateContact() 메서드를 테스트 하려고 합니다. 다음 5가지 테스트를 만듭니다.

- CreateContact() - CreateContact()가 유효한 연락처가 메서드에 전달될 때 true 값을 반환하는 테스트입니다.
- CreateContactRequiredFirstName() - 누락된 이름의 연락처가 CreateContact() 메서드에 전달될 때 오류 메시지가 모델 상태에 추가되는 테스트를 합니다.
- CreateContactRequiredLastName() - 누락된 성을 가진 연락처가 CreateContact() 메서드에 전달될 때 오류 메시지가 모델 상태에 추가되는 테스트를 합니다.
- CreateContactInvalidPhone() - 잘못된 전화 번호의 연락처가 CreateContact() 메서드에 전달될 때 오류 메시지가 모델 상태에 추가되는 테스트를 합니다.
- CreateContactInvalidEmail() - 잘못된 전자 메일 주소가 있는 연락처가 CreateContact() 메서드에 전달될 때 오류 메시지가 모델 상태에 추가되는 테스트를 수행합니다.

첫 번째 테스트는 유효한 Contact가 유효성 검사 오류를 생성하지 않는지 확인합니다. 나머지 테스트는 각 유효성 검사 규칙을 확인합니다.

이러한 테스트의 코드는 목록 1에 포함되어 있습니다.

**목록 1 - 모델\컨택 관리자서비스테스트.vb**

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample1.vb)]

목록 1의 연락처 클래스를 사용하므로 테스트 프로젝트에 Microsoft 엔터티 프레임워크에 대한 참조를 추가해야 합니다. System.Data.Entity 어셈블리에 참조를 추가합니다.

목록 1에는 [TestInitialize] 특성으로 장식된 Initialize()라는 메서드가 포함되어 있습니다. 이 메서드는 각 단위 테스트를 실행하기 전에 자동으로 호출됩니다(각 단위 테스트 바로 전에 5번 호출). Initialize() 메서드는 다음과 같은 코드 줄이 있는 모의 리포지토리를 만듭니다.

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample2.vb)]

이 코드 줄은 Moq 프레임워크를 사용하여 IContactManagerRepository 인터페이스에서 모의 리포지토리를 생성합니다. 모의 리포지토리는 각 단위 테스트를 실행할 때 데이터베이스에 액세스하지 않도록 실제 EntityContactManagerRepository 대신 사용됩니다. 모의 리포지토리는 IContactManagerRepository 인터페이스의 메서드를 구현하지만 메서드는 실제로 아무 것도 수행하지 않습니다.

> [!NOTE] 
> 
> Moq 프레임워크를 사용하는 경우 모의 \_와 \_모의 Repository.Object 사이에는 차이가 있습니다. 전자는 모의 리포지토리가 어떻게 행동할지 지정하는 메서드를 포함하는 모의(IContactManagerRepository) 클래스를 참조합니다. 후자는 IContactManagerRepository 인터페이스를 구현하는 실제 모의 리포지토리를 나타냅니다.

모의 리포지토리는 ContactManagerService 클래스의 인스턴스를 만들 때 Initialize() 메서드에 사용됩니다. 모든 개별 단위 테스트는 ContactManagerService 클래스의 이 인스턴스를 사용합니다.

목록 1에는 각 단위 테스트에 해당하는 5가지 메서드가 포함되어 있습니다. 이러한 각 메서드는 [TestMethod] 특성으로 장식되어 있습니다. 단위 테스트를 실행할 때 이 특성이 있는 메서드가 호출됩니다. 즉, [TestMethod] 특성으로 장식 된 모든 메서드는 단위 테스트입니다.

CreateContact(라는 첫 번째 단위 테스트)는 CreateContact()를 호출하면 Contact 클래스의 유효한 인스턴스가 메서드에 전달될 때 true 값을 반환한다는 것을 확인합니다. 테스트는 Contact 클래스의 인스턴스를 만들고 CreateContact() 메서드를 호출하고 CreateContact()가 true 값을 반환한다는 것을 확인합니다.

나머지 테스트는 CreateContact() 메서드가 잘못된 Contact를 사용하여 호출될 때 메서드가 false를 반환하고 예상 유효성 검사 오류 메시지가 모델 상태에 추가되는지 확인합니다. 예를 들어 CreateContactRequiredFirstName() 테스트는 FirstName 속성에 대한 빈 문자열이 있는 연락처 클래스의 인스턴스를 만듭니다. 다음으로 CreateContact() 메서드가 잘못된 연락처를 사용하여 호출됩니다. 마지막으로 테스트는 CreateContact()가 false를 반환하고 해당 모델 상태에 "이름은 필수"라는 예상 유효성 검사 오류 메시지가 포함되어 있는지 확인합니다.

메뉴 옵션 **테스트, 실행, 솔루션의 모든 테스트(CTRL+R, A)를**선택하여 목록 1에서 단위 테스트를 실행할 수 있습니다. 테스트 결과는 테스트 결과 창에 표시됩니다(그림 4 참조).

[![테스트 결과](iteration-5-create-unit-tests-vb/_static/image4.jpg)](iteration-5-create-unit-tests-vb/_static/image7.png)

**그림 04**: 테스트 결과[(전체 크기 이미지를 보려면 클릭)](iteration-5-create-unit-tests-vb/_static/image8.png)

## <a name="creating-unit-tests-for-controllers"></a>컨트롤러에 대한 단위 테스트 만들기

ASP.NET MVC 응용 프로그램은 사용자 상호 작용의 흐름을 제어합니다. 컨트롤러를 테스트할 때 컨트롤러가 올바른 작업 결과 및 뷰 데이터를 반환하는지 여부를 테스트하려고 합니다. 컨트롤러가 예상되는 방식으로 모델 클래스와 상호 작용하는지 여부를 테스트할 수도 있습니다.

예를 들어 목록 2에는 연락처 컨트롤러 Create() 메서드에 대한 두 개의 단위 테스트가 포함되어 있습니다. 첫 번째 단위 테스트는 유효한 Contact가 Create() 메서드에 전달될 때 Create() 메서드가 인덱스 작업으로 리디렉션되는지 확인합니다. 즉, 유효한 연락처를 통과하면 Create() 메서드는 인덱스 작업을 나타내는 리디렉션토루트Result를 반환해야 합니다.

컨트롤러 계층을 테스트할 때 ContactManager 서비스 계층을 테스트하지 않으려고 합니다. 따라서 초기화 메서드에서 다음 코드로 서비스 계층을 조롱합니다.

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample3.vb)]

CreateValidContact() 단위 테스트에서는 다음과 같은 코드 줄로 서비스 계층 CreateContact() 메서드를 호출하는 동작을 조롱합니다.

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample4.vb)]

이 코드 줄은 모의 ContactManager 서비스가 CreateContact() 메서드가 호출될 때 true 값을 반환하도록 합니다. 서비스 계층을 조롱하여 서비스 계층에서 코드를 실행할 필요 없이 컨트롤러의 동작을 테스트할 수 있습니다.

두 번째 단위 테스트에서는 잘못된 연락처가 메서드에 전달될 때 Create() 작업이 Create 뷰를 반환하는지 확인합니다. Service layer CreateContact() 메서드가 다음 코드 줄에 false 값을 반환하도록 합니다.

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample5.vb)]

Create() 메서드가 예상대로 작동하면 서비스 계층에서 false 값을 반환할 때 Create 뷰를 반환해야 합니다. 이렇게 하면 컨트롤러는 만들기 보기에 유효성 검사 오류 메시지를 표시할 수 있으며 사용자는 해당 잘못 된 Contact 속성을 수정할 수 있습니다.

컨트롤러에 대한 단위 테스트를 빌드하려는 경우 컨트롤러 작업에서 명시적 뷰 이름을 반환해야 합니다. 예를 들어 다음과 같은 보기를 반환하지 마십시오.

리턴 뷰()

대신 다음과 같이 뷰를 반환합니다.

리턴 뷰("만들기")

뷰를 반환할 때 명시적이지 않은 경우 ViewResult.ViewName 속성은 빈 문자열을 반환합니다.

**목록 2 - 컨트롤러\컨택 컨트롤러Test.vb**

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample6.vb)]

## <a name="summary"></a>요약

이 반복에서는 연락처 관리자 응용 프로그램에 대한 단위 테스트를 만들었습니다. 언제든지 이러한 단위 테스트를 실행하여 응용 프로그램이 예상대로 작동하는지 확인할 수 있습니다. 단위 테스트는 응용 프로그램의 안전망 역할을 하므로 향후 응용 프로그램을 안전하게 수정할 수 있습니다.

두 가지 단위 테스트 집합을 만들었습니다. 먼저 서비스 계층에 대한 단위 테스트를 만들어 유효성 검사 논리를 테스트했습니다. 다음으로 컨트롤러 계층에 대한 단위 테스트를 만들어 흐름 제어 논리를 테스트했습니다. 서비스 계층을 테스트할 때 리포지토리 계층을 조롱하여 리포지토리 계층에서 서비스 계층에 대한 테스트를 격리했습니다. 컨트롤러 계층을 테스트할 때 서비스 계층을 조롱하여 컨트롤러 계층에 대한 테스트를 격리했습니다.

다음 반복에서는 연락처 그룹을 지원되도록 연락처 관리자 응용 프로그램을 수정합니다. 테스트 기반 개발이라는 소프트웨어 설계 프로세스를 사용하여 응용 프로그램에 이 새로운 기능을 추가합니다.

> [!div class="step-by-step"]
> [이전](iteration-4-make-the-application-loosely-coupled-vb.md)
> [다음](iteration-6-use-test-driven-development-vb.md)
