---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET 웹 API 2 - ASP.NET 4.x의 전역 오류 처리
author: davidmatson
description: ASP.NET 4.x에 대한 ASP.NET 웹 API 2의 전역 오류 처리 개요입니다.
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 5ff54d2e4ed881ce927d0a401fb79d9b8bc5b8a1
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675425"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="04ec3-103">ASP.NET 웹 API 2의 글로벌 오류 처리</span><span class="sxs-lookup"><span data-stu-id="04ec3-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="04ec3-104">[데이비드 매슨,](https://github.com/davidmatson) [릭 앤더슨](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="04ec3-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="04ec3-105">이 항목에서는 ASP.NET 4.x에 대한 ASP.NET 웹 API 2의 전역 오류 처리에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="04ec3-106">오늘날 웹 API에서는 전 세계적으로 오류를 기록하거나 처리할 수 있는 쉬운 방법이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="04ec3-107">처리되지 않은 일부 예외는 [예외 필터를](exception-handling.md)통해 처리할 수 있지만 예외 필터가 처리할 수 없는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="04ec3-108">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="04ec3-108">For example:</span></span>

1. <span data-ttu-id="04ec3-109">컨트롤러 생성자에서 throw된 예외</span><span class="sxs-lookup"><span data-stu-id="04ec3-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="04ec3-110">메시지 처리기에서 throw된 예외</span><span class="sxs-lookup"><span data-stu-id="04ec3-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="04ec3-111">라우팅 중에 throw된 예외</span><span class="sxs-lookup"><span data-stu-id="04ec3-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="04ec3-112">응답 콘텐츠를 직렬화하는 동안 throw된 예외</span><span class="sxs-lookup"><span data-stu-id="04ec3-112">Exceptions thrown during response content serialization.</span></span>

<span data-ttu-id="04ec3-113">이러한 예외를 기록하고 처리하는 간단하고 일관된 방법을 제공하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="04ec3-114">예외를 처리하는 두 가지 주요 사례가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="04ec3-115">후자의 경우는 스트리밍 응답 콘텐츠 중간에 예외가 throw되는 경우입니다. 이 경우 상태 코드, 헤더 및 부분 콘텐츠가 이미 와이어를 가로 질러 이동했기 때문에 새 응답 메시지를 보내기에는 너무 늦었기 때문에 연결을 중단하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="04ec3-116">새 응답 메시지를 생성하기 위해 예외를 처리할 수 없지만 예외 로깅은 계속 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="04ec3-117">오류를 감지할 수 있는 경우 다음과 같이 적절한 오류 응답을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="04ec3-118">기존 옵션</span><span class="sxs-lookup"><span data-stu-id="04ec3-118">Existing Options</span></span>

<span data-ttu-id="04ec3-119">[예외 필터](exception-handling.md)외에도 [메시지 처리기를](../advanced/http-message-handlers.md) 사용하여 모든 500수준 응답을 관찰할 수 있지만 원래 오류에 대한 컨텍스트가 없기 때문에 이러한 응답에 대해 사용하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="04ec3-120">메시지 처리기는 처리할 수 있는 서비스 케이스에 대한 예외 필터와 동일한 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.</span></span> <span data-ttu-id="04ec3-121">Web API에는 오류 조건을 캡처하는 추적 인프라가 있지만 추적 인프라는 진단을 위한 것이며 프로덕션 환경에서 실행하기 위해 설계되거나 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-121">While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="04ec3-122">전역 예외 처리 및 로깅은 프로덕션 중에 실행되고 기존 모니터링 솔루션(예: [ELMAH)에](https://code.google.com/p/elmah/)연결될 수 있는 서비스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-122">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/)).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="04ec3-123">솔루션 개요</span><span class="sxs-lookup"><span data-stu-id="04ec3-123">Solution Overview</span></span>

 <span data-ttu-id="04ec3-124">처리되지 않은 예외를 기록하고 처리하기 위해 두 개의 새로운 사용자 교체 가능한 서비스인 [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) 및 IExceptionHandlerHandler를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-124">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="04ec3-125">서비스는 매우 유사하며 두 가지 주요 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-125">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="04ec3-126">여러 예외 로거를 등록하지만 단일 예외 처리기만 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-126">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="04ec3-127">연결을 중단하려고 하는 경우에도 예외 로거가 항상 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-127">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="04ec3-128">예외 처리기는 보낼 응답 메시지를 선택할 수 있는 경우에만 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-128">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="04ec3-129">두 서비스 모두 예외가 검색된 시점부터 관련 정보를 포함하는 예외 컨텍스트, 특히 [HttpRequestMessage,](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx) [HttpRequestContext,](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)throw된 예외 및 예외 소스(아래 세부 정보)에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-129">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="04ec3-130">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="04ec3-130">Design Principles</span></span>

1. <span data-ttu-id="04ec3-131">**주요 변경 사항 없음** 이 기능은 부 릴리스에 추가되기 때문에 솔루션에 영향을 주는 한 가지 중요한 제약 조건은 계약을 입력하거나 동작에 대한 주요 변경 내용이 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-131">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="04ec3-132">이 제약 조건은 예외를 500개의 응답으로 전환하는 기존 catch 블록 측면에서 수행하려는 일부 정리를 배제했습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-132">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="04ec3-133">이 추가 정리는 후속 주요 릴리스에서 고려할 수 있는 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-133">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="04ec3-134">이것이 중요한 경우 [웹 API 사용자 음성으로](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)투표하십시오 ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="04ec3-134">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="04ec3-135">**웹 API 구문과의 일관성 유지** Web API의 필터 파이프라인은 작업별, 컨트롤러별 또는 전역 범위에서 논리를 유연하게 적용하여 교차 절단 문제를 처리할 수 있는 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-135">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="04ec3-136">예외 필터를 포함한 필터에는 전역 범위에 등록된 경우에도 항상 작업 및 컨트롤러 컨텍스트가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-136">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="04ec3-137">이 계약은 필터에 적합하지만 전역으로 범위가 조정된 예외 필터도 작업 또는 컨트롤러 컨텍스트가 없는 메시지 처리기의 예외와 같은 일부 예외 처리 사례에 적합하지 않다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-137">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="04ec3-138">예외 처리를 위해 필터에서 제공하는 유연한 범위 지정을 사용하려면 예외 필터가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-138">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="04ec3-139">그러나 컨트롤러 컨텍스트 외부에서 예외를 처리해야 하는 경우 전체 전역 오류 처리(컨트롤러 컨텍스트 및 작업 컨텍스트 제약 조건이 없는 항목)에 대해 별도의 구문이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-139">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="04ec3-140">사용 시기</span><span class="sxs-lookup"><span data-stu-id="04ec3-140">When to Use</span></span>

- <span data-ttu-id="04ec3-141">예외 로거는 Web API에서 catch된 처리되지 않은 모든 예외를 확인하는 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-141">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="04ec3-142">예외 처리기는 Web API에서 catch한 처리되지 않은 예외에 대해 가능한 모든 응답을 사용자 지정하는 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-142">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="04ec3-143">예외 필터는 특정 작업 또는 컨트롤러와 관련된 하위 집합처리되지 않은 예외를 처리하는 가장 쉬운 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-143">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="04ec3-144">서비스 세부 정보</span><span class="sxs-lookup"><span data-stu-id="04ec3-144">Service Details</span></span>

 <span data-ttu-id="04ec3-145">예외 로거 및 처리기 서비스 인터페이스는 각각의 컨텍스트를 취하는 간단한 비동기 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-145">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="04ec3-146">또한 이러한 두 인터페이스모두에 대한 기본 클래스도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-146">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="04ec3-147">코어(동기화 또는 비동기) 메서드를 재정의하는 것은 권장 시간에 로그하거나 처리하는 데 필요한 모든 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-147">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="04ec3-148">로깅의 `ExceptionLogger` 경우 기본 클래스는 코어 로깅 메서드가 각 예외에 대해 한 번만 호출되도록 합니다(나중에 호출 스택을 더 많이 전파하고 다시 catch되는 경우에도 마찬가지입니다).</span><span class="sxs-lookup"><span data-stu-id="04ec3-148">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="04ec3-149">기본 `ExceptionHandler` 클래스는 레거시 중첩된 catch 블록을 무시하고 호출 스택 맨 위에 있는 예외에 대해서만 코어 처리 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-149">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="04ec3-150">(이러한 기본 클래스의 단순화된 버전은 아래 부록에 있습니다.) 둘 `IExceptionLogger` `IExceptionHandler` 다 를 통해 예외에 대한 정보를 수신합니다. `ExceptionContext`</span><span class="sxs-lookup"><span data-stu-id="04ec3-150">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="04ec3-151">프레임워크가 예외 로거 또는 예외 처리기를 호출할 `Exception` 때 `Request`항상 및 을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-151">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="04ec3-152">단위 테스트를 제외하고 항상 `RequestContext`을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-152">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="04ec3-153">예외 필터에 `ControllerContext` 대한 `ActionContext` catch 블록에서 호출하는 경우에만 a 및 를 거의 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-153">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="04ec3-154">그것은 매우 드물게 `Response`(응답을 작성하려고하는 중간에 특정 IIS의 경우에만)를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-154">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="04ec3-155">이러한 속성 중 일부는 예외 `null` 클래스의 멤버에 `null` 액세스하기 전에 확인하는 것은 소비자의 책임이 될 수 있으므로 주의하십시오.`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="04ec3-155">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="04ec3-156">는 예외를 본 catch 블록을 나타내는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-156">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="04ec3-157">catch 블록 문자열은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-157">The catch block strings are as follows:</span></span>

- <span data-ttu-id="04ec3-158">HttpServer (센드애싱크 방법)</span><span class="sxs-lookup"><span data-stu-id="04ec3-158">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="04ec3-159">HttpControllerDispatcher(SendAsync 메서드)</span><span class="sxs-lookup"><span data-stu-id="04ec3-159">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="04ec3-160">HttpBatchHandler (센타싱크 방법)</span><span class="sxs-lookup"><span data-stu-id="04ec3-160">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="04ec3-161">IExceptionFilter(ApiController의 ExecuteAsync에서 예외 필터 파이프라인 처리)</span><span class="sxs-lookup"><span data-stu-id="04ec3-161">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="04ec3-162">오윈 호스트:</span><span class="sxs-lookup"><span data-stu-id="04ec3-162">OWIN host:</span></span>

    - <span data-ttu-id="04ec3-163">HttpMessageHandlerAdapter.버퍼응답콘텐츠Async(버퍼링 출력용)</span><span class="sxs-lookup"><span data-stu-id="04ec3-163">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="04ec3-164">HttpMessageHandlerAdapter.CopyResponse콘텐츠Async(스트리밍 출력용)</span><span class="sxs-lookup"><span data-stu-id="04ec3-164">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="04ec3-165">웹 호스트:</span><span class="sxs-lookup"><span data-stu-id="04ec3-165">Web host:</span></span>

    - <span data-ttu-id="04ec3-166">HttpControllerHandler.WriteBufferedResponse콘텐츠Async(버퍼링 출력용)</span><span class="sxs-lookup"><span data-stu-id="04ec3-166">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="04ec3-167">HttpControllerHandler.WriteStreamedResponse콘텐츠동기화(스트리밍 출력용)</span><span class="sxs-lookup"><span data-stu-id="04ec3-167">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="04ec3-168">HttpControllerHandler.WriteErrorResponseContentAsync (버퍼링된 출력 모드에서 오류 복구 실패의 경우)</span><span class="sxs-lookup"><span data-stu-id="04ec3-168">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="04ec3-169">catch 블록 문자열 목록은 정적 readonly 속성을 통해서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-169">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="04ec3-170">(코어 캐치 블록 문자열은 정적 ExceptionCatchBlocks에 있고 나머지는 OWIN 및 웹 호스트에 대해 각각 하나의 정적 클래스에 나타납니다.)`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="04ec3-170">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="04ec3-171">호출 스택맨 맨 위에있는 예외를 처리하는 권장 패턴을 따르는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-171">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="04ec3-172">예외를 중첩된 catch 블록이 발생하는 모든 곳에서 500개의 응답으로 전환하는 대신 예외 처리기는 호스트에서 보일 때까지 예외를 전파할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-172">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="04ec3-173">뿐만 `ExceptionContext`아니라, 로거는 전체를 `ExceptionLoggerContext`통해 하나의 정보를 가져옵니다 :</span><span class="sxs-lookup"><span data-stu-id="04ec3-173">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="04ec3-174">두 번째 `CanBeHandled`속성 , "로거는 처리할 수 없는 예외를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-174">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="04ec3-175">연결이 중단되고 새 응답 메시지를 보낼 수 없는 경우 로거가 호출되지만 처리기가 ***호출되지 않으며*** 로거가 이 속성에서 이 시나리오를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-175">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="04ec3-176">`ExceptionContext`에 추가로 처리기는 예외를 처리하기 위해 전체에 `ExceptionHandlerContext` 설정할 수 있는 속성을 하나 더 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-176">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="04ec3-177">`Result` 예외 처리기는 속성을 작업 결과(예: [ExceptionResult,](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx) [InternalServerErrorResult,](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx) [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)또는 사용자 지정 결과)로 설정하여 예외를 처리했음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-177">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="04ec3-178">속성이 `Result` null이면 예외가 처리되지 않고 원래 예외가 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-178">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="04ec3-179">호출 스택 맨 위에 있는 예외의 경우 API 호출자에게 응답이 적절한지 확인하기 위해 추가 단계를 밟습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-179">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="04ec3-180">예외가 호스트에 전파되면 호출자는 노란색 사망 화면또는 일반적으로 적절한 API 오류 응답이 아닌 HTML인 다른 호스트가 제공된 응답을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-180">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="04ec3-181">이러한 경우 Result는 null이 아닌 것으로 시작되며 사용자 지정 예외 처리기가 명시적으로 다시 (처리되지 않음)으로 `null` 설정하는 경우에만 예외가 호스트에 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-181">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="04ec3-182">이러한 `Result` `null` 경우설정은 다음 두 가지 시나리오에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-182">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="04ec3-183">OWIN은 웹 API 이전/외부에 등록된 미들웨어를 처리하는 사용자 지정 예외를 가진 웹 API를 호스팅했습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-183">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="04ec3-184">노란색 사망 화면이 실제로 처리되지 않은 예외에 대한 유용한 응답인 브라우저를 통한 로컬 디버깅입니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-184">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="04ec3-185">예외 로거와 예외 처리기 모두에 대해 로거 또는 처리기 자체가 예외를 throw하는 경우 복구할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-185">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="04ec3-186">(예외가 전파되도록 하는 것 이외에는 더 나은 접근 방식이 있는 경우 이 페이지의 맨 아래에 피드백을 남겨 주세요.) 예외 로거 및 처리기에 대한 계약은 예외가 호출자에게 전파되도록 해서는 안 된다는 것입니다. 그렇지 않으면 예외가 호스트로 전파되어 ASP와 같은 HTML 오류가 발생하는 경우가 많습니다. NET의 노란색 화면)이 클라이언트로 다시 전송됩니다(일반적으로 JSON 또는 XML을 기대하는 API 호출자에게는 선호되지 않습니다).</span><span class="sxs-lookup"><span data-stu-id="04ec3-186">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="04ec3-187">예</span><span class="sxs-lookup"><span data-stu-id="04ec3-187">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="04ec3-188">추적 예외 로거</span><span class="sxs-lookup"><span data-stu-id="04ec3-188">Tracing Exception Logger</span></span>

<span data-ttu-id="04ec3-189">아래 예외 로거는 구성된 추적 원본(Visual Studio의 디버그 출력 창 포함)에 예외 데이터를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-189">The exception logger below sends exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="04ec3-190">사용자 지정 오류 메시지 예외 처리기</span><span class="sxs-lookup"><span data-stu-id="04ec3-190">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="04ec3-191">아래 예외 처리기는 지원에 문의하기 위한 전자 메일 주소를 포함하여 클라이언트에 대한 사용자 지정 오류 응답을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-191">The exception handler below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="04ec3-192">예외 필터 등록</span><span class="sxs-lookup"><span data-stu-id="04ec3-192">Registering Exception Filters</span></span>

<span data-ttu-id="04ec3-193">"ASP.NET MVC 4 웹 응용 프로그램" 프로젝트 템플릿을 사용하여 프로젝트를 만드는 경우 `WebApiConfig` *App_Start* 폴더에 웹 API 구성 코드를 클래스 안에 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="04ec3-193">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="04ec3-194">부록: 기본 클래스 세부 정보</span><span class="sxs-lookup"><span data-stu-id="04ec3-194">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
