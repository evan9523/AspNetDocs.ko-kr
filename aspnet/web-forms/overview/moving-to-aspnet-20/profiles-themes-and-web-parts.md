---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: 프로필, 테마 및 웹 파트 | Microsoft Docs
author: microsoft
description: 구성의 주요 변경 사항 및 ASP.NET 2.0의 계측 됩니다. 새 ASP.NET 구성 API pr 되도록 구성 변경 내용을 허용 하는 중...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: 010adaba61b15ca4421c2d3a4a7590becb53897b
ms.sourcegitcommit: 289e051cc8a90e8f7127e239fda73047bde4de12
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/25/2019
ms.locfileid: "58422852"
---
<a name="profiles-themes-and-web-parts"></a>프로필, 테마 및 웹 파트
====================
by [Microsoft](https://github.com/microsoft)

> 구성의 주요 변경 사항 및 ASP.NET 2.0의 계측 됩니다. 새 ASP.NET 구성 API를 프로그래밍 방식으로 되도록 구성 변경 내용을 허용 합니다. 또한 많은 새 구성 설정이 새 구성 및 계측을 허용 합니다.


ASP.NET 2.0에는 개인 설정 된 웹 사이트의 영역에서 향상을 시키고 나타냅니다. 이미 멤버 자격 기능 마십시오, 외에도 ASP.NET 프로필, 테마 및 웹 파트 대폭 향상 시킬 웹 사이트에서 개인 설정 합니다.

## <a name="aspnet-profiles"></a>ASP.NET 프로필

ASP.NET 프로필 세션와 비슷합니다. 프로필은 영구 세션은 브라우저를 닫을 때 손실 점이 다릅니다. 세션 및 프로필 간의 또 다른 큰 차이점은 프로필은 강력한 형식, 따라서 IntelliSense를 사용 하 여 개발 프로세스 중 제공 됩니다.

프로필을 컴퓨터 구성 파일 또는 응용 프로그램에 대 한 web.config 파일에서 정의 됩니다. (하위 폴더 web.config 파일에 프로필을 정의할 수 없습니다.) 아래 코드는 먼저 웹 사이트 방문자를 저장 하 고 이름을 마지막으로 프로필을 정의 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

프로필 속성에 대 한 기본 데이터 형식에는 System.String입니다. 위의 예에서 없는 데이터 형식이 지정 되었습니다. 따라서 FirstName 및 LastName 속성은 String 형식 둘 다. 앞에서 언급 한 프로필 속성은 강력한 형식입니다. 아래 코드는 Int32 형식의 기간에 대 한 새 속성을 추가 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

프로필은 ASP.NET 폼 인증을 사용 하 여 사용 됩니다. 각 사용자가 사용자 ID와 연결 된 별도 프로필을 조합 하 여 폼 인증을 사용 하 여 사용 하는 경우 그러나 것도 가능 하 여 익명 응용 프로그램 프로필의 사용을 허용 하는 &lt;anonymousIdentification&gt; 와 함께 구성 파일의 요소를 **allowAnonymous** 으로 특성 아래 참조:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

익명 사용자는 사이트를 찾아보고, ASP.NET의 인스턴스를 만듭니다 **ProfileCommon** 사용자에 대 한 합니다. 이 프로필이 고유 방문자로 사용자를 식별 하는 브라우저에서 쿠키에 저장 하는 고유한 ID를 사용 하세요. 따라서에서 익명으로 검색 하는 사용자에 대 한 프로필 정보를 저장할 수 있습니다.

## <a name="profile-groups"></a>프로필 그룹

프로필의 그룹 속성을 두는 것이 가능 합니다. 그룹화 속성에 의해 특정 응용 프로그램에 대 한 여러 프로필을 시뮬레이션 하는 것이 같습니다.

다음 구성은 두 그룹에 대 한 FirstName 및 LastName 속성 구성 구매자 및 잠재 고객입니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

다음과 같이 특정 그룹에 속성을 설정할 수 됩니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>복잡 한 개체를 저장합니다.

지금까지 설명한 예에서는 프로필에서 단순 데이터 형식을 저장 했어야 합니다. Serialization에 사용 하는 방법을 지정 하 여 프로필에서 복합 데이터 형식을 저장할 수 이기도 합니다 **serializeAs** 특성을 다음과 같이 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

이 경우 유형 PurchaseInvoice입니다. PurchaseInvoice 클래스를 serializable로 표시 되어야 하며 임의 개수의 속성을 포함할 수 있습니다. 예를 들어 PurchaseInvoice 라는 속성이 **NumItemsPurchased**를 다음과 같이 코드에서 해당 속성을 참조할 수 있습니다.

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>프로필 상속

여러 응용 프로그램에서 사용할 프로필을 만들 수는 것입니다. ProfileBase에서 파생 되는 프로필 클래스를 만들어 여러 응용 프로그램에서 프로필을 사용 하 여 재사용할 수 있습니다 합니다 **상속** 아래와 같이 특성:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

이 경우 클래스 **PurchasingProfile** 보입니다 다음과 같이 합니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>프로필 공급자

ASP.NET 프로필 공급자 모델을 사용 합니다. 앱에서 SQL Server Express 데이터베이스에 있는 정보를 저장 하는 기본 공급자\_SqlProfileProvider 공급자를 사용 하 여 웹 응용 프로그램 데이터 폴더. 데이터베이스가 존재 하지 않으면 ASP.NET 자동으로 만들어집니다 해당 프로필 정보를 저장 하려고 할 때.

그러나 경우에 따라 하려는 고유한 프로필 공급자를 개발 합니다. ASP.NET 프로필 기능을 사용 하면 쉽게 다양 한 공급자를 사용할 수 있습니다.

사용자 지정 프로필 공급자를 만든 경우:

- FoxPro 데이터베이스 또는 Oracle 데이터베이스에서 지원 되지 않는.NET Framework에 포함 된 프로필 공급자가 같은 데이터 원본에 프로필 정보를 저장 해야 합니다.
- .NET Framework에 포함 된 공급자가 사용 하는 데이터베이스 스키마와에서는 다른 데이터베이스 스키마를 사용 하 여 프로필 정보를 관리 해야 합니다. 일반적인 예는 기존 SQL Server 데이터베이스의 사용자 데이터를 사용 하 여 프로필 정보를 통합 하려는입니다.

### <a name="required-classes"></a>필요한 클래스

프로필 공급자를 구현 하려면 System.Web.Profile.ProfileProvider 추상 클래스를 상속 하는 클래스를 만들어야 합니다. 합니다 **ProfileProvider** 추상 클래스에서 상속 System.Configuration.SettingsProvider System.Configuration.Provider.ProviderBase 추상 클래스를 상속 하는 추상 클래스입니다. 필수 멤버 외에도이 상속 체인으로 인해 합니다 **ProfileProvider** 클래스의 필수 멤버를 구현 해야 합니다 **SettingsProvider** 및  **ProviderBase** 클래스입니다.

다음 표에에서 구현 해야 하는 메서드 및 속성을 설명 합니다 **ProviderBase**를 **SettingsProvider**, 및 **ProfileProvider** 추상 클래스입니다.

### <a name="providerbase-members"></a>ProviderBase 멤버

| **멤버** | **설명** |
| --- | --- |
| Initialize 메서드 | 공급자 인스턴스 이름 및 구성 설정의 NameValueCollection 입력으로 사용 합니다. 옵션 및 컴퓨터 구성 파일 또는 Web.config 파일에 지정 된 옵션과 구현 별 값을 포함 하 여 공급자 인스턴스의 속성 값을 설정 하는 데 사용 합니다. |

### <a name="settingsprovider-members"></a>SettingsProvider 멤버

| **멤버** | **설명** |
| --- | --- |
| ApplicationName 속성 | 각 프로필을 사용 하 여 저장 되는 응용 프로그램 이름입니다. 프로필 공급자 응용 프로그램 이름을 사용 하 여 개별적으로 각 응용 프로그램에 대 한 프로필 정보를 저장 합니다. 따라서 여러 ASP.NET 응용 프로그램 사용자 이름이 같은 다른 응용 프로그램에서 만들어지는 경우 충돌 없이 동일한 데이터 소스를 사용할 수 있습니다. 또는 여러 ASP.NET 응용 프로그램은 동일한 응용 프로그램 이름을 지정 하 여 프로필 데이터 소스를 공유할 수 있습니다. |
| GetPropertyValues 메서드 | SettingsContext a 입력과 SettingsPropertyCollection 개체를 변수로 사용 합니다. 합니다 **SettingsContext** 사용자에 대 한 정보를 제공 합니다. 사용자에 대 한 프로필 속성 정보를 검색 하는 기본 키로 정보를 사용할 수 있습니다. 사용 된 **SettingsContext** 사용자 이름 및 인증 또는 익명 사용자 인지를 가져올 개체입니다. 합니다 **SettingsPropertyCollection** SettingsProperty 개체의 컬렉션을 포함 합니다. 각 **SettingsProperty** 개체 속성 및 읽기 전용 속성 인지에 대 한 기본 값과 같은 추가 정보 뿐만 아니라 속성의 종류와 이름을 제공 합니다. 합니다 **GetPropertyValues** 메서드 기반 SettingsPropertyValue 개체는 SettingsPropertyValueCollection 채웁니다 합니다 **SettingsProperty** 입력으로 제공 되는 개체입니다. 지정된 된 사용자에 대 한 데이터 원본에서 값은 각 PropertyValue 속성에 할당 됩니다 **SettingsPropertyValue** 개체가 고 전체 컬렉션을 반환 됩니다. 현재 날짜 및 시간으로 지정 된 사용자 프로필에 대 한 LastActivityDate 값을 업데이트도 메서드를 호출 합니다. |
| SetPropertyValues 메서드 | 입력으로 사용 된 **SettingsContext** 와 **SettingsPropertyValueCollection** 개체입니다. 합니다 **SettingsContext** 사용자에 대 한 정보를 제공 합니다. 사용자에 대 한 프로필 속성 정보를 검색 하는 기본 키로 정보를 사용할 수 있습니다. 사용 된 **SettingsContext** 사용자 이름 및 인증 또는 익명 사용자 인지를 가져올 개체입니다. 합니다 **SettingsPropertyValueCollection** 의 컬렉션을 포함 **SettingsPropertyValue** 개체입니다. 각 **SettingsPropertyValue** 개체 이름, 형식 및 속성 및 읽기 전용 속성 인지에 대 한 기본 값과 같은 추가 정보 뿐만 아니라 속성의 값을 제공 합니다. 합니다 **SetPropertyValues** 메서드는 지정 된 사용자에 대 한 데이터 원본에 프로필 속성 값을 업데이트 합니다. 메서드를 호출 하면도 업데이트 합니다 **LastActivityDate** 및 현재 날짜 및 시간으로 지정 된 사용자 프로필에 대 한 LastUpdatedDate 값입니다. |

### <a name="profileprovider-members"></a>ProfileProvider 멤버

| **멤버** | **설명** |
| --- | --- |
| DeleteProfiles 메서드 | 일치 하는 응용 프로그램 이름이 문자열 배열 사용자의 이름을 지정 하 고 지정 된 이름에 대 한 모든 프로필 속성과 정보 값을 데이터 소스에서 삭제 하는 입력으로 사용 합니다 **ApplicationName** 속성 값입니다. 데이터 소스에서 트랜잭션을 지원 및 트랜잭션에서 모든 삭제 작업을 포함 하는 트랜잭션을 롤백할 삭제 작업이 실패 하면 예외를 throw 하는 것이 좋습니다. |
| DeleteProfiles 메서드 | 일치 하는 응용 프로그램 이름이 ProfileInfo의 컬렉션 개체 및 데이터 원본에서 각 프로필에 대 한 모든 프로필 속성과 정보 값을 삭제 하는 입력으로 사용 합니다 **ApplicationName** 속성 값입니다. 데이터 원본 트랜잭션을 지원할 경우 트랜잭션을 롤백 및 삭제 작업이 실패 하면 예외를 throw 트랜잭션에서 모든 삭제 작업을 포함 하는 것이 좋습니다. |
| DeleteInactiveProfiles 메서드 | ProfileAuthenticationOption 값을 입력으로 사용 및 DateTime 개체 및 데이터 삭제에 대 한 원본 모든 프로필 정보 및 마지막 작업 날짜가 지정 된 날짜 및 시간 보다 작거나 같은 되는 속성 값이 응용 프로그램 이름 일치 하는 **ApplicationName** 속성 값입니다. **ProfileAuthenticationOption** 매개 변수는 익명 프로필 프로필의 경우에 인증 되었는지 여부를 지정 또는 모든 프로필을 삭제 합니다. 데이터 원본 트랜잭션을 지원할 경우 트랜잭션을 롤백 및 삭제 작업이 실패 하면 예외를 throw 트랜잭션에서 모든 삭제 작업을 포함 하는 것이 좋습니다. |
| GetAllProfiles 메서드 | 입력으로 사용 된 **ProfileAuthenticationOption** 페이지 인덱스를 지정 하는 정수 값, 페이지 크기 및 프로필의 총 수로 설정 하는 정수에 대 한 참조를 지정 하는 정수입니다. 포함 된 ProfileInfoCollection 반환 **ProfileInfo** 일치 하는 응용 프로그램 이름이 데이터 소스에 있는 모든 프로필에 대 한 개체를 **ApplicationName** 속성 값입니다. 합니다 **ProfileAuthenticationOption** 매개 변수 지정만 익명 프로필에 프로필에만 인증 되었는지 여부를 반환 되는 모든 프로필 또는 합니다. 반환한 결과 **GetAllProfiles** 메서드는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값의 최대 수를 지정 **ProfileInfo** 에서 반환 하는 개체를 **ProfileInfoCollection**합니다. 페이지 인덱스 값을 1에서 첫 번째 페이지를 식별 하는 위치를 반환 하는 결과 페이지를 지정 합니다. 총 레코드에 대 한 매개 변수는 out 매개 변수 (사용할 수 있습니다 **ByRef** Visual basic에서) 프로필의 총 수로 설정 된 합니다. 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 프로필 및 페이지 인덱스 값이 5, 페이지 크기가 2 합니다 **ProfileInfoCollection** 반환에 6 번째부터 10 번째까지의 프로필이 포함 됩니다. 메서드는 반환 될 때 총 레코드 수 값 13으로 설정 됩니다. |
| GetAllInactiveProfiles 메서드 | 입력으로 사용 된 **ProfileAuthenticationOption** 값을 **DateTime** 개체, 페이지 인덱스를 지정 하는 정수, 페이지 크기에 대 한 참조를 설정 하는 정수를 지정 하는 정수 프로필의 총 개수입니다. 반환 된 **ProfileInfoCollection** 포함 하는 **ProfileInfo** 개체의 경우 데이터 소스의 마지막 작업 날짜가 지정 된 보다 작거나 같은 모든 프로필에 대 한 **날짜/시간**  일치 하는 응용 프로그램 이름이 고는 **ApplicationName** 속성 값입니다. 합니다 **ProfileAuthenticationOption** 매개 변수 지정만 익명 프로필에 프로필에만 인증 되었는지 여부를 반환 되는 모든 프로필 또는 합니다. 반환한 결과 **GetAllInactiveProfiles** 메서드는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값의 최대 수를 지정 **ProfileInfo** 에서 반환 하는 개체를 **ProfileInfoCollection**합니다. 페이지 인덱스 값을 1에서 첫 번째 페이지를 식별 하는 위치를 반환 하는 결과 페이지를 지정 합니다. 총 레코드에 대 한 매개 변수는 out 매개 변수 (사용할 수 있습니다 **ByRef** Visual basic에서) 프로필의 총 수로 설정 된 합니다. 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 프로필 및 페이지 인덱스 값이 5, 페이지 크기가 2 합니다 **ProfileInfoCollection** 반환에 6 번째부터 10 번째까지의 프로필이 포함 됩니다. 메서드는 반환 될 때 총 레코드 수 값 13으로 설정 됩니다. |
| FindProfilesByUserName 메서드 | 입력으로 사용 된 **ProfileAuthenticationOption** 값을 사용자 이름, 페이지 인덱스를 지정 하는 정수, 페이지 크기 및 총 수를 설정 하는 정수에 대 한 참조를 지정 하는 정수를 포함 하는 문자열 프로필입니다. 반환 된 **ProfileInfoCollection** 포함 하는 **ProfileInfo** 사용자 이름이 지정된 된 사용자 이름과 일치 하는 위치와 일치 하는 응용 프로그램 이름이 모든 프로필에는 데이터 원본에 대 한 개체를 **ApplicationName** 속성 값입니다. 합니다 **ProfileAuthenticationOption** 매개 변수 지정만 익명 프로필에 프로필에만 인증 되었는지 여부를 반환 되는 모든 프로필 또는 합니다. 데이터 원본에는 와일드 카드 문자 등의 추가 검색 기능을 지 원하는 경우에 사용자 이름에 대 한 보다 광범위 한 검색 기능을 제공할 수 있습니다. 반환한 결과 **FindProfilesByUserName** 메서드는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값의 최대 수를 지정 **ProfileInfo** 에서 반환 하는 개체를 **ProfileInfoCollection**합니다. 페이지 인덱스 값을 1에서 첫 번째 페이지를 식별 하는 위치를 반환 하는 결과 페이지를 지정 합니다. 총 레코드에 대 한 매개 변수는 out 매개 변수 (사용할 수 있습니다 **ByRef** Visual basic에서) 프로필의 총 수로 설정 된 합니다. 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 프로필 및 페이지 인덱스 값이 5, 페이지 크기가 2 합니다 **ProfileInfoCollection** 반환에 6 번째부터 10 번째까지의 프로필이 포함 됩니다. 메서드는 반환 될 때 총 레코드 수 값 13으로 설정 됩니다. |
| FindInactiveProfilesByUserName 메서드 | 입력으로 사용 된 **ProfileAuthenticationOption** 값이 고, 사용자 이름을 포함 하는 문자열을 **DateTime** 개체, 페이지 인덱스를 지정 하는 정수, 페이지 크기를 지정 하는 정수 및 프로필의 총 수로 설정 하는 정수에 대 한 참조입니다. 반환 된 **ProfileInfoCollection** 포함 하는 **ProfileInfo** 여기서는 마지막 작업 날짜가 지정 된 사용자 이름을 일치 하는 사용자 이름이 데이터 원본에 있는 모든 프로필에 대 한 개체 보다 작거나 또는 지정 된 같음 **날짜/시간**, 일치 하는 응용 프로그램 이름이 고는 **ApplicationName** 속성 값입니다. 합니다 **ProfileAuthenticationOption** 매개 변수 지정만 익명 프로필에 프로필에만 인증 되었는지 여부를 반환 되는 모든 프로필 또는 합니다. 데이터 원본에는 와일드 카드 문자 등의 추가 검색 기능을 지 원하는 경우에 사용자 이름에 대 한 보다 광범위 한 검색 기능을 제공할 수 있습니다. 반환한 결과 **FindInactiveProfilesByUserName** 메서드는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값의 최대 수를 지정 **ProfileInfo** 에서 반환 하는 개체를 **ProfileInfoCollection**합니다. 페이지 인덱스 값을 1에서 첫 번째 페이지를 식별 하는 위치를 반환 하는 결과 페이지를 지정 합니다. 총 레코드에 대 한 매개 변수는 out 매개 변수 (사용할 수 있습니다 **ByRef** Visual basic에서) 프로필의 총 수로 설정 된 합니다. 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 프로필 및 페이지 인덱스 값이 5, 페이지 크기가 2 합니다 **ProfileInfoCollection** 반환에 6 번째부터 10 번째까지의 프로필이 포함 됩니다. 메서드는 반환 될 때 총 레코드 수 값 13으로 설정 됩니다. |
| GetNumberOfInActiveProfiles 메서드 | 입력으로 사용 된 **ProfileAuthenticationOption** 값으로 **DateTime** 개체 및의 경우 데이터 소스의 마지막 작업 날짜가 지정 된 보다작거나같은모든프로필의수를반환 **날짜/시간** 일치 하는 응용 프로그램 이름이 고는 **ApplicationName** 속성 값입니다. 합니다 **ProfileAuthenticationOption** 매개 변수는 익명 프로필 프로필의 경우에 인증 되었는지 여부를 지정 모든 프로필을 계산할 또는 합니다. |

### <a name="applicationname"></a>ApplicationName

프로필 공급자 개별적으로 각 응용 프로그램에 대 한 프로필 정보를 저장할 수 있으므로 데이터 스키마에 응용 프로그램 이름을 포함 하 고 쿼리 및 업데이트도 포함 응용 프로그램 이름을 확인 해야 합니다. 예를 들어 명령을 사용자 이름 및는 프로필이 익명 인지 여부에 따라 데이터베이스에서 속성 값을 검색 하는 데 사용 되 고 되도록 합니다 **ApplicationName** 값 쿼리에 포함 됩니다.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>ASP.NET 테마

## <a name="what-are-aspnet-20-themes"></a>ASP.NET 2.0 테마는 무엇 인가요?

웹 응용 프로그램의 가장 중요 한 측면 중 하나에 사이트 전체에 걸쳐 일관 된 모양과 느낌입니다. ASP.NET 1.x 개발자는 일반적으로 일관 된 모양과 느낌을 구현 하려면 (CSS 스타일 시트)를 사용 합니다. ASP.NET 2.0 테마 CSS 시 ASP.NET 개발자 HTML 요소 뿐만 아니라 ASP.NET 서버 컨트롤의 모양을 정의 하는 기능 제공 하므로 크게 개선 합니다. 개별 컨트롤, 특정 웹 페이지 또는 전체 웹 응용 프로그램을 ASP.NET 테마를 적용할 수 있습니다. 테마는 이미지는 필요한 경우 CSS 파일과 선택적 스킨 파일을 선택적 이미지 디렉터리의 조합을 사용 합니다. 스킨 파일에는 ASP.NET 서버 컨트롤의 시각적 모양을 제어합니다.

## <a name="where-are-themes-stored"></a>여기서 테마 저장 인가요?

테마를 저장할 위치를 해당 범위에 따라 다릅니다. 모든 응용 프로그램에 적용할 수 있는 테마는 다음 폴더에 저장 됩니다.

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

특정 응용 프로그램에 관련 된 테마에 저장 되는 `App\_Themes\<Theme\_Name>` 웹 사이트의 루트에서 디렉터리입니다.

> [!NOTE]
> 스킨 파일에는 모양에 영향을 주는 서버 컨트롤 속성 수정만 해야 합니다.

전역 테마는 테마를 응용 프로그램 또는 웹 서버에서 실행 중인 웹 사이트에 적용할 수 있습니다. 이러한 테마는 기본적으로 v2.x.xxxxx 디렉터리 내에 있는 ASP.NETClientfiles\Themes 디렉터리에 저장 됩니다. 또는 aspnet에 테마 파일을 이동할 수 있습니다\_클라이언트/시스템\_web / [version] /Themes/ [테마\_이름] 웹 사이트의 루트에서 폴더입니다.

응용 프로그램 관련 테마 파일 귀하가 거주 하는 응용 프로그램에만 적용할 수 있습니다. 이러한 파일에 저장 되는 `App\_Themes/<theme\_name>` 웹 사이트의 루트에서 디렉터리입니다.

## <a name="the-components-of-a-theme"></a>테마의 구성 요소

하나 이상의 CSS 파일는 선택적 스킨 파일 및 선택적 이미지 폴더의 테마 구성 됩니다. CSS 파일 모든 이름일 수 있습니다 (예: default.css 또는 theme.css 등)를 선택 하 고 테마 폴더의 루트에 있어야 합니다. CSS 파일은 일반 CSS 클래스 및 특정 선택기에 대 한 특성을 정의에 사용 됩니다. 페이지 요소에 CSS 클래스 중 하나를 적용 하는 **CSSClass** 속성을 사용 합니다.

스킨 파일은 ASP.NET 서버 컨트롤에 대 한 속성 정의 포함 하는 XML 파일입니다. 아래 나열 된 코드 예제에서는 스킨 파일입니다.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

**그림 1** 아래 테마가 적용 하지 않고 작은 ASP.NET 페이지를 검색 합니다. **그림 2** 테마가 적용 된 동일한 파일을 보여 줍니다. 배경색과 텍스트 색을 CSS 파일을 통해 구성 됩니다. 단추 및 텍스트의 모양은 위에 나열 된 스킨 파일을 사용 하 여 구성 됩니다.


![테마 없음](profiles-themes-and-web-parts/_static/image1.gif)

**그림 1**: 테마 없음


![테마 적용](profiles-themes-and-web-parts/_static/image2.gif)

**그림 2**: 테마 적용


위에 나열 된 스킨 파일에는 모든 텍스트 상자 컨트롤 및 단추 컨트롤에 대 한 기본 스킨을 정의 합니다. 즉, 모든 TextBox 컨트롤 및 단추 컨트롤을 페이지에 삽입이 모양에 걸립니다. 사용 하 여 이러한 컨트롤의 특정 인스턴스에 적용할 수 있는 스킨을 정의할 수도 있습니다는 **SkinID** 컨트롤의 속성입니다.

아래 코드는 단추 컨트롤의 스킨을 정의합니다. 단추만 사용 하 여 컨트롤을 **SkinID** 속성을 **goButton** 스킨 모양을 걸립니다.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

서버 컨트롤 형식 당 하나의 기본 스킨만을 있습니다. 필요한 경우 추가 스킨, SkinID 속성을 사용 해야 합니다.

## <a name="applying-themes-to-pages"></a>페이지 테마 적용

다음 방법 중 하나를 사용 하는 테마를 적용할 수 있습니다.

- 에 &lt;페이지&gt; web.config 파일의 요소
- 에 @Page 페이지 지시문
- 프로그래밍 방식으로

## <a name="applying-a-theme-in-the-configuration-file"></a>구성 파일에 테마를 적용합니다.

응용 프로그램 구성 파일에 테마를 적용 하려면 다음 구문을 사용 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

여기에 지정 된 테마 이름 themes 폴더의 이름과 일치 해야 합니다. 이 폴더는이 과정의 앞부분에서 언급 된 위치 중 하나에 있을 수 있습니다. 존재 하지 않는 테마를 적용 하려는 경우 구성 오류가 발생 합니다.

## <a name="applying-a-theme-in-the-page-directive"></a>Page 지시문에서 테마를 적용합니다.

또한 @ Page 지시문에서 테마를 적용할 수 있습니다. 이 메서드를 사용 하면 특정 페이지에 테마를 사용할 수 있습니다.

테마를 적용 하는 @Page 지시문을 다음 구문을 사용 하 여:

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

다시 한번, 여기에 지정 된 테마를 앞서 언급 했 듯이 테마 폴더를 일치 해야 합니다. 존재 하지 않는 테마를 적용 하려고 하면 빌드 오류가 발생 합니다. Visual Studio 특성을 강조 표시 하 고 이러한 테마 없음 있는지 알려도 됩니다.

## <a name="applying-a-theme-programmatically"></a>프로그래밍 방식으로 테마 적용

프로그래밍 방식으로 테마를 적용 하려면을 지정 해야 합니다 **테마** 속성 페이지에 대 한는 **페이지\_PreInit** 메서드.

프로그래밍 방식으로 테마를 적용 하려면 다음 구문을 사용 합니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

PreInit 메서드를 페이지 수명 주기 때문에 테마를 적용 하는 것이 반드시 합니다. 적용할 경우 해당 시점 이후에, 페이지 테마는 이미 적용 된 런타임에서 이며 변경 시점 너무 늦게 수명 주기에서. 존재 하지 않는 테마를 적용 하는 경우는 **HttpException** 발생 합니다. 테마를 프로그래밍 방식으로 적용 될 때 서버 컨트롤 속성이 SkinID 지정 하는 경우 빌드 경고가 발생 합니다. 이 경고는 없는 테마를 선언적으로 적용할을 무시할 수 사용자에 게 알리는 것입니다.

## <a name="exercise-1--applying-a-theme"></a>연습 1: 테마를 적용합니다.

이 연습에서는 웹 사이트에 ASP.NET 테마를 적용 합니다.

> [!IMPORTANT]
> 스킨 파일에 정보를 입력 했는지를 Microsoft Word를 사용 하는 경우 따옴표를 사용 하 여 일반 견적을 대체 하지 않습니다. 둥근 따옴표에는 스킨 파일을 사용 하 여 문제가 발생 합니다.

1. 새 ASP.NET 웹 사이트를 만듭니다.
2. 솔루션 탐색기에서 프로젝트를 마우스 오른쪽 새 항목 추가 선택 합니다.
3. 웹 구성 파일의 파일 목록에서 선택 하 고 추가 클릭 합니다.
4. 솔루션 탐색기에서 프로젝트를 마우스 오른쪽 새 항목 추가 선택 합니다.
5. 스킨 파일을 선택 하 고 추가 클릭 합니다.
6. 앱 내에서 파일을 배치 하려는 경우 메시지가 표시 되 면 예 클릭\_테마 폴더입니다.
7. 앱 내에서 SkinFile 폴더를 마우스 오른쪽 단추로 클릭\_테마 폴더 솔루션 탐색기에서 새 항목 추가 선택 합니다.
8. 파일의 목록에서 스타일 시트를 선택 하 고 추가 클릭 합니다. 이제 모든 새 테마를 구현 하는 데 필요한 파일이 있습니다. 그러나 Visual Studio는 테마 폴더 SkinFile 선정 하였습니다. 해당 폴더에서 마우스 CoolTheme 이름을 변경 합니다.
9. SkinFile.skin 파일을 열고 파일의 끝 다음 코드를 추가 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. SkinFile.skin 파일을 저장 합니다.
11. StyleSheet.css를 엽니다.
12. 다음을 사용 하 여 모든에 텍스트를 대체 합니다. 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. StyleSheet.css 파일을 저장 합니다.
14. Default.aspx 페이지를 엽니다.
15. TextBox 컨트롤 및 단추 컨트롤을 추가 합니다.
16. 페이지를 저장합니다. Default.aspx 페이지를 검색 합니다. 일반 웹 폼으로 표시 됩니다.
17. Web.config 파일을 엽니다.
18. 여는 바로 아래 다음 코드를 추가 `<system.web>` 태그: 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Web.config 파일을 저장 합니다. Default.aspx 페이지를 검색 합니다. 적용 된 테마를 사용 하 여 표시 됩니다.
20. 열려 있지 않으면 Visual Studio에서 Default.aspx 페이지를 엽니다.
21. 단추를 선택 합니다.
22. 변경 된 **SkinID** goButton 속성입니다. Visual Studio에서는 단추 컨트롤에 대 한 유효한 SkinID 값을 사용 하 여 드롭다운을 확인 합니다.
23. 페이지를 저장합니다. 이제 브라우저에서 페이지를 다시 미리 합니다. 단추를 지금 "이동" 이어야 하며 모양이 더 광범위 한 여야 합니다.

사용 하는 **SkinID** 속성인 서버 컨트롤의 특정 형식의 다른 인스턴스에 대 한 다양 한 스킨을 쉽게 구성할 수 있습니다.

## <a name="the-stylesheettheme-property"></a>StyleSheetTheme 속성

지금까지 소개한만 Theme 속성을 사용 하 여 테마를 적용 합니다. 테마 속성을 사용 하는 경우 스킨 파일에는 서버 컨트롤에 대 한 모든 선언적 설정이 무시 됩니다. 예를 들어, 실습 1에서는 단추 컨트롤에 대 한 "goButton"의 SkinID 지정한 및 "이동" 단추 텍스트를 변경 하는 합니다. "단추" 단추를 디자이너에서의 Text 속성 설정 되었지만 테마는 되며 알 수 있습니다. 테마는 디자이너에서 속성 설정을 항상 덮어씁니다.

테마의 스킨 파일에 정의 된 속성을 재정의할 수 있게 되기를 원하는 경우 속성에에서 지정 된 디자이너를 사용할 수는 **StyleSheetTheme** 테마 속성 대신 합니다. StyleSheetTheme 속성을 제외 하 고 테마 속성은 모든 명시적 속성 설정을 재정의 하지 테마 속성와 같습니다.

이 작업에서을 보려면을 연습 1에서에서 프로젝트의 web.config 파일을 엽니다 변경 된 `<pages>` 다음과 요소:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Default.aspx 페이지를 검색 하 고 단추 컨트롤에는 "단추"의 텍스트 속성을 다시 표시 됩니다. 디자이너에서 명시적 속성 설정을 SkinID goButton 설정한 Text 속성은 재정의 되기 때문입니다.

## <a name="overriding-themes"></a>테마를 재정의합니다.

앱에서 동일한 이름으로을 테마를 적용 하 여 전역 테마를 재정의할 수 있습니다\_응용 프로그램 테마 폴더입니다. 그러나 테마 true 재정의 시나리오에서 적용 되지 않습니다. 런타임에서 테마 파일 앱에서 발생 하는 경우\_테마 폴더를 해당 파일을 사용 하 여 테마를 적용할 고 전역 테마를 무시 합니다.

StyleSheetTheme 속성을 재정의할 수 이며 코드에서 다음과 같이 재정의할 수 있습니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>웹 파트

ASP.NET 웹 파트는 최종 사용자가 콘텐츠, 모양 및 동작 웹 페이지의 브라우저에서 직접 수정할 수 있도록 하는 웹 사이트를 만들기 위한 컨트롤 집합을 통합된 합니다. 개별 사용자 또는 사이트의 모든 사용자가 수정 작업을 적용할 수 있습니다. 사용자가 페이지 및 컨트롤을 수정 라는 개인 설정 기능을 이후의 브라우저 세션 간에 사용자의 개인 기본 설정을 유지 하려면 설정은 저장할 수 있습니다. 이러한 웹 파트 기능을 개발자가 최종 사용자가 개발자 또는 관리자의 개입 없이 동적으로 웹 응용 프로그램을 개인 설정 하 게 제공할 수 있습니다 의미 합니다.

웹 파트 컨트롤 집합을 사용 하 여, 최종 사용자가 사용할 수 개발자로 서 있습니다.

- 페이지 콘텐츠를 개인 설정 합니다. 사용자 수 페이지에 새 웹 파트 컨트롤을 추가, 제거, 숨기려면, 또는 일반 창과 마찬가지로 최소화 합니다.
- 페이지 레이아웃을 개인 설정 합니다. 사용자가 페이지에 웹 파트 컨트롤을 다른 영역으로 끌어 하거나 해당 모양, 속성 및 동작을 변경할 수 있습니다.
- 컨트롤 내보내기 및 가져오기. 사용자를 가져오거나 속성, 모양 및 컨트롤의 데이터도 그대로 유지 하 고 다른 페이지 또는 사이트에서 사용 하기 위해 웹 파트 컨트롤 설정을 내보낼 수 있습니다. 이렇게 하면 최종 사용자에 게 데이터 항목 및 구성 요구 줄어듭니다.
- 연결을 만듭니다. 차트 컨트롤을 주식 종목 컨트롤의 데이터에 대 한 그래프를 표시할 수 있습니다 예를 들어 되도록 사용자 컨트롤 간의 연결을 설정할 수 있습니다. 사용자가 자체에 연결 하지만 모양 및 차트 컨트롤에서 데이터를 표시 하는 방법의 세부 정보 뿐만 아니라 개인 설정할 수 없습니다.
- 관리 하 고 사이트 수준 설정을 개인 설정 합니다. 권한 있는 사용자 사이트 수준 설정을 구성, 사이트 또는 페이지에 액세스할 수 있습니다, 그리고 역할 기반 액세스 컨트롤에 설정 및 등는 확인 수 있습니다. 예를 들어, 관리 역할에서 사용자, 모든 사용자가 공유 하도록 웹 파트 컨트롤을 설정 및 공유 컨트롤을 개인 설정에서 관리자가 아닌 사용자 수 없습니다.

일반적으로 세 가지 방법 중 하나에서 웹 파트를 사용 하 여 작동 합니다: 페이지를 사용 하는 웹 파트 컨트롤 만들기, 개별 웹 파트 컨트롤을 만들거나 전체, 개인 설정 가능한 웹 응용 프로그램, 예: 포털입니다.

## <a name="page-development"></a>페이지 개발

페이지 개발자는 Microsoft Visual Studio 2005와 같은 비주얼 디자인 도구를 사용 하 여 웹 파트를 사용 하는 페이지를 만들 수 있습니다. Visual Studio는 웹 파트 컨트롤 집합은 같은 도구를 사용 하 여 장점 중 하나는 비주얼 디자이너에서 웹 파트 컨트롤의 끌어서 놓기 생성 및 구성에 대 한 기능을 제공 합니다. 디자이너를 사용 하 여 웹 파트 영역에 또는 웹 파트 편집기 컨트롤을 디자인 화면으로 끌어 다음 오른쪽으로 컨트롤을 구성 하는 예를 들어, 웹 파트에서 제공 하는 UI를 사용 하 여 디자이너에서 컨트롤 집합입니다. 이 웹 파트 응용 프로그램 개발을 가속화 하 고 작성 하는 코드의 양을 줄일 수 있습니다.

## <a name="control-development"></a>컨트롤 개발

표준 웹 서버 컨트롤, 사용자 지정 서버 컨트롤 및 사용자 정의 컨트롤을 포함 하 여 웹 파트 컨트롤을 기존 ASP.NET 컨트롤을 사용할 수 있습니다. 환경의 최대 프로그래밍 방식으로 컨트롤에 대 한도 WebPart 클래스에서 파생 되는 사용자 지정 웹 파트 컨트롤을 만들 수 있습니다. 개별 웹 파트 컨트롤 개발 하는 경우는 일반적으로 사용자 컨트롤 만들기 및 컨트롤을 웹 파트를 사용 하거나 사용자 지정 웹 파트 컨트롤을 개발 합니다.

사용자 지정 웹 파트 컨트롤을 개발 하는 예를 들어, 개인 설정 가능한 웹 파트 컨트롤을 패키지 하는 데 유용할 수 있는 다른 ASP.NET 서버 컨트롤에서 제공 하는 기능 중 하나를 제공 하는 컨트롤을 만들 수 있습니다: 일정, 목록, 재무 정보 뉴스, 계산기, 콘텐츠, 편집 가능한 표를 업데이트 하는 것에 대 한 서식 있는 텍스트 컨트롤 하는 데이터베이스에 연결할 차트를 동적으로 디스플레이 업데이트 또는 날씨 정보를 이동 합니다. 컨트롤을 사용 하 여 비주얼 디자이너를 제공 하는 경우 다음 Visual Studio를 사용 하는 페이지 개발자 수 컨트롤이 웹 파트 영역으로 끌어서 추가 코드를 작성할 필요 없이 디자인 타임에 구성 됩니다.

개인 설정에는 웹 파트 기능의 기초입니다. 수정 하거나 개인 설정-레이아웃, 모양 및 동작 페이지에서 웹 파트 컨트롤의 사용자 수 있습니다. 개인 설정 된 설정은 수명이 긴: 현재 브라우저 세션 뿐 아니라 유지 하기 (마찬가지로 보기 상태), 장기 저장소에도 있지만 이후의 브라우저 세션을 위해 사용자의 설정을 저장할 수 있도록 합니다. 개인 설정 웹 파트 페이지에 대 한 기본으로 사용 됩니다.

UI 구조적 구성 요소는 개인 설정에 의존 하 고 핵심 구조 및 모든 웹 파트 컨트롤에 필요한 서비스를 제공 합니다. 하나의 UI 구조 필요한 구성 요소가 모든 웹 파트 페이지의 WebPartManager 컨트롤입니다. 에 표시 되지는 않지만이 컨트롤을 페이지에서 모든 웹 파트 컨트롤을 조정 하는 중요 한 작업을 있습니다. 예를 들어, 모든 개별 웹 파트 컨트롤을 추적합니다. 웹 파트 영역 (페이지의 웹 파트 컨트롤을 포함 하는 영역)을 관리 하 고 어떤 영역에 있는 컨트롤입니다. 또한 추적 하 고 찾아보기, 연결, 편집 또는 카탈로그 모드 및 개인 설정 변경 내용은 모든 사용자에 게 또는 개별 사용자에 게 적용 되는지 여부를 페이지 등의 가능한 다양 한 디스플레이 모드를 제어 합니다. 마지막으로 시작 하 고 웹 파트 컨트롤 간의 연결 및 통신을 추적 합니다.

두 번째 구조적 구성 요소 UI 종류가 영역입니다. 영역 레이아웃 관리자 역할을 웹 파트 페이지에 있습니다. 포함 및 (일부 컨트롤), 파트 클래스에서 파생 된 컨트롤을 구성 하며 가로 또는 세로 방향 모듈식 페이지 레이아웃 작업을 수행 하는 기능을 제공 합니다. 영역; 포함 된 각 컨트롤에 대 한 공통적 이며 일관 된 UI 요소 (예: 머리글 및 바닥글 스타일, title, 테두리 스타일, 실행 단추 및 등) 제공 이러한 공통 요소를 컨트롤의 크롬 라고 합니다. 몇 가지 특수 한 유형의 영역에는 다양 한 디스플레이 모드 및 다양 한 컨트롤을 사용 하 여 사용 됩니다. 다양 한 영역 아래의 웹 파트에 대 한 필수 컨트롤 섹션에 설명 되어 있습니다.

파생 되는 모든 웹 파트 UI 컨트롤을 합니다 **파트** 클래스, 웹 파트 페이지에서 기본 UI를 구성 합니다. 웹 파트 컨트롤 집합은 유연 하 고 포괄적인 옵션을 제공 하면 파트 컨트롤을 만드는 합니다. 사용자 고유의 사용자 지정 웹 파트 컨트롤을 만드는 것 외에 기존 ASP.NET 서버 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 컨트롤을 웹 파트 컨트롤로 사용할 수도 있습니다. 웹 파트 페이지를 만들기 위한 가장 일반적으로 사용 되는 필수 컨트롤은 다음 섹션에 설명 되어 있습니다.

## <a name="web-parts-essential-controls"></a>웹 파트 필수 컨트롤

웹 파트 컨트롤 집합은 광범위 하지만 하려면 웹 파트에 대 한 필요한 또는 웹 파트 페이지에서 가장 자주 사용 하는 컨트롤을 이기 때문에 일부 컨트롤은 필수입니다. 웹 파트를 사용 하 여을 시작 하 고 기본 웹 파트 페이지를 만드는 것이 좋습니다는 다음 표에 설명 된 필수 웹 파트 컨트롤에 익숙해야 합니다.

| **웹 파트 컨트롤** | **설명** |
| --- | --- |
| WebPartManager | 페이지의 모든 웹 파트 컨트롤을 관리합니다. 하나 (및 하나만) **WebPartManager** 컨트롤은 모든 웹 파트 페이지에 대 한 필요 합니다. |
| CatalogZone | CatalogPart 컨트롤이 포함 됩니다. 사용자가 페이지에 추가할 컨트롤을 선택할 수 있는 웹 파트 컨트롤의 카탈로그를 만들려면이 영역을 사용 합니다. |
| EditorZone | EditorPart 컨트롤이 포함 됩니다. 사용자가 편집 하 고 페이지의 웹 파트 컨트롤을 개인 설정할 수 있도록이 영역을 사용 합니다. |
| WebPartZone | 포함 하 고 페이지의 기본 UI를 구성 하는 웹 파트 컨트롤에 대 한 전체 레이아웃을 제공 합니다. 웹 파트 컨트롤을 사용 하 여 페이지를 만들 때마다이 영역을 사용 합니다. 페이지는 하나 이상의 영역을 포함할 수 있습니다. |
| ConnectionsZone | WebPartConnection 컨트롤을 포함 하 고 연결을 관리 하기 위한 UI를 제공 합니다. |
| 웹 파트 (GenericWebPart) | 기본 UI를 렌더링합니다. 대부분의 웹 파트 UI 컨트롤은이 범주에 속합니다. 최대 프로그래밍 방식으로 컨트롤에 대 한 기본에서 파생 되는 사용자 지정 웹 파트 컨트롤을 만들 수 있습니다 **WebPart** 제어 합니다. 웹 파트 컨트롤로 기존 서버 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 컨트롤도 사용할 수 있습니다. 이러한 컨트롤 중 하나는 영역에 배치 됩니다 될 때마다 합니다 **WebPartManager** 컨트롤에 사용 하 여 항목을 자동으로 래핑합니다 **GenericWebPart** 웹 파트 기능을 사용 하 여 사용할 수 있도록 런타임에 제어 합니다. |
| CatalogPart | 사용자가 페이지에 추가할 수 있는 사용 가능한 웹 파트 컨트롤의 목록을 포함 합니다. |
| WebPartConnection | 페이지에서 두 웹 파트 컨트롤 간의 연결을 만듭니다. 연결 (데이터)의 공급자 및 소비자로 서 다른 웹 파트 컨트롤 중 하나를 정의 합니다. |
| EditorPart | 특수 편집기 컨트롤에 대 한 기본 클래스로 사용 됩니다. |
| EditorPart 컨트롤 (AppearanceEditorPart, LayoutEditorPart, BehaviorEditorPart, 및 PropertyGridEditorPart) | 페이지에 웹 파트 UI 컨트롤의 다양 한 측면을 개인 설정 하는 작업을 할 수 있습니다. |

## <a name="lab-create-a-web-part-page"></a>랩: 웹 파트 페이지 만들기

이 랩에서 ASP.NET 프로필을 통해 정보를 유지 하는 웹 파트 페이지를 만듭니다.

### <a name="creating-a-simple-page-with-web-parts"></a>웹 파트를 사용 하 여 간단한 페이지 만들기

이 연습 부분에서는 웹 파트 컨트롤을 사용 하 여 정적 콘텐츠를 표시 하는 페이지를 만듭니다. 웹 파트를 사용 하는 첫 번째 단계는 두 개의 필수 구조적 요소를 사용 하 여 페이지를 만드는 것입니다. 먼저, 웹 파트 페이지에는 WebPartManager 컨트롤을 추적 하 고 모든 웹 파트 컨트롤을 조정 해야 합니다. 둘째, 웹 파트 페이지에는 웹 파트 또는 다른 서버 컨트롤을 포함 하 고 페이지의 지정된 된 영역을 차지 하는 복합 컨트롤에는 하나 이상의 영역이 필요 합니다.

> [!NOTE]
> 웹 파트 개인 설정;를 사용 하도록 설정 하려면 아무 작업도 수행할 필요가 없습니다. 웹 파트 컨트롤 집합에 대해 기본적으로 활성화 됩니다. 사이트에서 웹 파트 페이지를 처음 실행 하면 ASP.NET 사용자 개인 설정을 저장 하는 기본 개인 설정 공급자를 설정 합니다. 개인 설정에 대 한 자세한 내용은 웹 파트 개인 설정 개요를 참조 하세요.


### <a name="to-create-a-page-for-containing-web-parts-controls"></a>컨트롤이 웹 파트를 포함 하는 것에 대 한 페이지를 만들려면

1. 기본 페이지를 닫고 WebPartsDemo.aspx 이라는 사이트에 새 페이지를 추가 합니다.
2. 전환할 **디자인** 보기.
3. **보기** 메뉴에서 있는지 확인 합니다 **비시각적 컨트롤** 및 **세부 정보** 레이아웃 태그 및 UI 없는 컨트롤을 볼 수 있도록 옵션을 선택 합니다.
4. 앞에 삽입 포인터를 배치할는 `<div>` 다음 enter 키를 눌러 새 줄을 추가 하 고 디자인 화면에서 태그를 지정 합니다. 줄 바꿈 문자 앞에 삽입 포인터 위치를 클릭 합니다 **블록 형식을** 드롭다운 목록에서 메뉴의 컨트롤 및 선택 합니다 **제목 1** 옵션. 머리글 텍스트 추가 **웹 파트 데모 페이지**합니다.
5. **WebParts** 끌어서 도구 상자 탭을 **WebPartManager** 컨트롤을 페이지로, 줄 바꿈 문자 바로 뒤와 앞에 배치는 `<div>`태그 합니다.   
  
   합니다 **WebPartManager** 디자이너 화면에 회색 상자로 표시 되도록 컨트롤 출력을 렌더링 하지 않습니다.
6. 내에서 삽입 지점을 `<div>` 태그입니다.
7. 에 **레이아웃** 메뉴에서 클릭 **Insert Table**, 하나의 행과 세 개의 열이 있는 새 테이블을 만듭니다. 클릭 합니다 **셀 속성** 단추를 선택 **위쪽** 에서 **세로 맞춤** 드롭 다운 목록 클릭 **확인**, 누릅니다 **확인** 다시 테이블을 만들려고 합니다.
8. WebPartZone 컨트롤을 왼쪽된 테이블 열의 끌어다 놓습니다. 마우스 오른쪽 단추로 클릭 합니다 **WebPartZone** 컨트롤을 선택 **속성**, 다음 속성을 설정:   
  
   ID: SidebarZone   
  
   HeaderText: 사이드바
9. 두 번째 끌어 **WebPartZone** 중간 테이블 열에 제어 하 고 다음 속성을 설정 합니다.   
  
   ID: MainZone   
  
   HeaderText: 주
10. 파일을 저장합니다.

페이지에는 이제 개별적으로 제어할 수 있는 두 개의 고유 영역에 있습니다. 그러나 두 영역에 모든 콘텐츠를 다음 단계는 콘텐츠 만들기. 이 연습에서는 정적 콘텐츠만 표시 하는 웹 파트 컨트롤을 사용 하 여 작동 합니다.

지정 된 웹 파트 영역의 레이아웃을 &lt;zonetemplate&gt; 요소입니다. 영역 템플릿 내에서 모든 ASP.NET 컨트롤을 사용자 지정 웹 파트 컨트롤, 사용자 지정 컨트롤, 또는 기존 서버 컨트롤을 추가할 수 있습니다. 레이블 컨트롤을 사용 하는 여기서는 단순히 추가 하는 정적 텍스트에 유의 하십시오. 일반 서버 컨트롤을 배치 하는 경우는 **WebPartZone** 영역에서 ASP.NET 컨트롤로 처리 웹 파트 컨트롤을 런타임에 컨트롤에 웹 파트 기능을 사용할 수 있는 합니다.

**주 영역에 대 한 콘텐츠를 만들려면**

1. **디자인** 보기에서 끌어서를 **레이블을** 에서 제어 합니다 **표준** 영역의 콘텐츠 영역으로 도구 상자 탭입니다 **ID** 속성 MainZone로 설정 됩니다.
2. 전환할 **원본** 보기. &lt;zonetemplate&gt; 요소가 줄 바꿈에 추가 합니다 **레이블** 는 MainZone 컨트롤.
3. 이라는 특성을 추가 **제목** 에 &lt;asp: label&gt; 요소 콘텐츠를 해당 값을 설정 하 고 합니다. 텍스트를 제거 =에서 "Label" 특성을 &lt;asp: label&gt; 요소입니다. 열고 닫는 태그 사이 합니다 &lt;asp: label&gt; 요소와 같은 일부 텍스트를 추가 **내 홈 페이지에 오신 것을 환영** 쌍 안의 &lt;h2&gt; 요소 태그입니다. 코드 같이 표시 되어야 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. 파일을 저장합니다.

다음으로 웹 파트 컨트롤을 페이지에도 추가할 수 있는 사용자 정의 컨트롤을 만듭니다.

### <a name="to-create-a-user-control"></a>사용자 정의 컨트롤을 만들려면

1. 검색 컨트롤 역할을 사이트에 새 웹 사용자 컨트롤을 추가 합니다. 옵션을 선택 취소 **소스 코드를 별도 파일에 배치**합니다. WebPartsDemo.aspx 페이지와 동일한 디렉터리에 추가한 SearchUserControl.ascx 라는 이름을 지정 합니다.   
  
    > [!NOTE]
    > 이 연습에 대 한 사용자 정의 컨트롤 실제 검색 기능을 구현 하지 않습니다. 웹 파트 기능을 설명 하기 위해서만 사용 됩니다.
2. 전환할 **디자인** 보기. **표준** 탭 도구 상자의 텍스트 상자 컨트롤을 페이지로 끌어다 놓으십시오.
3. 방금 추가한 입력란 뒤 삽입 포인터를 놓고 enter 키를 눌러 새 줄을 추가 합니다.
4. 단추 컨트롤 방금 추가한 입력란 아래 새 줄에 페이지를 끌어옵니다.
5. 전환할 **원본** 보기. 사용자 정의 컨트롤에 대 한 소스 코드를 다음과 같이 표시 되는지 확인 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. 파일을 저장한 후 닫습니다.

이제 사이드바 영역에 웹 파트 컨트롤을 추가할 수 있습니다. 두 컨트롤 사이드바 영역에 추가 하는, 이전 절차에서 만든 사용자 정의 컨트롤에는 링크와 다른 목록이 포함 된 하나입니다. 링크를 표준으로 추가 됩니다 **레이블** 서버 컨트롤을 기본 영역에 대 한 정적 텍스트를 생성 하는 방법은 비슷합니다. 개별 서버 컨트롤에 포함 되어 있지만 사용자 정의 컨트롤 (예: 레이블 컨트롤) 영역에 직접 포함 될 수 없습니다 그러나 없는 연결 되는 경우에 합니다. 대신, 이전 절차에서 만든 사용자 정의 컨트롤의 포함 됩니다. 이 일반적인 방법은 모든 컨트롤 및 사용자 정의 컨트롤을 원하는 추가 기능 패키지 한 다음 웹 파트 컨트롤을 영역에서 해당 컨트롤 참조를 보여 줍니다.

런타임 시 웹 파트 컨트롤 집합 GenericWebPart 컨트롤을 사용 하 여 두 컨트롤을 래핑합니다. 경우는 **GenericWebPart** 컨트롤 웹 서버 컨트롤, 제네릭 파트 컨트롤은 부모 컨트롤을 래핑하고 부모 컨트롤의 ChildControl 속성을 통해 서버 컨트롤에 액세스할 수 있습니다. 제네릭 파트 컨트롤의이 사용이 표준 웹 서버 컨트롤에서 파생 되는 웹 파트 컨트롤로 특성과 같은 기본 동작에 사용 하도록 설정 합니다 **WebPart** 클래스입니다.

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>사이드바 영역에 웹 파트 컨트롤을 추가 하려면

1. WebPartsDemo.aspx 페이지를 엽니다.
2. 전환할 **디자인** 보기.
3. 사용자 컨트롤 페이지를 만들 SearchUserControl.ascx를 끌어 **솔루션 탐색기** 영역에 해당 **ID** 속성 SidebarZone로 설정 되 고 있는 놓습니다.
4. WebPartsDemo.aspx 페이지를 저장 합니다.
5. 전환할 **원본** 보기.
6. 내부를 &lt;asp: webpartzone&gt; 추가 사용자 정의 컨트롤에 대 한 참조 바로 위에 SidebarZone에 대 한 요소를 &lt;asp: label&gt; 다음 예제에서와 같이 사용 하 여 요소에 링크를 포함 합니다. 또한 추가 **제목** 특성을 사용자 정의 컨트롤 태그의 값을 사용 하 여 **검색**표시 된 것 처럼 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. 파일을 저장한 후 닫습니다.

이제 브라우저에서 탐색 하 여 페이지를 테스트할 수 있습니다. 페이지에는 두 영역이 표시 됩니다. 다음 스크린 샷에서 페이지를 보여 줍니다.

**두 영역을 사용 하 여 웹 파트 데모 페이지**


![웹 파트 VS 연습 1 스크린 샷](profiles-themes-and-web-parts/_static/image3.gif)

**그림 3**: 웹 파트 VS 연습 1 스크린 샷


제목 표시줄 각 컨트롤의 동사 메뉴 컨트롤에 대해 수행 가능한 작업에 대 한 액세스를 제공 하는 아래쪽 화살표는 경우 동사 메뉴 컨트롤 중 하나를 클릭 합니다 **최소화** 동사와 참고 하 여 컨트롤이 최소화 됩니다. 동사 메뉴에서 클릭 **복원**, 보통 크기로 컨트롤을 반환 합니다.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>사용 하도록 설정 하면 사용자가 편집 페이지를 레이아웃 변경

웹 파트 끌어서 영역에서 다른 웹 파트 컨트롤의 레이아웃을 변경 하려면 사용자에 대 한 기능을 제공 합니다. 사용자가 이동 하도록 허용 하는 것 외에도 **WebPart** 다른 영역에서 컨트롤, 사용자가 해당 모양, 레이아웃 및 동작을 포함 하 여 컨트롤의 다양 한 특성을 편집 하도록 허용할 수 있습니다. 웹 파트 컨트롤 집합에 대 한 기본 편집 기능을 제공 **WebPart** 컨트롤입니다. 이이 연습에서 수행 하지는 않지만의 기능을 편집할 수 있도록 하는 사용자 지정 편집기 컨트롤도 만들 수 있습니다 **WebPart** 컨트롤입니다. 위치를 변경 하는 것과 마찬가지로 **WebPart** 컨트롤, 사용자가 만든 변경 내용을 저장 하는 ASP.NET 개인 설정 기반 컨트롤의 속성을 편집 합니다.

이 연습 부분에서는 사용자가 모든 기본 특성을 편집할 수 있는 기능 추가 **WebPart** 페이지의 컨트롤입니다. 이러한 기능을 사용 하려면 다른 사용자 지정 사용자 컨트롤 추가 페이지와 함께 &lt;asp: editorzone&gt; 요소와 두 개의 편집 컨트롤입니다.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>페이지 레이아웃을 변경할 수 있도록 하는 사용자 정의 컨트롤을 만들려면

1. Visual Studio에서에 **파일** 메뉴에서를 **새로 만들기** 하위 메뉴를 클릭 합니다 **파일** 옵션.
2. 에 **새 항목 추가** 대화 상자에서 **웹 사용자 정의 컨트롤**합니다. DisplayModeMenu.ascx 새 파일을 이름을 지정 합니다. 옵션을 선택 취소 **별도 파일에 소스 코드를 배치할**합니다.
3. 새 컨트롤을 만들려면 추가 클릭 합니다.
4. 전환할 **원본** 보기.
5. 새 파일에서 모든 기존 코드를 제거 하 고 다음 코드를 붙여 넣습니다. 이 사용자 정의 컨트롤 코드는 페이지 뷰를 변경 하거나 디스플레이 모드를 사용 하도록 설정 하는 웹 파트 컨트롤 집합의 기능을 사용 하 고 실제 모양을 변경할 수 있습니다 및 레이아웃 하는 동안 페이지의 특정 디스플레이 모드 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. 저장을 클릭 하 여 파일을 저장 아이콘을 선택 하 여 또는 도구 모음에서 **저장할** 에 **파일** 메뉴.

### <a name="to-enable-users-to-change-the-layout"></a>레이아웃을 변경 하려면 사용자를 사용 하도록 설정 하려면

1. WebPartsDemo.aspx 페이지를 열고 전환할 **디자인** 보기.
2. 컨트롤에서 삽입 지점 위치를 **디자인** 직후 보기는 **WebPartManager** 이전에 추가한 컨트롤을 합니다. 후 빈 줄이 되도록 하드 반환 텍스트 뒤에 추가 합니다 **WebPartManager** 제어 합니다. 빈 줄에 커서를 놓습니다.
3. 방금 만든 사용자 정의 컨트롤을 끌어 옵니다 (파일 이름은 DisplayModeMenu.ascx) 페이지는 WebPartsDemo.aspx에 빈 줄에 놓습니다.
4. EditorZone 컨트롤을 끌어 합니다 **WebParts** WebPartsDemo.aspx 페이지의 나머지 열려 있는 테이블 셀에 도구 상자의 섹션입니다.
5. **WebParts** 섹션 도구 상자의 AppearanceEditorPart 컨트롤을 및 LayoutEditorPart 컨트롤을 끌어 합니다 **EditorZone** 컨트롤입니다.
6. 전환할 **원본** 보기. 테이블 셀의 결과 코드가 다음 코드와 비슷해야 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. WebPartsDemo.aspx 파일을 저장 합니다. 디스플레이 모드를 변경 하 고 페이지 레이아웃을 변경할 수 있는 사용자 정의 컨트롤을 만들고 기본 웹 페이지의 컨트롤을 참조 했습니다.

이제 페이지를 편집 하 고 레이아웃을 변경 하는 기능을 테스트할 수 있습니다.

### <a name="to-test-layout-changes"></a>레이아웃 변경 내용을 테스트 하려면

1. 브라우저에서 페이지를 로드 합니다.
2. 클릭 합니다 **디스플레이 모드** 드롭 다운 메뉴에서 선택한 **편집**합니다. 영역 제목이 표시 됩니다.
3. 끌기 합니다 **내 링크** 주 영역 아래쪽에 세로 막대 영역에서의 제목 표시줄 컨트롤입니다. 페이지에는 다음 스크린샷과 같습니다.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>이동 내 링크 컨트롤을 사용 하 여 웹 파트 데모 페이지


![웹 파트 VS 연습 2 스크린 샷](profiles-themes-and-web-parts/_static/image4.gif)

**그림 4**: 웹 파트 VS 연습 2 스크린 샷


1. 클릭 합니다 **디스플레이 모드** 드롭 다운 메뉴에서 선택한 **찾아보기**합니다. 페이지가 새로 고쳐집니다, 영역 이름을 사라지는 하며 **내 링크** 유지 하는 위치를 제어 합니다.
2. 개인 설정이 사용 되는 작업을 보여 주기 위해 브라우저를 닫고 페이지를 다시 로드 합니다. 이후의 브라우저 세션에 대 한 변경 내용을 저장 됩니다.
3. **디스플레이 모드** 메뉴에서 **편집**합니다.   
  
   동사 드롭다운 메뉴를 포함 하는 제목 표시줄에 있는 아래쪽 화살표를 사용 하 여 각 페이지의 컨트롤에 표시 됩니다.
4. 동사 메뉴를 표시 하려면 화살표를 클릭 합니다 **내 링크** 제어 합니다. 클릭 합니다 **편집** 동사입니다.   
  
   합니다 **EditorZone** 컨트롤이 표시, 추가 제어는 EditorPart를 표시 합니다.
5. 에 **모양을** 변경 하는 편집 컨트롤의 섹션을 **제목** 즐겨찾기를 사용 하 여는 **크롬 유형** 선택 하려면 드롭다운 목록 **제목만**를 클릭 하 고 **적용**합니다. 다음 스크린 샷에서 편집 모드에 있는 페이지를 보여줍니다.

### <a name="web-parts-demo-page-in-edit-mode"></a>편집 모드에서 웹 파트 데모 페이지


![웹 파트 VS 연습 3 스크린 샷](profiles-themes-and-web-parts/_static/image5.gif)

**그림 5**: 웹 파트 VS 연습 3 스크린 샷


1. 클릭 합니다 **디스플레이 모드** 메뉴에서 선택한 **찾아보기** 찾아보기 모드로 돌아갑니다.
2. 이제 컨트롤에는 업데이트 된 제목과 테두리가 없는 다음 스크린 샷과 같이 합니다.

### <a name="edited-web-parts-demo-page"></a>웹 파트 데모 페이지 편집된


![웹 파트 VS 연습 4 스크린 샷](profiles-themes-and-web-parts/_static/image6.gif)

**그림 4**: 웹 파트 VS 연습 4 스크린 샷


### <a name="adding-web-parts-at-run-time"></a>런타임 시 웹 파트 추가

또한 런타임 시 해당 페이지에 웹 파트 컨트롤을 추가 하는 사용자를 허용할 수 있습니다. 이렇게 하려면 사용자에 게 제공 하려는 웹 파트 컨트롤의 목록을 포함 하는 웹 파트 카탈로그를 사용 하 여 페이지를 구성 합니다.

**런타임 시 웹 파트를 추가할 수 있도록 하려면**

1. WebPartsDemo.aspx 페이지를 열고 전환할 **디자인** 보기.
2. **WebParts** 탭 도구 상자의 컨트롤을 끌어 CatalogZone 테이블의 오른쪽 열에 아래 합니다 **EditorZone** 제어 합니다.   
  
   동시에 표시 되지 것입니다 두 컨트롤 모두에 동일한 표 셀 수 있습니다.
3. 속성 창에서 문자열을 할당 **웹 파트 추가** HeaderText 속성에 **CatalogZone** 제어 합니다.
4. 합니다 **WebParts** 섹션 도구 상자의 DeclarativeCatalogPart 컨트롤의 콘텐츠 영역으로 끕니다 합니다 **CatalogZone** 컨트롤입니다.
5. 오른쪽 위 모퉁이의 화살표를 클릭 합니다 **DeclarativeCatalogPart** 컨트롤을 해당 작업 메뉴를 표시 한 다음 선택 **템플릿 편집**합니다.
6. **표준** 끌어서 도구 상자의 섹션을 **FileUpload** 컨트롤 및 **달력** 컨트롤을 **WebPartsTemplate** 섹션의 **DeclarativeCatalogPart** 제어 합니다.
7. 전환할 **원본** 보기. 소스 코드를 검사 합니다 &lt;asp: catalogzone&gt; 요소입니다. 있음을 합니다 **DeclarativeCatalogPart** 컨트롤에는 &lt;webpartstemplate&gt; 카탈로그에서 페이지에 추가할 수 있는 두 개의 포함된 서버 컨트롤을 사용 하 여 요소.
8. 추가 된 **제목** 표시 되는 문자열 값을 사용 하 여 아래 코드 예제에서는 각 타이틀에 대 한 카탈로그에 추가한 컨트롤의 각 속성입니다. 제목 속성 되지 않더라도 설정할 수 있습니다 일반적으로 이러한 두 서버 컨트롤에서 사용자를 이러한 컨트롤을 추가 하는 경우 디자인 타임에 **WebPartZone** 영역 런타임에 카탈로그에서 각 래핑됩니다와  **GenericWebPart** 제어 합니다. 이 통해 제목을 표시 하는 일을 할 수 있도록 웹 파트 컨트롤 역할을 합니다.   
  
   에 포함 된 두 개의 컨트롤에 대 한 코드를 **DeclarativeCatalogPart** 컨트롤 같이 표시 되어야 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. 페이지를 저장합니다.

이제 카탈로그를 테스트할 수 있습니다.

### <a name="to-test-the-web-parts-catalog"></a>웹 파트 카탈로그를 테스트 하려면

1. 브라우저에서 페이지를 로드 합니다.
2. 클릭 합니다 **디스플레이 모드** 드롭 다운 메뉴에서 선택한 **카탈로그**합니다.   
  
   라는 카탈로그 **웹 파트 추가** 표시 됩니다.
3. 끌어서 합니다 **즐겨찾기** 사이드바 영역의 맨 위로 이동 주 영역에서 제어 하 고 있는 놓습니다.
4. 에 **웹 파트 추가** 카탈로그, 두 확인란을 선택한 후 **Main** 사용할 수 있는 영역을 포함 하는 드롭다운 목록에서.
5. 클릭 **추가** 카탈로그에서 합니다. 주 영역에 컨트롤을 추가 합니다. 원한다 면 페이지로 카탈로그에서 컨트롤의 여러 인스턴스를 추가할 수 있습니다.   
  
   다음 스크린 샷은 주 영역에 파일 업로드 컨트롤 및 달력을 사용 하 여 페이지를 보여 줍니다. 

![카탈로그에서 주 영역에 추가 된 컨트롤](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. 클릭 합니다 **디스플레이 모드** 드롭 다운 메뉴에서 선택한 **찾아보기**합니다. 카탈로그 사라지고 페이지가 새로 고쳐집니다.
7. 브라우저를 닫습니다. 페이지를 다시 로드 합니다. 변경 내용이 유지 됩니다.
