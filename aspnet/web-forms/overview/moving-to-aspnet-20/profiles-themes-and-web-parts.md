---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: 프로필, 테마 및 웹 파트 | Microsoft Docs
author: microsoft
description: ASP.NET 2.0에는 구성 및 계측의 주요 변경 사항이 있습니다. 새 ASP.NET 구성 API를 통해 구성 변경을 pr으로 수행할 수 있습니다.
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: cf5c45781be6d003d28c6aa27efa08032579a6dd
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78474641"
---
# <a name="profiles-themes-and-web-parts"></a>프로필, 테마 및 웹 파트

[Microsoft](https://github.com/microsoft) 에서

> ASP.NET 2.0에는 구성 및 계측의 주요 변경 사항이 있습니다. 새 ASP.NET 구성 API를 사용 하면 프로그래밍 방식으로 구성을 변경할 수 있습니다. 또한 많은 새 구성 설정이 새 구성 및 계측에 대해 허용 됩니다.

ASP.NET 2.0은 개인 설정 된 웹 사이트의 영역에서 상당한 개선을 나타냅니다. 이미 다루는 멤버 자격 기능 외에도 ASP.NET 프로필, 테마 및 웹 파트는 웹 사이트에서 개인 설정을 크게 향상 시킵니다.

## <a name="aspnet-profiles"></a>ASP.NET 프로필

ASP.NET 프로필은 세션과 비슷합니다. 차이점은 프로필이 영구적 이지만 브라우저가 닫힐 때 세션이 손실 된다는 것입니다. 세션과 프로필의 또 다른 큰 차이점은 프로필은 강력한 형식 이므로 개발 프로세스 중에 IntelliSense를 제공 한다는 것입니다.

프로필은 컴퓨터 구성 파일 또는 응용 프로그램에 대 한 web.config 파일에서 정의 됩니다. (하위 폴더 web.config 파일에는 프로필을 정의할 수 없습니다.) 아래 코드는 웹 사이트 방문자의 이름과 성을 저장 하는 프로필을 정의 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

프로필 속성의 기본 데이터 형식은 System.string입니다. 위의 예에서는 데이터 형식을 지정 하지 않았습니다. 따라서 FirstName 및 LastName 속성은 모두 문자열 형식입니다. 앞에서 설명한 것 처럼 프로필 속성은 강력한 형식입니다. 아래 코드는 Int32 형식의 age에 대 한 새 속성을 추가 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

프로필은 일반적으로 ASP.NET Forms 인증과 함께 사용 됩니다. 폼 인증과 함께 사용 하는 경우 각 사용자에 게는 사용자 ID와 연결 된 별도의 프로필이 있습니다. 그러나 아래와 같이 **allowanonymous** 특성과 함께 구성 파일의 &lt;anonymousIdentification&gt; 요소를 사용 하 여 익명 응용 프로그램에서 프로필을 사용 하도록 허용할 수도 있습니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

익명 사용자가 사이트를 탐색 하면 ASP.NET는 사용자에 대 한 **ProfileCommon** 의 인스턴스를 만듭니다. 이 프로필은 브라우저의 쿠키에 저장 된 고유한 ID를 사용 하 여 사용자를 고유한 방문자로 식별 합니다. 이러한 방식으로 익명으로 검색 하는 사용자에 대 한 프로필 정보를 저장할 수 있습니다.

## <a name="profile-groups"></a>프로필 그룹

프로필의 속성을 그룹화 할 수 있습니다. 속성을 그룹화 하면 특정 응용 프로그램에 대해 여러 프로필을 시뮬레이션할 수 있습니다.

다음 구성에서는 두 그룹의 FirstName 및 LastName 속성을 구성 합니다. 구매자 및 잠재 고객.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

그러면 다음과 같이 특정 그룹의 속성을 설정할 수 있습니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>복합 개체 저장

지금까지 설명한 예제는 프로필에 단순 데이터 형식을 저장 했습니다. **SerializeAs** 특성을 사용 하 여 serialization 방법을 다음과 같이 지정 하 여 복합 데이터 형식을 프로필에 저장할 수도 있습니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

이 경우 형식은 PurchaseInvoice입니다. PurchaseInvoice 클래스는 serializable로 표시 해야 하며 원하는 수의 속성을 포함할 수 있습니다. 예를 들어 PurchaseInvoice에 **NumItemsPurchased**라는 속성이 있는 경우 다음과 같이 코드에서 해당 속성을 참조할 수 있습니다.

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>프로필 상속

여러 응용 프로그램에서 사용할 프로필을 만들 수 있습니다. ProfileBase에서 파생 되는 프로필 클래스를 만들면 아래와 같이 **inherits** 특성을 사용 하 여 여러 응용 프로그램에서 프로필을 다시 사용할 수 있습니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

이 경우 **PurchasingProfile** 클래스는 다음과 같습니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>프로필 공급자

ASP.NET 프로필은 공급자 모델을 사용 합니다. 기본 공급자는 SqlProfileProvider 공급자를 사용 하 여 웹 응용 프로그램의 App\_Data 폴더에 있는 SQL Server Express 데이터베이스에 정보를 저장 합니다. 데이터베이스가 존재 하지 않는 경우 ASP.NET는 프로필에서 정보를 저장 하려고 할 때 자동으로 만듭니다.

그러나 경우에 따라 사용자 고유의 프로필 공급자를 개발 하는 것이 좋습니다. ASP.NET profile 기능을 사용 하면 다른 공급자를 쉽게 사용할 수 있습니다.

사용자 지정 프로필 공급자는 다음과 같은 경우에 만듭니다.

- .NET Framework에 포함 된 프로필 공급자가 지원 하지 않는 FoxPro 데이터베이스 또는 Oracle 데이터베이스의와 같은 데이터 원본에 프로필 정보를 저장 해야 합니다.
- .NET Framework 포함 된 공급자에서 사용 하는 데이터베이스 스키마와 다른 데이터베이스 스키마를 사용 하 여 프로필 정보를 관리 해야 합니다. 일반적인 예는 프로필 정보를 기존 SQL Server 데이터베이스의 사용자 데이터와 통합 하려는 경우입니다.

### <a name="required-classes"></a>필수 클래스

프로필 공급자를 구현 하려면 System.web. Profile. ProfileProvider 추상 클래스를 상속 하는 클래스를 만듭니다. 그러면 **Profileprovider** 추상 클래스는 SettingsProvider 추상 클래스를 상속 하며,이 클래스는 system.object를 상속 하는 추상 클래스를 상속 합니다. 이 상속 체인 때문에 **Profileprovider** 클래스의 필수 멤버 외에도 **SettingsProvider** 및 **providerbase** 클래스의 필수 멤버를 구현 해야 합니다.

다음 표에서는 **Providerbase**, **SettingsProvider**및 **profileprovider** abstract 클래스에서 구현 해야 하는 속성 및 메서드에 대해 설명 합니다.

### <a name="providerbase-members"></a>ProviderBase 멤버

| **멤버** | **설명** |
| --- | --- |
| Initialize 메서드 | 공급자 인스턴스의 이름 및 구성 설정의 NameValueCollection를 입력으로 사용 합니다. 컴퓨터 구성 또는 Web.config 파일에 지정 된 구현 특정 값 및 옵션을 포함 하 여 공급자 인스턴스의 옵션 및 속성 값을 설정 하는 데 사용 됩니다. |

### <a name="settingsprovider-members"></a>SettingsProvider 멤버

| **멤버** | **설명** |
| --- | --- |
| ApplicationName 속성 | 각 프로필에 저장 된 응용 프로그램 이름입니다. 프로필 공급자는 응용 프로그램 이름을 사용 하 여 각 응용 프로그램에 대해 별도로 프로필 정보를 저장 합니다. 이렇게 하면 여러 ASP.NET 응용 프로그램에서 동일한 사용자 이름이 다른 응용 프로그램에서 생성 된 경우 충돌 없이 동일한 데이터 원본을 사용할 수 있습니다. 또는 여러 ASP.NET 응용 프로그램에서 동일한 응용 프로그램 이름을 지정 하 여 프로필 데이터 원본을 공유할 수 있습니다. |
| GetPropertyValues 메서드 | SettingsContext 및 SettingsPropertyCollection 개체를 입력으로 사용 합니다. **SettingsContext** 사용자에 대 한 정보를 제공 합니다. 이 정보를 기본 키로 사용 하 여 사용자에 대 한 프로필 속성 정보를 검색할 수 있습니다. **SettingsContext** 개체를 사용 하 여 사용자 이름 및 사용자의 인증 여부를 가져옵니다. **SettingsPropertyCollection** 에는 settingsproperty 개체의 컬렉션이 포함 되어 있습니다. 각 **settingsproperty** 개체는 속성의 이름 및 유형과 속성의 기본값, 속성이 읽기 전용인 지 여부 등의 추가 정보를 제공 합니다. **Getpropertyvalues** 메서드는 입력으로 제공 된 **settingsproperty** 개체에 따라 settingspropertyvalue objects를 사용 하 여 settingspropertyvaluecollection을 채웁니다. 지정 된 사용자에 대 한 데이터 소스의 값이 각 **settingspropertyvalue** 개체의 PropertyValue 속성에 할당 되 고 전체 컬렉션이 반환 됩니다. 메서드를 호출 하면 지정 된 사용자 프로필의 LastActivityDate 값도 현재 날짜 및 시간으로 업데이트 됩니다. |
| SetPropertyValues 메서드 | **SettingsContext** 및 **Settingspropertyvaluecollection** 개체를 입력으로 사용 합니다. **SettingsContext** 사용자에 대 한 정보를 제공 합니다. 이 정보를 기본 키로 사용 하 여 사용자에 대 한 프로필 속성 정보를 검색할 수 있습니다. **SettingsContext** 개체를 사용 하 여 사용자 이름 및 사용자의 인증 여부를 가져옵니다. **Settingspropertyvaluecollection** 에는 **settingspropertyvalue** 개체의 컬렉션이 포함 되어 있습니다. 각 **Settingspropertyvalue** 개체는 속성의 이름, 형식 및 값 뿐만 아니라 속성의 기본값, 속성이 읽기 전용인 지 여부 등의 추가 정보를 제공 합니다. **Setpropertyvalues** 메서드는 지정 된 사용자에 대 한 데이터 원본의 프로필 속성 값을 업데이트 합니다. 메서드를 호출 하면 지정 된 사용자 프로필의 **Lastactivitydate** 및 LastUpdatedDate 값도 현재 날짜 및 시간으로 업데이트 됩니다. |

### <a name="profileprovider-members"></a>ProfileProvider 멤버

| **멤버** | **설명** |
| --- | --- |
| DeleteProfiles 메서드 | 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 경우 지정 된 이름에 대 한 모든 프로필 정보 및 속성 값을 입력으로 사용 하 여 사용자 이름 및 데이터 소스에서 삭제 합니다. 데이터 원본에서 트랜잭션을 지 원하는 경우 트랜잭션에 모든 삭제 작업을 포함 하는 것이 좋습니다 .이 경우에는 트랜잭션을 롤백하고 삭제 작업이 실패 하면 예외를 throw 하는 것이 좋습니다. |
| DeleteProfiles 메서드 | 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 각 프로필에 대 한 프로필 정보 및 속성 값을 모두 입력으로 사용 하 여 데이터 원본에서 프로필 정보를 수집 하 고 삭제 합니다. 데이터 원본에서 트랜잭션을 지 원하는 경우 트랜잭션에 모든 삭제 작업을 포함 하 고 트랜잭션을 롤백하고 삭제 작업이 실패 하는 경우 예외를 throw 하는 것이 좋습니다. |
| DeleteInactiveProfiles 메서드 | 는 ProfileAuthenticationOption 값과 DateTime 개체를 입력으로 사용 하 고, 마지막 작업 날짜가 지정 된 날짜 및 시간 보다 작거나 같고 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 모든 프로필 정보 및 속성 값을 데이터 소스에서 삭제 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필만 또는 모든 프로필을 삭제할지 여부를 지정 합니다. 데이터 원본에서 트랜잭션을 지 원하는 경우 트랜잭션에 모든 삭제 작업을 포함 하 고 트랜잭션을 롤백하고 삭제 작업이 실패 하는 경우 예외를 throw 하는 것이 좋습니다. |
| GetAllProfiles 메서드 | 는 **Profileauthenticationoption** 값을 입력으로 사용 하 고, 페이지 인덱스를 지정 하는 정수, 페이지 크기를 지정 하는 정수 및 총 프로필 수로 설정 되는 정수에 대 한 참조로 사용 합니다. 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 데이터 원본의 모든 프로필에 대 한 **profileinfo** 개체를 포함 하는 profileinfocollection을 반환 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필만 또는 모든 프로필을 반환할지 여부를 지정 합니다. **GetAllProfiles** 메서드에서 반환 되는 결과는 페이지 인덱스와 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값은 **Profileinfocollection**에 반환할 **profileinfo** 개체의 최대 수를 지정 합니다. 페이지 인덱스 값은 반환할 결과 페이지를 지정 합니다. 여기서 1은 첫 번째 페이지를 식별 합니다. 총 레코드에 대 한 매개 변수는 전체 프로필 수로 설정 된 out 매개 변수입니다 (Visual Basic에서 **ByRef** 를 사용할 수 있음). 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 개의 프로필이 포함 되 고 페이지 인덱스 값이 2 인 경우 페이지 크기가 5 인 경우 **Profileinfocollection** 에는 여섯 번째 프로필이 포함 된 프로필이 포함 됩니다. 메서드가 반환 될 때 total records 값은 13으로 설정 됩니다. |
| GetAllInactiveProfiles 메서드 | 는 **Profileauthenticationoption** 값, **DateTime** 개체, 페이지 인덱스를 지정 하는 정수, 페이지 크기를 지정 하는 정수 및 총 프로필 수로 설정 되는 정수에 대 한 참조로 사용 합니다. 마지막 작업 날짜가 지정 된 **날짜/시간** 보다 작거나 같고 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 데이터 소스의 모든 프로필에 대 한 **profileinfo** 개체를 포함 하는 **profileinfocollection** 을 반환 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필만 또는 모든 프로필을 반환할지 여부를 지정 합니다. **Getallinactiveprofiles** 메서드에서 반환 되는 결과는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값은 **Profileinfocollection**에 반환할 **profileinfo** 개체의 최대 수를 지정 합니다. 페이지 인덱스 값은 반환할 결과 페이지를 지정 합니다. 여기서 1은 첫 번째 페이지를 식별 합니다. 총 레코드에 대 한 매개 변수는 전체 프로필 수로 설정 된 out 매개 변수입니다 (Visual Basic에서 **ByRef** 를 사용할 수 있음). 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 개의 프로필이 포함 되 고 페이지 인덱스 값이 2 인 경우 페이지 크기가 5 인 경우 **Profileinfocollection** 에는 여섯 번째 프로필이 포함 된 프로필이 포함 됩니다. 메서드가 반환 될 때 total records 값은 13으로 설정 됩니다. |
| Find프로필 Byusername 메서드 | 는 **Profileauthenticationoption** 값을 입력으로 사용 하 고, 사용자 이름을 포함 하는 문자열을, 페이지 인덱스를 지정 하는 정수, 페이지 크기를 지정 하는 정수 및 총 프로필 수로 설정 되는 정수에 대 한 참조로 사용 합니다. 사용자 이름이 지정 된 사용자 이름과 일치 하 고 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 데이터 원본의 모든 프로필에 대 한 **profileinfo** 개체를 포함 하는 **profileinfocollection** 을 반환 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필만 또는 모든 프로필을 반환할지 여부를 지정 합니다. 데이터 원본에는 와일드 카드 문자 등의 추가 검색 기능을 지 원하는 경우에 사용자 이름에 대 한 보다 광범위 한 검색 기능을 제공할 수 있습니다. **Find프로필 Byusername** 메서드에서 반환 되는 결과는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값은 **Profileinfocollection**에 반환할 **profileinfo** 개체의 최대 수를 지정 합니다. 페이지 인덱스 값은 반환할 결과 페이지를 지정 합니다. 여기서 1은 첫 번째 페이지를 식별 합니다. 총 레코드에 대 한 매개 변수는 전체 프로필 수로 설정 된 out 매개 변수입니다 (Visual Basic에서 **ByRef** 를 사용할 수 있음). 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 개의 프로필이 포함 되 고 페이지 인덱스 값이 2 인 경우 페이지 크기가 5 인 경우 **Profileinfocollection** 에는 여섯 번째 프로필이 포함 된 프로필이 포함 됩니다. 메서드가 반환 될 때 total records 값은 13으로 설정 됩니다. |
| Findinactive프로필 Byusername 메서드 | 는 **Profileauthenticationoption** 값을 입력으로 사용 하 고, 사용자 이름을 포함 하는 문자열을, **DateTime** 개체, 페이지 인덱스를 지정 하는 정수, 페이지 크기를 지정 하는 정수 및 총 프로필 수로 설정 되는 정수에 대 한 참조로 사용 합니다. 사용자 이름이 지정 된 사용자 이름과 일치 하는 데이터 소스의 모든 프로필에 대 한 **Profileinfo** 개체를 포함 하는 **profileinfocollection** 을 반환 합니다. 여기서 마지막 작업 날짜는 지정 된 날짜 **/시간**보다 작거나 같고 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필만 또는 모든 프로필을 반환할지 여부를 지정 합니다. 데이터 원본에는 와일드 카드 문자 등의 추가 검색 기능을 지 원하는 경우에 사용자 이름에 대 한 보다 광범위 한 검색 기능을 제공할 수 있습니다. **Findinactive프로필 Byusername** 메서드에서 반환 되는 결과는 페이지 인덱스 및 페이지 크기 값에 의해 제한 됩니다. 페이지 크기 값은 **Profileinfocollection**에 반환할 **profileinfo** 개체의 최대 수를 지정 합니다. 페이지 인덱스 값은 반환할 결과 페이지를 지정 합니다. 여기서 1은 첫 번째 페이지를 식별 합니다. 총 레코드에 대 한 매개 변수는 전체 프로필 수로 설정 된 out 매개 변수입니다 (Visual Basic에서 **ByRef** 를 사용할 수 있음). 예를 들어 데이터 저장소에 응용 프로그램에 대 한 13 개의 프로필이 포함 되 고 페이지 인덱스 값이 2 인 경우 페이지 크기가 5 인 경우 **Profileinfocollection** 에는 여섯 번째 프로필이 포함 된 프로필이 포함 됩니다. 메서드가 반환 될 때 total records 값은 13으로 설정 됩니다. |
| Get번호 Ofinactiveprofiles 메서드 | 는 **Profileauthenticationoption** 값과 **DateTime** 개체를 입력으로 사용 하 고 마지막 작업 날짜가 지정 된 **날짜/시간** 보다 작거나 같고 응용 프로그램 이름이 **ApplicationName** 속성 값과 일치 하는 데이터 원본에 있는 모든 프로필의 수를 반환 합니다. **Profileauthenticationoption** 매개 변수는 익명 프로필, 인증 된 프로필 또는 모든 프로필만 계산할지 여부를 지정 합니다. |

### <a name="applicationname"></a>ApplicationName

프로필 공급자는 각 응용 프로그램에 대해 프로필 정보를 개별적으로 저장 하므로 데이터 스키마에 응용 프로그램 이름이 포함 되 고 쿼리 및 업데이트에도 응용 프로그램 이름이 포함 되는지 확인 해야 합니다. 예를 들어 다음 명령은 사용자 이름 및 프로필이 익명 인지 여부를 기준으로 데이터베이스에서 속성 값을 검색 하는 데 사용 되며 **ApplicationName** 값이 쿼리에 포함 되도록 합니다.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>ASP.NET 테마

## <a name="what-are-aspnet-20-themes"></a>ASP.NET 2.0 테마 란?

웹 응용 프로그램의 가장 중요 한 측면 중 하나는 사이트 전체에서 일관 된 모양과 느낌입니다. ASP.NET 1.x 개발자는 일반적으로 CSS (CSS 스타일시트)를 사용 하 여 일관 된 모양과 느낌을 구현 합니다. ASP.NET 2.0 테마는 ASP.NET 개발자가 HTML 요소 뿐만 아니라 ASP.NET 서버 컨트롤의 모양을 정의 하는 기능을 제공 하기 때문에 CSS를 크게 향상 시킵니다. ASP.NET 테마는 개별 컨트롤, 특정 웹 페이지 또는 전체 웹 응용 프로그램에 적용할 수 있습니다. 테마는 CSS 파일, 선택적 스킨 파일 및 이미지가 필요한 경우 선택적 이미지 디렉터리의 조합을 사용 합니다. 스킨 파일은 ASP.NET server 컨트롤의 시각적 모양을 제어 합니다.

## <a name="where-are-themes-stored"></a>테마는 어디에 저장 되나요?

테마를 저장 하는 위치는 범위에 따라 다릅니다. 모든 응용 프로그램에 적용할 수 있는 테마는 다음 폴더에 저장 됩니다.

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

특정 응용 프로그램과 관련 된 테마는 웹 사이트의 루트에 있는 `App\_Themes\<Theme\_Name>` 디렉터리에 저장 됩니다.

> [!NOTE]
> 스킨 파일은 모양에 영향을 주는 서버 컨트롤 속성만 수정 해야 합니다.

전역 테마는 웹 서버에서 실행 되는 모든 응용 프로그램 또는 웹 사이트에 적용할 수 있는 테마입니다. 이러한 테마는 기본적으로 xxxxx 디렉터리에 있는 NETClientfiles\Themes 디렉터리에 저장 됩니다. 또는 웹 사이트의 루트에 있는 aspnet\_client/system\_web/[version]/Themes/[theme\_name] 폴더로 테마 파일을 이동할 수 있습니다.

응용 프로그램 특정 테마는 파일이 상주 하는 응용 프로그램에만 적용 될 수 있습니다. 이러한 파일은 웹 사이트의 루트에 있는 `App\_Themes/<theme\_name>` 디렉터리에 저장 됩니다.

## <a name="the-components-of-a-theme"></a>테마의 구성 요소

테마는 하나 이상의 CSS 파일, 선택적 스킨 파일 및 선택적 이미지 폴더로 구성 됩니다. CSS 파일은 원하는 모든 이름이 될 수 있으며 (예: .css 또는 테마 .css 등) 테마 폴더의 루트에 있어야 합니다. CSS 파일은 특정 선택기에 대 한 일반 CSS 클래스 및 특성을 정의 하는 데 사용 됩니다. 페이지 요소에 CSS 클래스 중 하나를 적용 하려면 **CSSClass** 속성을 사용 합니다.

스킨 파일은 ASP.NET 서버 컨트롤에 대 한 속성 정의를 포함 하는 XML 파일입니다. 아래에 나열 된 코드는 스킨 파일의 예제입니다.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

아래 **그림 1** 에서는 테마를 적용 하지 않고 검색 된 작은 ASP.NET 페이지를 보여 줍니다. **그림 2** 에는 테마가 적용 된 동일한 파일이 표시 됩니다. 배경색 및 텍스트 색은 CSS 파일을 통해 구성 됩니다. 단추와 텍스트 상자의 모양은 위에 나열 된 스킨 파일을 사용 하 여 구성 됩니다.

![테마 없음](profiles-themes-and-web-parts/_static/image1.gif)

**그림 1**: 테마 없음

![테마가 적용 됨](profiles-themes-and-web-parts/_static/image2.gif)

**그림 2**: 테마가 적용 됨

위에 나열 된 스킨 파일은 모든 TextBox 컨트롤과 단추 컨트롤에 대 한 기본 스킨을 정의 합니다. 즉, 페이지에 삽입 된 모든 TextBox 컨트롤과 Button 컨트롤은이 모양을 사용 합니다. 컨트롤의 **SkinID** 속성을 사용 하 여 이러한 컨트롤의 특정 인스턴스에 적용할 수 있는 스킨을 정의할 수도 있습니다.

아래 코드는 단추 컨트롤의 스킨을 정의 합니다. **GoButton** 의 **SkinID** 속성이 있는 Button 컨트롤만 스킨의 모양에 적용 됩니다.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

서버 컨트롤 형식 마다 하나의 기본 스킨이 있을 수 있습니다. 추가 스킨이 필요한 경우에는 SkinID 속성을 사용 해야 합니다.

## <a name="applying-themes-to-pages"></a>페이지에 테마 적용

다음 방법 중 하나를 사용 하 여 테마를 적용할 수 있습니다.

- Web.config 파일의 &lt;pages&gt; 요소
- 페이지의 @Page 지시어
- 프로그래밍 방식

## <a name="applying-a-theme-in-the-configuration-file"></a>구성 파일에 테마 적용

응용 프로그램 구성 파일에서 테마를 적용 하려면 다음 구문을 사용 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

여기에 지정 된 테마 이름은 테마 폴더의 이름과 일치 해야 합니다. 이 폴더는이 과정의 앞부분에서 설명한 위치 중 하나에 있을 수 있습니다. 존재 하지 않는 테마를 적용 하려고 하면 구성 오류가 발생 합니다.

## <a name="applying-a-theme-in-the-page-directive"></a>Page 지시문에 테마 적용

@ Page 지시문에 테마를 적용할 수도 있습니다. 이 메서드를 사용 하면 특정 페이지에 테마를 사용할 수 있습니다.

@Page 지시문에 테마를 적용 하려면 다음 구문을 사용 합니다.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

다시 한 번 여기에 지정 된 테마가 앞에서 설명한 대로 테마 폴더와 일치 해야 합니다. 존재 하지 않는 테마를 적용 하려고 하면 빌드 오류가 발생 합니다. 또한 Visual Studio에서는 특성을 강조 표시 하 고 이러한 테마가 없다는 사실을 알려 줍니다.

## <a name="applying-a-theme-programmatically"></a>프로그래밍 방식으로 테마 적용

프로그래밍 방식으로 테마를 적용 하려면 페이지 **\_PreInit** 메서드 페이지의 **테마** 속성을 지정 해야 합니다.

프로그래밍 방식으로 테마를 적용 하려면 다음 구문을 사용 합니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

페이지 수명 주기 때문에 PreInit 메서드에 테마를 적용 해야 합니다. 이 시점 이후에 적용 하는 경우 페이지 테마는 이미 런타임에 적용 되 고 해당 시점에 변경 내용이 수명 주기에서 너무 늦습니다. 존재 하지 않는 테마를 적용 하면 **Httpexception** 이 발생 합니다. 테마를 프로그래밍 방식으로 적용 하면 서버 컨트롤에 SkinID 속성이 지정 된 경우 빌드 경고가 발생 합니다. 이 경고는 어떠한 테마도 선언적으로 적용 되지 않으며 무시할 수 있음을 알리기 위한 것입니다.

## <a name="exercise-1--applying-a-theme"></a>연습 1: 테마 적용

이 연습에서는 ASP.NET 테마를 웹 사이트에 적용 합니다.

> [!IMPORTANT]
> Microsoft Word를 사용 하 여 스킨 파일에 정보를 입력 하는 경우에는 따옴표를 사용 하 여 일반 따옴표를 대체 하지 않아야 합니다. 스마트 따옴표를 사용 하면 스킨 파일에 문제가 발생 합니다.

1. 새 ASP.NET 웹 사이트 만들기
2. 솔루션 탐색기에서 프로젝트를 마우스 오른쪽 단추로 클릭 하 고 새 항목 추가를 선택 합니다.
3. 파일 목록에서 웹 구성 파일을 선택 하 고 추가를 클릭 합니다.
4. 솔루션 탐색기에서 프로젝트를 마우스 오른쪽 단추로 클릭 하 고 새 항목 추가를 선택 합니다.
5. 스킨 파일을 선택 하 고 추가를 클릭 합니다.
6. 앱\_테마 폴더 내에 파일을 저장할 것인지 묻는 메시지가 표시 되 면 예를 클릭 합니다.
7. 솔루션 탐색기에서 앱\_테마 폴더 내의 SkinFile 폴더를 마우스 오른쪽 단추로 클릭 하 고 새 항목 추가를 선택 합니다.
8. 파일 목록에서 스타일 시트를 선택 하 고 추가를 클릭 합니다. 이제 새 테마를 구현 하는 데 필요한 모든 파일이 있습니다. 그러나 Visual Studio의 이름은 테마 폴더 SkinFile입니다. 해당 폴더를 마우스 오른쪽 단추로 클릭 하 고 이름을 CoolTheme로 변경 합니다.
9. SkinFile 파일을 열고 다음 코드를 파일의 끝에 추가 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. SkinFile 파일을 저장 합니다.
11. 스타일 시트 .css를 엽니다.
12. 여기에 있는 모든 텍스트를 다음으로 바꿉니다. 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. 스타일 시트 .css 파일을 저장 합니다.
14. Default.aspx 페이지를 엽니다.
15. TextBox 컨트롤과 Button 컨트롤을 추가 합니다.
16. 페이지를 저장합니다. 이제 Default.aspx 페이지를 탐색 합니다. 일반 웹 양식으로 표시 되어야 합니다.
17. Web.config 파일을 엽니다.
18. 여는 `<system.web>` 태그 바로 아래에 다음을 추가 합니다. 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Web.config 파일을 저장 합니다. 이제 Default.aspx 페이지를 탐색 합니다. 테마가 적용 된 상태로 표시 되어야 합니다.
20. 아직 열려 있지 않은 경우 Visual Studio에서 default.aspx 페이지를 엽니다.
21. 단추를 선택 합니다.
22. **SkinID** 속성을 goButton로 변경 합니다. Visual Studio는 단추 컨트롤에 대해 유효한 SkinID 값이 포함 된 드롭다운을 제공 합니다.
23. 페이지를 저장합니다. 이제 브라우저에서 페이지를 다시 미리 봅니다. 단추에 "go"가 표시 되 고 모양이 더 커야 합니다.

**SkinID** 속성을 사용 하면 특정 유형의 서버 컨트롤에 대 한 다른 인스턴스에 대해 다른 스킨을 쉽게 구성할 수 있습니다.

## <a name="the-stylesheettheme-property"></a>StyleSheetTheme 속성

지금 까지는 테마 속성을 사용 하 여 테마를 적용 하는 것에 대해서만 이야기 했습니다. 테마 속성을 사용 하는 경우 스킨 파일은 서버 컨트롤에 대 한 모든 선언적 설정을 재정의 합니다. 예를 들어, 연습 1에서는 단추 컨트롤에 대해 SkinID를 "goButton"로 지정 하 고 단추의 텍스트를 "go"로 변경 했습니다. 디자이너에서 단추의 Text 속성이 "Button"으로 설정 되어 있지만 테마는이를 초과 했습니다. 테마는 항상 디자이너의 모든 속성 설정을 재정의 합니다.

디자이너에 지정 된 속성을 사용 하 여 테마의 스킨 파일에 정의 된 속성을 재정의할 수 있도록 하려면 테마 속성 대신 **StyleSheetTheme** 속성을 사용할 수 있습니다. StyleSheetTheme 속성은 테마 속성과 같은 모든 명시적 속성 설정을 재정의 하지 않는다는 점을 제외 하 고는 테마 속성과 동일 합니다.

이 작업을 수행 하려면 연습 1의 프로젝트에서 web.config 파일을 열고 `<pages>` 요소를 다음과 같이 변경 합니다.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

이제 Default.aspx 페이지를 탐색 하면 단추 컨트롤의 텍스트 속성은 "Button"으로 다시 표시 됩니다. 이는 디자이너의 명시적 속성 설정이 goButton SkinID로 설정 된 텍스트 속성을 재정의 하기 때문입니다.

## <a name="overriding-themes"></a>테마 재정의

응용 프로그램의 앱\_테마 폴더에서 동일한 이름으로 테마를 적용 하 여 전역 테마를 재정의할 수 있습니다. 그러나 테마는 진정한 재정의 시나리오에서 적용 되지 않습니다. 런타임이 앱\_테마 폴더의 테마 파일을 발견 하면 해당 파일을 사용 하 여 테마가 적용 되 고 전역 테마는 무시 됩니다.

StyleSheetTheme 속성은 재정의 가능 하며 다음과 같이 코드에서 재정의할 수 있습니다.

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>웹 파트

ASP.NET 웹 파트는 최종 사용자가 브라우저에서 직접 웹 페이지의 콘텐츠, 모양 및 동작을 수정할 수 있도록 하는 웹 사이트를 만들기 위한 통합 컨트롤 집합입니다. 수정 사항은 사이트의 모든 사용자 또는 개별 사용자에 게 적용 될 수 있습니다. 사용자가 페이지 및 컨트롤을 수정 하는 경우 설정을 저장 하 여 향후 브라우저 세션에서 개인 설정 이라는 기능을 유지할 수 있습니다. 이러한 웹 파트 기능은 개발자 또는 관리자의 개입 없이 최종 사용자가 웹 응용 프로그램을 동적으로 개인 설정할 수 있도록 하는 것을 의미 합니다.

개발자는 웹 파트 컨트롤 집합을 사용 하 여 최종 사용자가 다음을 수행할 수 있습니다.

- 페이지 콘텐츠를 개인 설정 합니다. 사용자는 페이지에 새 웹 파트 컨트롤을 추가 하거나, 제거 하거나, 숨기 거 나, 일반 창과 같은 컨트롤을 최소화할 수 있습니다.
- 페이지 레이아웃을 개인 설정 합니다. 사용자는 페이지의 다른 영역으로 웹 파트 컨트롤을 끌거나 모양, 속성 및 동작을 변경할 수 있습니다.
- 컨트롤 내보내기 및 가져오기 사용자는 다른 페이지 또는 사이트에서 사용할 수 있도록 웹 파트 제어 설정을 가져오거나 내보내 컨트롤의 속성, 모양 및 데이터도 유지할 수 있습니다. 이렇게 하면 최종 사용자에 대 한 데이터 입력 및 구성 요구가 줄어듭니다.
- 연결을 만듭니다. 예를 들어 사용자가 컨트롤 간의 연결을 설정 하 여 차트 컨트롤에서 주식 시세 컨트롤의 데이터에 대 한 그래프를 표시할 수 있습니다. 사용자는 연결 자체 뿐만 아니라 차트 컨트롤에서 데이터를 표시 하는 방법에 대 한 모양과 세부 정보를 개인 설정할 수 있습니다.
- 사이트 수준 설정을 관리 하 고 개인 설정 합니다. 권한 있는 사용자는 사이트 수준 설정을 구성 하 고, 사이트 또는 페이지에 액세스할 수 있는 사용자를 결정 하 고, 컨트롤에 대 한 역할 기반 액세스를 설정할 수 있습니다. 예를 들어 관리 역할의 사용자는 모든 사용자가 공유 하는 웹 파트 컨트롤을 설정 하 고 관리자가 아닌 사용자가 공유 컨트롤을 개인 설정 하지 못하게 할 수 있습니다.

일반적으로 웹 파트 컨트롤을 사용 하는 페이지 만들기, 개별 웹 파트 컨트롤 만들기 또는 포털 등의 개인 설정할 수 있는 완전 한 웹 응용 프로그램 만들기의 세 가지 방법 중 하나를 사용 하 여 웹 파트 작업을 수행 합니다.

## <a name="page-development"></a>페이지 개발

페이지 개발자는 Microsoft Visual Studio 2005 등의 시각적 디자인 도구를 사용 하 여 웹 파트를 사용 하는 페이지를 만들 수 있습니다. Visual Studio와 같은 도구를 사용 하는 경우의 이점 중 하나는 웹 파트 컨트롤 집합이 비주얼 디자이너에서 웹 파트 컨트롤의 끌어서 놓기 기능을 제공 하는 기능을 제공 한다는 것입니다. 예를 들어 디자이너를 사용 하 여 웹 파트 영역 또는 웹 파트 편집기 컨트롤을 디자인 화면으로 끌어 온 다음 웹 파트 컨트롤 집합에서 제공 하는 UI를 사용 하 여 디자이너에서 컨트롤을 바로 구성할 수 있습니다. 이렇게 하면 웹 파트 응용 프로그램의 개발 속도를 높이고 작성 해야 하는 코드의 양을 줄일 수 있습니다.

## <a name="control-development"></a>컨트롤 개발

표준 웹 서버 컨트롤, 사용자 지정 서버 컨트롤 및 사용자 정의 컨트롤을 포함 하 여 기존 ASP.NET 컨트롤을 웹 파트 컨트롤로 사용할 수 있습니다. 사용자 환경에 대 한 최대 프로그래밍 제어를 위해 WebPart 클래스에서 파생 되는 사용자 지정 웹 파트 컨트롤을 만들 수도 있습니다. 개별 웹 파트 컨트롤을 개발 하는 경우 일반적으로 사용자 정의 컨트롤을 만들어 웹 파트 컨트롤로 사용 하거나 사용자 지정 웹 파트 컨트롤을 개발 합니다.

사용자 지정 웹 파트 컨트롤을 개발 하는 예로, 개인 설정할 수 있는 웹 파트 컨트롤로 패키지 하는 데 유용 하 게 사용할 수 있는 다른 ASP.NET 서버 컨트롤에서 제공 하는 기능을 제공 하는 컨트롤을 만들 수 있습니다. 일정, 목록, 재무 정보, 뉴스, 계산기, 콘텐츠 업데이트를 위한 서식 있는 텍스트 컨트롤, 데이터베이스에 연결 되는 편집 가능한 표, 표시를 동적으로 업데이트 하는 차트 또는 날씨와 여행 정보를 사용할 수 있습니다. 비주얼 디자이너에 컨트롤을 제공 하는 경우 Visual Studio를 사용 하는 모든 페이지 개발자는 단순히 컨트롤을 웹 파트 영역으로 끌어서 추가 코드를 작성 하지 않고도 디자인 타임에 구성할 수 있습니다.

개인 설정은 웹 파트 기능의 기초가 됩니다. 이를 통해 사용자는 페이지에 있는 웹 파트 컨트롤의 레이아웃, 모양 및 동작을 수정 하거나 사용자 지정할 수 있습니다. 개인 설정 된 설정은 수명이 깁니다 .이 설정은 현재 브라우저 세션 (보기 상태) 뿐만 아니라 장기 저장소 에서도 유지 되므로 이후 브라우저 세션에 대해서도 사용자 설정이 저장 됩니다. 개인 설정은 웹 파트 페이지에서 기본적으로 사용 하도록 설정 됩니다.

UI 구조적 구성 요소는 개인 설정을 사용 하 고 모든 웹 파트 컨트롤에 필요한 핵심 구조와 서비스를 제공 합니다. 모든 웹 파트 페이지에 필요한 하나의 UI 구조 구성 요소가 WebPartManager 컨트롤입니다. 이 컨트롤은 표시 되지 않지만 페이지의 모든 웹 파트 컨트롤을 조정 하는 중요 한 작업을 포함 합니다. 예를 들어 모든 개별 웹 파트 컨트롤을 추적 합니다. 웹 파트 영역 (페이지의 웹 파트 컨트롤을 포함 하는 영역) 및 어떤 컨트롤이 영역에 있는지를 관리 합니다. 또한 찾아보기, 연결, 편집 또는 카탈로그 모드와 같이 페이지가 있을 수 있는 다양 한 디스플레이 모드와 개인 설정 변경 내용이 모든 사용자 또는 개별 사용자에 게 적용 되는지 여부를 추적 하 고 제어 합니다. 마지막으로 웹 파트 컨트롤 간의 연결 및 통신을 시작 하 고 추적 합니다.

두 번째 종류의 UI 구조 구성 요소는 영역입니다. 영역은 웹 파트 페이지에서 레이아웃 관리자 역할을 합니다. 이러한 컨트롤은 파트 클래스 (파트 컨트롤)에서 파생 되는 컨트롤을 포함 하 고 구성 하며, 가로 또는 세로 방향으로 모듈식 페이지 레이아웃을 수행 하는 기능을 제공 합니다. 영역은 포함 하는 각 컨트롤에 대해 공통적이 고 일관 된 UI 요소 (예: 머리글, 바닥글 스타일, 제목, 테두리 스타일, 작업 단추 등)도 제공 합니다. 이러한 공통 요소를 컨트롤의 크롬 이라고 합니다. 여러 가지 특수 영역 형식이 다양 한 디스플레이 모드와 다양 한 컨트롤에서 사용 됩니다. 각 영역 유형에 대 한 자세한 내용은 아래 웹 파트 필수 컨트롤 섹션을 참조 하십시오.

**파트** 클래스에서 파생 되는 웹 파트 UI 컨트롤은 웹 파트 페이지의 기본 ui를 구성 합니다. 웹 파트 컨트롤 집합은 파트 컨트롤을 만들기 위해 제공 하는 옵션을 유연 하 고 포함 합니다. 사용자 지정 웹 파트 컨트롤을 만드는 것 외에도 기존 ASP.NET 서버 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 컨트롤을 웹 파트 컨트롤로 사용할 수 있습니다. 웹 파트 페이지를 만드는 데 가장 일반적으로 사용 되는 필수 컨트롤은 다음 섹션에 설명 되어 있습니다.

## <a name="web-parts-essential-controls"></a>필수 컨트롤 웹 파트

웹 파트 컨트롤 집합은 광범위 하지만 일부 컨트롤은 웹 파트 작동 하는 데 필요 하거나 웹 파트 페이지에서 가장 자주 사용 되는 컨트롤 이기 때문에 필수적입니다. 웹 파트 사용을 시작 하 고 기본 웹 파트 페이지를 만들 때 다음 표에 설명 된 필수 웹 파트 컨트롤에 대해 잘 알고 있으면 유용 합니다.

| **웹 파트 컨트롤** | **설명** |
| --- | --- |
| WebPartManager | 페이지의 모든 웹 파트 컨트롤을 관리 합니다. 모든 웹 파트 페이지에는 하나의 **WebPartManager** 컨트롤이 필요 합니다. |
| CatalogZone | CatalogPart 컨트롤을 포함 합니다. 이 영역을 사용 하 여 사용자가 페이지에 추가할 컨트롤을 선택할 수 있는 웹 파트 컨트롤의 카탈로그를 만들 수 있습니다. |
| EditorZone | EditorPart 컨트롤을 포함 합니다. 사용자가 페이지에서 웹 파트 컨트롤을 편집 하 고 개인 설정할 수 있도록 하려면이 영역을 사용 합니다. |
| WebPartZone | 페이지의 주 UI를 구성 하는 WebPart 컨트롤의 전체 레이아웃을 포함 하 고 제공 합니다. 웹 파트 컨트롤을 사용 하 여 페이지를 만들 때마다이 영역을 사용 합니다. 페이지는 하나 이상의 영역을 포함할 수 있습니다. |
| ConnectionsZone | 연결은 system.web.ui.webcontrols.webparts.webpartconnection 컨트롤을 포함 하 고 연결을 관리 하기 위한 UI를 제공 합니다. |
| WebPart (GenericWebPart) | 기본 UI를 렌더링 합니다. 대부분의 웹 파트 UI 컨트롤은이 범주에 속합니다. 프로그래밍 방식의 최대 제어를 위해 기본 **WebPart** 컨트롤에서 파생 되는 사용자 지정 웹 파트 컨트롤을 만들 수 있습니다. 기존 서버 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 컨트롤을 웹 파트 컨트롤로 사용할 수도 있습니다. 이러한 컨트롤이 영역에 배치 될 때마다 **WebPartManager** 컨트롤이 런타임에 **GenericWebPart** 컨트롤을 사용 하 여 자동으로 래핑하여 웹 파트 기능과 함께 사용할 수 있습니다. |
| CatalogPart | 사용자가 페이지에 추가할 수 있는 사용 가능한 웹 파트 컨트롤의 목록을 포함 합니다. |
| WebPartConnection | 페이지의 두 웹 파트 컨트롤 사이에 연결을 만듭니다. 연결은 웹 파트 컨트롤 중 하나를 공급자 (데이터)로 정의 하 고 다른 하나를 소비자로 정의 합니다. |
| EditorPart | 특수화 된 편집기 컨트롤의 기본 클래스로 사용 됩니다. |
| EditorPart 컨트롤 (AppearanceEditorPart, LayoutEditorPart, BehaviorEditorPart 및 PropertyGridEditorPart) | 사용자가 페이지에서 웹 파트 UI 컨트롤의 다양 한 측면을 개인 설정할 수 있도록 허용 |

## <a name="lab-create-a-web-part-page"></a>랩: 웹 파트 페이지 만들기

이 랩에서는 ASP.NET 프로필을 통해 정보를 유지 하는 웹 파트 페이지를 만듭니다.

### <a name="creating-a-simple-page-with-web-parts"></a>웹 파트를 사용 하 여 간단한 페이지 만들기

이 연습 부분에서는 웹 파트 컨트롤을 사용 하 여 정적 콘텐츠를 표시 하는 페이지를 만듭니다. 웹 파트를 사용 하는 첫 번째 단계는 두 개의 필수 구조 요소가 포함 된 페이지를 만드는 것입니다. 첫째, 웹 파트 페이지에는 모든 웹 파트 컨트롤을 추적 하 고 조정 하는 WebPartManager 컨트롤이 필요 합니다. 둘째, 웹 파트 페이지에는 WebPart 또는 다른 서버 컨트롤을 포함 하 고 페이지의 지정 된 영역을 차지 하는 복합 컨트롤인 하나 이상의 영역이 필요 합니다.

> [!NOTE]
> 웹 파트 개인 설정을 사용 하도록 설정 하는 것은 필요 하지 않습니다. 웹 파트 컨트롤 집합에 대해 기본적으로 사용 하도록 설정 되어 있습니다. 사이트에서 웹 파트 페이지를 처음으로 실행 하는 경우 ASP.NET는 사용자 개인 설정 설정을 저장할 기본 개인 설정 공급자를 설정 합니다. 개인 설정에 대 한 자세한 내용은 웹 파트 개인 설정 개요를 참조 하세요.

### <a name="to-create-a-page-for-containing-web-parts-controls"></a>웹 파트 컨트롤을 포함 하는 페이지를 만들려면

1. 기본 페이지를 닫고 WebPartsDemo 라는 사이트에 새 페이지를 추가 합니다.
2. **디자인** 뷰로 전환 합니다.
3. **보기** 메뉴에서 **비시각적 컨트롤** 및 **세부 정보** 옵션이 선택 되었는지 확인 하 여 UI가 없는 레이아웃 태그와 컨트롤을 볼 수 있습니다.
4. 디자인 화면의 `<div>` 태그 앞에 삽입 지점을 놓고 ENTER 키를 눌러 새 줄을 추가 합니다. 줄 바꿈 문자 앞에 삽입 지점을 놓고 메뉴의 **블록 형식** 드롭다운 목록 컨트롤을 클릭 한 다음 **제목 1** 옵션을 선택 합니다. 제목에서 텍스트 **웹 파트 데모 페이지**를 추가 합니다.
5. 도구 상자의 **웹 파트** 탭에서 **WebPartManager** 컨트롤을 페이지로 끌어 줄 바꿈 문자 바로 뒤와 `<div>`태그 앞에 배치 합니다.   
  
   **WebPartManager** 컨트롤은 출력을 렌더링 하지 않으므로 디자이너 화면에 회색 상자로 표시 됩니다.
6. `<div>` 태그 안에 삽입 지점을 배치 합니다.
7. **레이아웃** 메뉴에서 **테이블 삽입**을 클릭 하 고 한 행과 세 개의 열이 있는 새 테이블을 만듭니다. **셀 속성** 단추를 클릭 하 고 **세로 맞춤** 드롭다운 목록에서 **위쪽** 을 선택 하 고 **확인**을 클릭 한 다음 **확인** 을 다시 클릭 하 여 테이블을 만듭니다.
8. WebPartZone 컨트롤을 왼쪽 테이블 열로 끌어 옵니다. **WebPartZone** 컨트롤을 마우스 오른쪽 단추로 클릭 하 고 **속성**을 선택한 후 다음 속성을 설정 합니다.   
  
   ID: 바 영역 영역   
  
   HeaderText: 사이드바
9. 두 번째 **WebPartZone** 컨트롤을 가운데 테이블 열로 끌고 다음 속성을 설정 합니다.   
  
   ID: MainZone   
  
   HeaderText: Main
10. 파일을 저장합니다.

이제 페이지에는 개별적으로 제어할 수 있는 두 개의 고유한 영역이 있습니다. 그러나 어느 영역에도 콘텐츠가 없으므로 다음 단계로 콘텐츠를 만들 수 있습니다. 이 연습에서는 정적 콘텐츠만 표시 하는 웹 파트 컨트롤을 사용 합니다.

웹 파트 영역의 레이아웃은 &lt;zonetemplate&gt; 요소에 의해 지정 됩니다. 사용자 지정 웹 파트 컨트롤, 사용자 정의 컨트롤 또는 기존 서버 컨트롤 인지 여부에 관계 없이 영역 템플릿 내에서 ASP.NET 컨트롤을 추가할 수 있습니다. 여기에서 Label 컨트롤을 사용 하 고 있고 정적 텍스트를 추가 하는 것을 확인할 수 있습니다. **WebPartZone** 영역에 일반 서버 컨트롤을 넣으면 ASP.NET는 컨트롤을 런타임에 웹 파트 컨트롤로 처리 합니다. 그러면 컨트롤에서 웹 파트 기능을 사용할 수 있습니다.

**주 영역에 대 한 콘텐츠를 만들려면**

1. **디자인** 뷰에서 도구 상자의 **표준** 탭에 있는 **레이블** 컨트롤을 **ID** 속성이 mainzone으로 설정 된 영역의 내용 영역으로 끕니다.
2. **원본** 뷰로 전환 합니다. &lt;zonetemplate&gt; 요소를 추가 하 여 MainZone에서 **Label** 컨트롤을 래핑합니다.
3. **Title** 이라는 특성을 &lt;asp: label&gt; 요소에 추가 하 고 해당 값을 Content로 설정 합니다. &lt;asp: label&gt; 요소에서 Text = "Label" 특성을 제거 합니다. &lt;asp: label&gt; 요소에 대 한 여는 태그와 닫는 태그 사이에 &lt;h2&gt; 요소 태그 쌍 내에서 **홈 페이지를 시작 하** 는 등의 일부 텍스트를 추가 합니다. 코드는 다음과 같습니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. 파일을 저장합니다.

다음으로 웹 파트 컨트롤로 페이지에 추가할 수 있는 사용자 정의 컨트롤을 만듭니다.

### <a name="to-create-a-user-control"></a>사용자 정의 컨트롤을 만들려면

1. 검색 컨트롤로 사용할 새 웹 사용자 정의 컨트롤을 사이트에 추가 합니다. **소스 코드를 별도의 파일에 저장**하는 옵션을 선택 취소 합니다. 이를 WebPartsDemo .aspx 페이지와 동일한 디렉터리에 추가 하 고 이름을 SearchUserControl .ascx로 추가 합니다.   
  
    > [!NOTE]
    > 이 연습에 대 한 사용자 정의 컨트롤은 실제 검색 기능을 구현 하지 않습니다. 웹 파트 기능을 설명 하는 데만 사용 됩니다.
2. **디자인** 뷰로 전환 합니다. 도구 상자의 **표준** 탭에서 TextBox 컨트롤을 페이지로 끌어 옵니다.
3. 방금 추가한 텍스트 상자 뒤에 삽입 지점을 놓고 ENTER 키를 눌러 새 줄을 추가 합니다.
4. 단추 컨트롤을 방금 추가한 텍스트 상자 아래의 새 줄에 있는 페이지로 끌어옵니다.
5. **원본** 뷰로 전환 합니다. 사용자 정의 컨트롤의 소스 코드는 다음 예제와 유사 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. 파일을 저장하고 닫습니다.

이제 사이드바 영역에 웹 파트 컨트롤을 추가할 수 있습니다. 사이드바 영역에 두 개의 컨트롤을 추가 합니다. 하나는 링크 목록을 포함 하 고 다른 하나는 이전 절차에서 만든 사용자 정의 컨트롤입니다. 링크는 기본 영역에 대 한 정적 텍스트를 생성 하는 방식과 비슷하게 표준 **레이블** 서버 컨트롤로 추가 됩니다. 그러나 사용자 정의 컨트롤에 포함 된 개별 서버 컨트롤은 label 컨트롤과 같이 영역에 직접 포함 될 수 있지만이 경우에는 그렇지 않습니다. 대신, 이전 절차에서 만든 사용자 정의 컨트롤의 일부입니다. 사용자 정의 컨트롤에서 원하는 컨트롤과 추가 기능을 패키지 한 다음 영역에서 해당 컨트롤을 웹 파트 컨트롤로 참조 하는 일반적인 방법을 보여 줍니다.

런타임에 웹 파트 컨트롤 집합은 GenericWebPart 컨트롤을 사용 하 여 두 컨트롤을 래핑합니다. **GenericWebPart** 컨트롤이 웹 서버 컨트롤을 래핑하는 경우 제네릭 파트 컨트롤이 부모 컨트롤이 고 부모 컨트롤의 childcontrol 속성을 통해 서버 컨트롤에 액세스할 수 있습니다. 이러한 제네릭 파트 컨트롤 사용을 통해 표준 웹 서버 컨트롤은 **WebPart** 클래스에서 파생 되는 웹 파트 컨트롤과 동일한 기본 동작 및 특성을 사용할 수 있습니다.

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>세로 막대 영역에 웹 파트 컨트롤을 추가 하려면

1. WebPartsDemo .aspx 페이지를 엽니다.
2. **디자인** 뷰로 전환 합니다.
3. 만든 사용자 정의 컨트롤 페이지를 **솔루션 탐색기** 에서 **ID** 속성이 영역 영역으로 설정 된 영역으로 끌어서 해당 위치로 끌어 놓습니다.
4. WebPartsDemo .aspx 페이지를 저장 합니다.
5. **원본** 뷰로 전환 합니다.
6. 사용자 정의 컨트롤에 대 한 참조 바로 위에 있는 &lt;asp: webpartzone&gt; 요소 내에 다음 예제와 같이 포함 된 링크를 사용 하 여 &lt;asp: label&gt; 요소를 추가 합니다. 또한 다음과 같이 **검색**값으로 **Title** 특성을 사용자 컨트롤 태그에 추가 합니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. 파일을 저장하고 닫습니다.

이제 브라우저에서 페이지를 탐색 하 여 테스트할 수 있습니다. 이 페이지에는 두 개의 영역이 표시 됩니다. 다음 스크린샷은 페이지를 보여 줍니다.

**두 영역이 있는 웹 파트 데모 페이지**

![웹 파트 VS 연습 1 스크린샷](profiles-themes-and-web-parts/_static/image3.gif)

**그림 3**: 웹 파트 VS 연습 1 스크린샷

각 컨트롤의 제목 표시줄에는 컨트롤에 대해 수행할 수 있는 사용 가능한 작업의 동사 메뉴에 대 한 액세스를 제공 하는 하향 화살표가 있습니다. 컨트롤 중 하나에 대 한 동사 메뉴를 클릭 한 다음 **최소화** 동사를 클릭 하면 컨트롤이 최소화 됩니다. 동사 메뉴에서 **복원**을 클릭 하면 컨트롤이 보통 크기로 돌아옵니다.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>사용자가 페이지를 편집 하 고 레이아웃을 변경할 수 있도록 설정

웹 파트은 사용자가 한 영역에서 다른 영역으로 끌어 웹 파트 컨트롤의 레이아웃을 변경할 수 있는 기능을 제공 합니다. 사용자가 **WebPart** 컨트롤을 한 영역에서 다른 영역으로 이동할 수 있도록 하는 것 외에도 사용자가 컨트롤의 모양, 레이아웃 및 동작을 포함 하 여 컨트롤의 다양 한 특성을 편집할 수 있습니다. 웹 파트 컨트롤 집합은 **WebPart** 컨트롤에 대 한 기본 편집 기능을 제공 합니다. 이 연습에서는이 작업을 수행 하지 않지만 사용자가 **WebPart** 컨트롤의 기능을 편집 하는 데 사용할 수 있는 사용자 지정 편집기 컨트롤을 만들 수도 있습니다. **WebPart** 컨트롤의 위치를 변경 하는 것과 마찬가지로, 컨트롤의 속성을 편집 하면 ASP.NET 개인 설정을 사용 하 여 사용자가 변경한 내용을 저장 합니다.

이 연습 부분에서는 사용자가 페이지에서 **WebPart** 컨트롤의 기본 특성을 편집 하는 기능을 추가 합니다. 이러한 기능을 사용 하려면 &lt;asp: editorzone&gt; 요소와 두 개의 편집 컨트롤과 함께 다른 사용자 지정 사용자 정의 컨트롤을 페이지에 추가 합니다.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>페이지 레이아웃을 변경할 수 있는 사용자 정의 컨트롤을 만들려면

1. Visual Studio의 **파일** 메뉴에서 **새** 하위 메뉴를 선택 하 고 **파일** 옵션을 클릭 합니다.
2. **새 항목 추가** 대화 상자에서 **웹 사용자 정의 컨트롤**을 선택 합니다. 새 파일의 이름을 DisplayModeMenu. .ascx로 합니다. **소스 코드를 별도의 파일에 저장**하는 옵션을 선택 취소 합니다.
3. 추가를 클릭 하 여 새 컨트롤을 만듭니다.
4. **원본** 뷰로 전환 합니다.
5. 새 파일의 기존 코드를 모두 제거 하 고 다음 코드를 붙여 넣습니다. 이 사용자 정의 컨트롤 코드는 페이지에서 보기 또는 표시 모드를 변경할 수 있도록 하는 웹 파트 컨트롤 집합의 기능을 사용 하며, 특정 표시 모드에 있는 동안 페이지의 실제 모양과 레이아웃을 변경할 수도 있습니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. 도구 모음에서 저장 아이콘을 클릭 하거나 **파일** 메뉴에서 **저장** 을 선택 하 여 파일을 저장 합니다.

### <a name="to-enable-users-to-change-the-layout"></a>사용자가 레이아웃을 변경할 수 있도록 하려면

1. WebPartsDemo .aspx 페이지를 열고 **디자인** 뷰로 전환 합니다.
2. **디자인** 뷰에서 이전에 추가한 **WebPartManager** 컨트롤 바로 뒤에 삽입 지점을 배치 합니다. **WebPartManager** 컨트롤 뒤에 빈 줄이 있도록 텍스트 뒤에 하드 반환을 추가 합니다. 빈 줄에 삽입 포인터를 놓습니다.
3. 방금 만든 사용자 정의 컨트롤 (파일 이름이 DisplayModeMenu. .ascx)을 WebPartsDemo 페이지로 끌어 빈 줄에 놓습니다.
4. 도구 상자의 **웹 파트** 섹션에서 EditorZone 컨트롤을 WebPartsDemo 페이지의 나머지 열린 테이블 셀로 끕니다.
5. 도구 상자의 **webpart** 섹션에서 AppearanceEditorPart 컨트롤과 LayoutEditorPart 컨트롤을 **EditorZone** 컨트롤로 끌어 옵니다.
6. **원본** 뷰로 전환 합니다. 표 셀의 결과 코드는 다음 코드와 유사 하 게 표시 됩니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. WebPartsDemo .aspx 파일을 저장 합니다. 표시 모드를 변경 하 고 페이지 레이아웃을 변경할 수 있는 사용자 정의 컨트롤을 만들었으며 기본 웹 페이지에서 컨트롤을 참조 했습니다.

이제 페이지를 편집 하 고 레이아웃을 변경 하는 기능을 테스트할 수 있습니다.

### <a name="to-test-layout-changes"></a>레이아웃 변경 내용을 테스트 하려면

1. 브라우저에서 페이지를 로드 합니다.
2. **디스플레이 모드** 드롭다운 메뉴를 클릭 하 고 **편집**을 선택 합니다. 영역 제목이 표시 됩니다.
3. 세로 막대의 제목 표시줄에서 주 영역 아래쪽으로 **내 링크** 컨트롤을 끌어 옵니다. 페이지는 다음 스크린샷 처럼 표시 됩니다.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>내 링크 컨트롤을 이동한 웹 파트 데모 페이지

![웹 파트 VS 연습 2 스크린샷](profiles-themes-and-web-parts/_static/image4.gif)

**그림 4**: 웹 파트 VS 연습 2 스크린샷

1. **디스플레이 모드** 드롭다운 메뉴를 클릭 하 고 **찾아보기**를 선택 합니다. 페이지가 새로 고쳐지고 영역 이름이 사라지고 **내 링크** 컨트롤의 위치는 그대로 유지 됩니다.
2. 개인 설정이 작동 하 고 있음을 설명 하려면 브라우저를 닫은 다음 페이지를 다시 로드 합니다. 이후 브라우저 세션에 대해 변경한 내용이 저장 됩니다.
3. **디스플레이 모드** 메뉴에서 **편집**을 선택 합니다.   
  
   이제 페이지의 각 컨트롤이 제목 표시줄에 아래쪽 화살표가 표시 되 고 동사 드롭다운 메뉴가 포함 됩니다.
4. 화살표를 클릭 하 여 **내 링크** 컨트롤에 동사 메뉴를 표시 합니다. 동사 **편집** 을 클릭 합니다.   
  
   추가한 EditorPart 컨트롤을 표시 하는 **EditorZone** 컨트롤이 나타납니다.
5. 편집 컨트롤의 **모양** 섹션에서 **제목을** 내 즐겨찾기로 변경 하 고 **Chrome 유형** 드롭다운 목록을 사용 하 여 **제목만**선택한 다음 **적용**을 클릭 합니다. 다음 스크린샷은 편집 모드의 페이지를 보여 줍니다.

### <a name="web-parts-demo-page-in-edit-mode"></a>편집 모드의 웹 파트 데모 페이지

![웹 파트 VS 연습 3 스크린샷](profiles-themes-and-web-parts/_static/image5.gif)

**그림 5**: 웹 파트 VS 연습 3 스크린샷

1. **표시 모드** 메뉴를 클릭 하 고 **찾아보기** 를 선택 하 여 찾아보기 모드로 돌아갑니다.
2. 이제 다음 스크린샷에 표시 된 것 처럼 컨트롤에 업데이트 된 제목 및 테두리가 없습니다.

### <a name="edited-web-parts-demo-page"></a>편집 웹 파트 데모 페이지

![웹 파트 VS 연습 4 스크린샷](profiles-themes-and-web-parts/_static/image6.gif)

**그림 4**: 웹 파트 VS 연습 4 스크린샷

### <a name="adding-web-parts-at-run-time"></a>런타임에 웹 파트 추가

사용자가 런타임에 페이지에 웹 파트 컨트롤을 추가 하도록 허용할 수도 있습니다. 이렇게 하려면 사용자가 사용할 수 있도록 설정할 웹 파트 컨트롤 목록을 포함 하는 웹 파트 카탈로그를 사용 하 여 페이지를 구성 합니다.

**런타임에 사용자가 웹 파트를 추가할 수 있도록 하려면**

1. WebPartsDemo .aspx 페이지를 열고 **디자인** 뷰로 전환 합니다.
2. 도구 상자의 **웹 파트** 탭에서 CatalogZone 컨트롤을 **EditorZone** 컨트롤 아래의 테이블 오른쪽 열로 끕니다.   
  
   두 컨트롤은 동시에 표시 되지 않기 때문에 동일한 테이블 셀에 있을 수 있습니다.
3. 속성 창에서 **CatalogZone** 컨트롤의 HeaderText 속성에 **Add 웹 파트** 문자열을 할당 합니다.
4. 도구 상자의 **webpart** 섹션에서 DeclarativeCatalogPart 컨트롤을 **CatalogZone** 컨트롤의 콘텐츠 영역으로 끌어 옵니다.
5. **DeclarativeCatalogPart** 컨트롤의 오른쪽 위 모퉁이에 있는 화살표를 클릭 하 여 해당 작업 메뉴를 표시 한 다음 **템플릿 편집**을 선택 합니다.
6. 도구 상자의 **표준** 섹션에서 **FileUpload** 컨트롤 및 **Calendar** 컨트롤을 **DeclarativeCatalogPart** 컨트롤의 **WebPartsTemplate** 섹션으로 끌어 옵니다.
7. **원본** 뷰로 전환 합니다. &lt;asp: catalogzone&gt; 요소의 소스 코드를 검사 합니다. **DeclarativeCatalogPart** 컨트롤에는 카탈로그에서 페이지에 추가할 수 있는 두 개의 포함 된 서버 컨트롤을 포함 하는 &lt;webpartstemplate&gt; 요소가 포함 됩니다.
8. 아래 코드 예제의 각 제목에 대해 표시 된 문자열 값을 사용 하 여 카탈로그에 추가한 각 컨트롤에 **title** 속성을 추가 합니다. 제목이 속성이 아닌 경우에도, 사용자가 런타임에 카탈로그에서 **WebPartZone** 영역에 이러한 컨트롤을 추가할 때 이러한 컨트롤은 각각 **GenericWebPart** 컨트롤을 사용 하 여 래핑됩니다. 이렇게 하면 웹 파트 컨트롤로 작동할 수 있으므로 제목을 표시할 수 있습니다.   
  
   **DeclarativeCatalogPart** 컨트롤에 포함 된 두 컨트롤의 코드는 다음과 같습니다. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. 페이지를 저장합니다.

이제 카탈로그를 테스트할 수 있습니다.

### <a name="to-test-the-web-parts-catalog"></a>웹 파트 카탈로그를 테스트 하려면

1. 브라우저에서 페이지를 로드 합니다.
2. **디스플레이 모드** 드롭다운 메뉴를 클릭 하 고 **카탈로그**를 선택 합니다.   
  
   **웹 파트 추가** 라는 카탈로그가 표시 됩니다.
3. 주 영역에서 **내 즐겨찾기** 컨트롤을 사이드바 영역의 맨 위로 다시 끌고 여기에 놓습니다.
4. 웹 파트 카탈로그 **추가** 에서 두 확인란을 모두 선택한 다음 사용 가능한 영역을 포함 하는 드롭다운 목록에서 **주** 를 선택 합니다.
5. 카탈로그에서 **추가** 를 클릭 합니다. 컨트롤이 주 영역에 추가 됩니다. 원하는 경우 카탈로그의 여러 컨트롤 인스턴스를 페이지에 추가할 수 있습니다.   
  
   다음 스크린샷은 파일 업로드 컨트롤 및 주 영역의 달력이 있는 페이지를 보여 줍니다. 

![카탈로그에서 주 영역에 추가 된 컨트롤](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. **디스플레이 모드** 드롭다운 메뉴를 클릭 하 고 **찾아보기**를 선택 합니다. 카탈로그가 사라지고 페이지가 새로 고쳐집니다.
7. 브라우저를 닫습니다. 페이지를 다시 로드 합니다. 변경한 내용이 유지 됩니다.
