---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: 응용 프로그램 시작 시 데이터 캐싱C#() | Microsoft Docs
author: rick-anderson
description: 모든 웹 응용 프로그램에서 일부 데이터는 자주 사용 되 고 일부 데이터는 자주 사용 되지 않습니다. ASP.NET 응용 프로그램의 성능을 향상 시킬 수 있습니다.
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386511"
---
# <a name="caching-data-at-application-startup-c"></a><span data-ttu-id="b3c69-104">애플리케이션 시작 시 데이터 캐싱(C#)</span><span class="sxs-lookup"><span data-stu-id="b3c69-104">Caching Data at Application Startup (C#)</span></span>

<span data-ttu-id="b3c69-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="b3c69-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="b3c69-106">PDF 다운로드</span><span class="sxs-lookup"><span data-stu-id="b3c69-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="b3c69-107">모든 웹 응용 프로그램에서 일부 데이터는 자주 사용 되 고 일부 데이터는 자주 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="b3c69-108">자주 사용 하는 데이터 (캐싱 이라고 함)를 미리 로드 하 여 ASP.NET 응용 프로그램의 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as Caching.</span></span> <span data-ttu-id="b3c69-109">이 자습서에서는 응용 프로그램 시작 시 캐시로 데이터를 로드 하는 사전 로드의 한 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>

## <a name="introduction"></a><span data-ttu-id="b3c69-110">소개</span><span class="sxs-lookup"><span data-stu-id="b3c69-110">Introduction</span></span>

<span data-ttu-id="b3c69-111">위의 두 가지 자습서에서는 프레젠테이션 및 캐싱 계층에서 데이터를 캐시 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="b3c69-112">ObjectDataSource를 사용 하 여 [데이터를 캐시할](caching-data-with-the-objectdatasource-cs.md)때 objectdatasource의 캐싱 기능을 사용 하 여 프레젠테이션 계층의 데이터를 캐시 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource's caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="b3c69-113">[아키텍처의 데이터를 캐시](caching-data-in-the-architecture-cs.md) 하는 경우 별도의 새로운 캐싱 계층에서 캐싱이 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="b3c69-114">이러한 자습서는 모두 데이터 캐시 작업에서 *사후 로드* 를 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="b3c69-115">사후 로드를 사용 하면 데이터가 요청 될 때마다 시스템이 먼저 캐시에 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-115">With reactive loading, each time the data is requested, the system first checks if it's in the cache.</span></span> <span data-ttu-id="b3c69-116">그렇지 않으면 데이터베이스와 같은 원래 원본에서 데이터를 가져와 하 여 캐시에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="b3c69-117">사후 로드의 주요 이점은 구현의 용이성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="b3c69-118">이러한 단점 중 하나는 요청 간에 불균형 성능입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="b3c69-119">이전 자습서의 캐싱 계층을 사용 하 여 제품 정보를 표시 하는 페이지를 상상해 보세요.</span><span class="sxs-lookup"><span data-stu-id="b3c69-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="b3c69-120">이 페이지를 처음으로 방문 하거나 메모리 제약 조건으로 인해 캐시 된 데이터가 제거 된 후 처음으로 방문 하거나 지정 된 만료에 도달 하면 데이터베이스에서 데이터를 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="b3c69-121">따라서 이러한 사용자 요청은 캐시에서 처리할 수 있는 사용자 요청 보다 오래 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="b3c69-122">*자동 관리 로드* 는 캐시 된 데이터를 필요에 따라 로드 하 여 요청 간에 성능을 저하 하는 대체 캐시 관리 전략을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it's needed.</span></span> <span data-ttu-id="b3c69-123">일반적으로 자동 관리 로드에서는 기본 데이터에 대 한 업데이트가 있는 경우 주기적으로 확인 하거나 알림이 표시 되는 프로세스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="b3c69-124">그런 다음이 프로세스는 캐시를 업데이트 하 여 최신 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="b3c69-125">자동 관리 로드는 기본 데이터가 느린 데이터베이스 연결, 웹 서비스 또는 기타 기타 데이터 원본에서 제공 되는 경우에 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="b3c69-126">그러나 이러한 자동 관리 로드 방식은 변경을 확인 하 고 캐시를 업데이트 하는 프로세스를 만들고 관리 하 고 배포 해야 하므로 구현 하기가 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="b3c69-127">다른 사전 로드 버전 및이 자습서에서 살펴볼 형식은 응용 프로그램 시작 시 캐시로 데이터를 로드 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="b3c69-128">이 방법은 데이터베이스 조회 테이블의 레코드와 같은 정적 데이터를 캐시 하는 데 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="b3c69-129">자동 관리 및 사후 로드 간의 차이점 뿐만 아니라 전문가, 단점 및 구현 권장 사항의 목록을 자세히 살펴보기 위해 .NET 용 캐싱 아키텍처 가이드의 [캐시 콘텐츠 관리](https://msdn.microsoft.com/library/ms978503.aspx) 섹션을 참조 하세요. [ 프레임 워크 응용 프로그램](https://msdn.microsoft.com/library/ms978498.aspx).</span><span class="sxs-lookup"><span data-stu-id="b3c69-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="b3c69-130">1단계: 응용 프로그램 시작 시 캐시할 데이터 결정</span><span class="sxs-lookup"><span data-stu-id="b3c69-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="b3c69-131">이전 두 자습서에서 검사 한 사후 처리 로드를 사용 하는 캐싱 예제는 주기적으로 변경 될 수 있는 데이터와 함께 작동 하며 생성 하는 데 exorbitantly 긴 시간이 소요 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="b3c69-132">그러나 캐시 된 데이터가 변경 되지 않는 경우 사후 로드에서 사용 하는 만료는 불필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="b3c69-133">마찬가지로 캐시 되는 데이터를 생성 하는 데 지나치게 긴 시간이 소요 되는 경우, 해당 캐시를 검색 하는 요청은 기본 데이터를 검색 하는 동안 긴 대기 시간을 endure 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="b3c69-134">응용 프로그램 시작 시 생성 하는 데 매우 긴 시간이 소요 되는 정적 데이터 및 데이터를 캐싱하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="b3c69-135">데이터베이스에는 자주 변경 되는 동적 값이 많이 있지만, 대부분의 경우에는 상당한 양의 정적 데이터도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="b3c69-136">예를 들어 거의 모든 데이터 모델에는 고정 된 선택 항목 집합에서 특정 값을 포함 하는 열이 하나 이상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="b3c69-137">데이터베이스 `Patients` 테이블에는 값 집합 `PrimaryLanguage` 을 영어, 스페인어, 프랑스어, 러시아어, 일본어 등으로 지정할 수 있는 열이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="b3c69-138">이러한 유형의 열이 *조회 테이블*을 사용 하 여 구현 되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="b3c69-139">문자열 영어 또는 프랑스어를 `Patients` 테이블에 저장 하는 대신, 일반적으로 두 개의 열, 즉 고유 식별자와 문자열 설명을 포함 하는 두 번째 테이블이 생성 됩니다 .이 테이블에는 가능한 각 값에 대 한 레코드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="b3c69-140">테이블의 열은 `PrimaryLanguage` 해당 하는 고유 식별자를 조회 테이블에 저장 합니다. `Patients`</span><span class="sxs-lookup"><span data-stu-id="b3c69-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="b3c69-141">그림 1에서 환자 John Doe의 주 언어는 영어이 고 Ed Johnson의는 러시아어입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-141">In Figure 1, patient John Doe's primary language is English, while Ed Johnson's is Russian.</span></span>

![언어 테이블은 환자 테이블에서 사용 하는 조회 테이블입니다.](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="b3c69-143">**그림 1**: 테이블은 `Patients` 테이블에서 사용 하는 조회 테이블입니다. `Languages`</span><span class="sxs-lookup"><span data-stu-id="b3c69-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>

<span data-ttu-id="b3c69-144">새 환자를 편집 하거나 만들기 위한 사용자 인터페이스에는 `Languages` 테이블의 레코드에 의해 채워진 허용 가능한 언어의 드롭다운 목록이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="b3c69-145">캐싱을 사용 하지 않는 경우이 인터페이스를 방문할 때마다 시스템이 테이블을 `Languages` 쿼리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="b3c69-146">조회 테이블 값은 매우 드물게 변경 되므로 불필요 하 고 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="b3c69-147">이전 자습서에서 검사 `Languages` 한 것과 동일한 사후 로드 기법을 사용 하 여 데이터를 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="b3c69-148">그러나 사후 로드는 정적 조회 테이블 데이터에 필요 하지 않은 시간 기반 만료를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="b3c69-149">사후 로드를 사용 하는 캐싱은 캐싱을 전혀 사용 하지 않는 것이 좋지만 응용 프로그램 시작 시 조회 테이블 데이터를 캐시에 사전에 로드 하는 것이 가장 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="b3c69-150">이 자습서에서는 조회 테이블 데이터 및 기타 정적 정보를 캐시 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="b3c69-151">2단계: 데이터를 캐시 하는 다양 한 방법 검사</span><span class="sxs-lookup"><span data-stu-id="b3c69-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="b3c69-152">정보는 다양 한 방법을 사용 하 여 프로그래밍 방식으로 ASP.NET 응용 프로그램에 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="b3c69-153">이전 자습서에서 데이터 캐시를 사용 하는 방법을 이미 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="b3c69-154">또는 *정적 멤버나* *응용 프로그램 상태*를 사용 하 여 프로그래밍 방식으로 개체를 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="b3c69-155">클래스를 사용 하는 경우 일반적으로 해당 멤버에 액세스 하려면 먼저 클래스를 인스턴스화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="b3c69-156">예를 들어 비즈니스 논리 계층의 클래스 중 하나에서 메서드를 호출 하려면 먼저 클래스의 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="b3c69-157">*SomeMethod* 를 호출 하거나 *SomeProperty*를 사용 하 여 작업 하려면 먼저 키워드를 `new` 사용 하 여 클래스의 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="b3c69-158">*SomeMethod* 및 *SomeProperty* 는 특정 인스턴스와 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="b3c69-159">이러한 멤버의 수명은 연결 된 개체의 수명에 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="b3c69-160">반면에 *정적 멤버*는 클래스의 *모든* 인스턴스 간에 공유 되는 변수, 속성 및 메서드로, 결과적으로 클래스의 수명 기간을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="b3c69-161">정적 멤버는 키워드로 `static`표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="b3c69-162">정적 멤버 외에도 응용 프로그램 상태를 사용 하 여 데이터를 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="b3c69-163">각 ASP.NET 응용 프로그램은 응용 프로그램의 모든 사용자 및 페이지에서 공유 되는 이름/값 컬렉션을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-163">Each ASP.NET application maintains a name/value collection that's shared across all users and pages of the application.</span></span> <span data-ttu-id="b3c69-164">이 컬렉션은 [ `HttpContext` 클래스](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)의 [ `Application` 속성](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)을 사용 하 여 액세스할 수 있으며, 다음과 같이 ASP.NET 페이지의 코드 숨김이 아닌 클래스에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)'s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page's code-behind class like so:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="b3c69-165">데이터 캐시는 데이터를 캐시 하 고 시간 및 종속성 기반 expiries, 캐시 항목 우선 순위 등을 위한 메커니즘을 제공 하는 훨씬 더 풍부한 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="b3c69-166">정적 멤버와 응용 프로그램 상태를 사용 하면 페이지 개발자가 이러한 기능을 수동으로 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="b3c69-167">그러나 응용 프로그램을 시작할 때 응용 프로그램의 수명 동안 데이터를 캐시 하는 경우 데이터 캐시의 이점이 불과할 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-167">When caching data at application startup for the lifetime of the application, however, the data cache's advantages are moot.</span></span> <span data-ttu-id="b3c69-168">이 자습서에서는 정적 데이터 캐싱에 세 가지 기술을 모두 사용 하는 코드를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="b3c69-169">3단계: `Suppliers`테이블 데이터 캐싱</span><span class="sxs-lookup"><span data-stu-id="b3c69-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="b3c69-170">지금까지 구현한 Northwind 데이터베이스 테이블에는 기존의 조회 테이블이 포함 되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="b3c69-171">해당 값이 비정적 인 모든 모델 테이블에서 구현 되는 네 가지 Datatable.</span><span class="sxs-lookup"><span data-stu-id="b3c69-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="b3c69-172">이 자습서에서는 DAL에 새 DataTable을 추가 하는 시간을 소비 하 고 BLL에 새 클래스와 메서드를 사용 하는 대신 `Suppliers` 테이블의 데이터가 정적인 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let's just pretend that the `Suppliers` table's data is static.</span></span> <span data-ttu-id="b3c69-173">따라서 응용 프로그램을 시작할 때이 데이터를 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="b3c69-174">시작 하려면 `StaticCache.cs` `CL` 폴더에 이라는 새 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>

![CL 폴더에 StaticCache.cs 클래스 만들기](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="b3c69-176">**그림 2**: 폴더에 클래스를 `StaticCache.cs` 만듭니다. `CL`</span><span class="sxs-lookup"><span data-stu-id="b3c69-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>

<span data-ttu-id="b3c69-177">시작할 때 데이터를 로드 하는 메서드를 적절 한 캐시 저장소에 추가 하 고이 캐시에서 데이터를 반환 하는 메서드를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="b3c69-178">위의 코드에서는 정적 `suppliers`멤버 변수를 사용 하 여 `LoadStaticCache()` 메서드에서 호출 되는 `SuppliersBLL` 클래스의 `GetSuppliers()` 메서드에서 결과를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class's `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="b3c69-179">메서드 `LoadStaticCache()` 는 응용 프로그램을 시작 하는 동안 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-179">The `LoadStaticCache()` method is meant to be called during the application's start.</span></span> <span data-ttu-id="b3c69-180">응용 프로그램 시작 시이 데이터가 로드 되 면 공급자 데이터를 사용 해야 하는 모든 페이지에서 클래스의 `StaticCache` `GetSuppliers()` 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class's `GetSuppliers()` method.</span></span> <span data-ttu-id="b3c69-181">따라서 공급자를 가져오기 위해 데이터베이스에 대 한 호출은 응용 프로그램 시작 시 한 번만 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="b3c69-182">정적 멤버 변수를 캐시 저장소로 사용 하는 대신 응용 프로그램 상태 또는 데이터 캐시를 사용 했을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="b3c69-183">다음 코드에서는 응용 프로그램 상태를 사용 하는 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-183">The following code shows the class retooled to use application state:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="b3c69-184">에서 `LoadStaticCache()`공급자 정보는 응용 프로그램 변수 *키*에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="b3c69-185">`Northwind.SuppliersDataTable` 에서`GetSuppliers()`적절 한 형식 ()으로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-185">It's returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="b3c69-186">응용 프로그램 상태는를 사용 하 `Application["key"]`는 ASP.NET 페이지의 코드 숨김이 클래스에서 액세스할 수 있지만 현재 `HttpContext`를 얻기 위해를 `HttpContext.Current.Application["key"]` 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="b3c69-187">마찬가지로, 다음 코드에 나와 있는 것 처럼 데이터 캐시를 캐시 저장소로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="b3c69-188">시간 기반 만료 없이 항목을 데이터 캐시에 추가 하려면 `System.Web.Caching.Cache.NoAbsoluteExpiration` 및 `System.Web.Caching.Cache.NoSlidingExpiration` 값을 입력 매개 변수로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="b3c69-189">캐시 항목의 *우선 순위* 를 지정할 수 `Insert` 있도록 데이터 캐시의 메서드에 대 한이 특정 오버 로드가 선택 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-189">This particular overload of the data cache's `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="b3c69-190">우선 순위는 사용 가능한 메모리가 부족 한 경우 캐시에서 청소할 항목을 결정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="b3c69-191">여기서는이 캐시 항목이 `NotRemovable`청소 되지 않도록 하는 우선 순위를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-191">Here we use the priority `NotRemovable`, which ensures that this cache item won't be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="b3c69-192">이 자습서의 다운로드에서는 정적 `StaticCache` 멤버 변수 접근 방법을 사용 하 여 클래스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-192">This tutorial's download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="b3c69-193">응용 프로그램 상태 및 데이터 캐시 기술에 대 한 코드는 클래스 파일의 주석에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>

## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="b3c69-194">4단계: 응용 프로그램 시작 시 코드 실행</span><span class="sxs-lookup"><span data-stu-id="b3c69-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="b3c69-195">웹 응용 프로그램이 처음 시작 될 때 코드를 실행 하려면 라는 `Global.asax`특수 파일을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="b3c69-196">이 파일은 응용 프로그램, 세션 및 요청 수준 이벤트에 대 한 이벤트 처리기를 포함할 수 있으며 응용 프로그램이 시작 될 때마다 실행 되는 코드를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="b3c69-197">Visual Studio의 솔루션 탐색기에서 웹 사이트 프로젝트 이름을 마우스 오른쪽 단추로 클릭 하 고 새 항목 추가를 선택 하 여 웹 응용 프로그램의 루트 디렉터리에 파일을추가합니다.`Global.asax`</span><span class="sxs-lookup"><span data-stu-id="b3c69-197">Add the `Global.asax` file to your web application's root directory by right-clicking on the website project name in Visual Studio's Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="b3c69-198">새 항목 추가 대화 상자에서 전역 응용 프로그램 클래스 항목 유형을 선택 하 고 추가 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="b3c69-199">프로젝트에 `Global.asax` 파일이 이미 있는 경우 전역 응용 프로그램 클래스 항목 형식이 새 항목 추가 대화 상자에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>

<span data-ttu-id="b3c69-200">[![웹 응용 프로그램의 루트 디렉터리에 Global.asax 파일을 추가 합니다.](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="b3c69-200">[![Add the Global.asax File to Your Web Application's Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="b3c69-201">**그림 3**: 웹 응용 `Global.asax` 프로그램의 루트 디렉터리에 파일을 추가 합니다 ([전체 크기 이미지를 보려면 클릭](caching-data-at-application-startup-cs/_static/image5.png)).</span><span class="sxs-lookup"><span data-stu-id="b3c69-201">**Figure 3**: Add the `Global.asax` File to Your Web Application's Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>

<span data-ttu-id="b3c69-202">기본 `Global.asax` 파일 템플릿은 서버 쪽 `<script>` 태그 내에 5 개의 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="b3c69-203">**`Application_Start`** 웹 응용 프로그램이 처음 시작 될 때 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="b3c69-204">**`Application_End`** 응용 프로그램이 종료 될 때 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="b3c69-205">**`Application_Error`** 처리 되지 않은 예외가 응용 프로그램에 도달할 때마다 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="b3c69-206">**`Session_Start`** 새 세션이 만들어질 때 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="b3c69-207">**`Session_End`** 세션이 만료 되거나 중단 될 때 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="b3c69-208">`Application_Start` 이벤트 처리기는 응용 프로그램의 수명 주기 동안 한 번만 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-208">The `Application_Start` event handler is called only once during an application's life cycle.</span></span> <span data-ttu-id="b3c69-209">응용 프로그램은 응용 프로그램에서 ASP.NET 리소스가 처음 요청 될 때 시작 되 고 응용 프로그램이 다시 시작 될 때까지 계속 실행 됩니다 .이는 `/Bin` 폴더 `Global.asax`의 콘텐츠를 수정 하 고 수정 하 고 수정 하 여 발생할 수 있습니다. 다른 원인으로 `App_Code` 인해 폴더의 콘텐츠 또는 `Web.config` 파일을 수정 하는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="b3c69-210">응용 프로그램 수명 주기에 대 한 자세한 내용은 [ASP.NET 응용 프로그램 수명 주기 개요](https://msdn.microsoft.com/library/ms178473.aspx) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c69-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="b3c69-211">이러한 자습서에서는 `Application_Start` 메서드에 코드를 추가 하기만 하면 되므로 다른 코드를 자유롭게 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="b3c69-212">에서 `Application_Start`공급자 정보를 로드 `StaticCache` 하 고 `LoadStaticCache()` 캐시 하는 클래스의 메서드를 호출 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-212">In `Application_Start`, simply call the `StaticCache` class's `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="b3c69-213">이것이 전부입니다!</span><span class="sxs-lookup"><span data-stu-id="b3c69-213">That's all there is to it!</span></span> <span data-ttu-id="b3c69-214">응용 프로그램 시작 시 메서드 `LoadStaticCache()` 는 BLL에서 공급자 정보를 가져오고이를 정적 멤버 변수 (또는 `StaticCache` 클래스에서 사용 하 여 종료 한 캐시 저장소)에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="b3c69-215">이 동작을 확인 하려면 `Application_Start` 메서드에 중단점을 설정 하 고 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="b3c69-216">응용 프로그램이 시작 될 때 중단점이 적중 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="b3c69-217">그러나 후속 요청은 `Application_Start` 메서드를 실행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>

<span data-ttu-id="b3c69-218">[![중단점을 사용 하 여 Application_Start 이벤트 처리기가 실행 되 고 있는지 확인 합니다.](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="b3c69-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="b3c69-219">**그림 4**: 중단점을 사용 하 여 `Application_Start` 이벤트 처리기가 실행 되 고 있는지 확인 합니다 ([전체 크기 이미지를 보려면 클릭](caching-data-at-application-startup-cs/_static/image8.png)).</span><span class="sxs-lookup"><span data-stu-id="b3c69-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>

> [!NOTE]
> <span data-ttu-id="b3c69-220">처음으로 디버깅을 시작할 때 `Application_Start` 중단점에 도달 하지 않으면 응용 프로그램이 이미 시작 되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="b3c69-221">`Global.asax` 또는`Web.config` 파일을 수정 하 여 응용 프로그램을 강제로 다시 시작 하 고 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="b3c69-222">이러한 파일 중 하나의 끝에 빈 줄을 추가 (또는 제거) 하 여 응용 프로그램을 신속 하 게 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>

## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="b3c69-223">5단계: 캐시 된 데이터 표시</span><span class="sxs-lookup"><span data-stu-id="b3c69-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="b3c69-224">이 시점에서 클래스 `StaticCache` 는 응용 프로그램 시작 시 캐시 된 공급자 데이터의 버전을 포함 하 여 해당 `GetSuppliers()` 메서드를 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="b3c69-225">프레젠테이션 계층에서이 데이터를 사용 하려면 ObjectDataSource를 사용 하거나 ASP.NET 페이지의 코드 숨김으로 클래스의 `StaticCache` `GetSuppliers()` 메서드를 프로그래밍 방식으로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class's `GetSuppliers()` method from an ASP.NET page's code-behind class.</span></span> <span data-ttu-id="b3c69-226">ObjectDataSource 컨트롤과 GridView 컨트롤을 사용 하 여 캐시 된 공급자 정보를 표시 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-226">Let's look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="b3c69-227">먼저 `AtApplicationStartup.aspx` 폴더`Caching` 에서 페이지를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="b3c69-228">`ID` 속성을로 `Suppliers`설정 하 여 도구 상자에서 디자이너로 GridView를 끌어 옵니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="b3c69-229">다음으로 GridView의 스마트 태그에서 라는 `SuppliersCachedDataSource`새 ObjectDataSource를 만들도록 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-229">Next, from the GridView's smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="b3c69-230">`StaticCache` 클래스 의`GetSuppliers()` 메서드를 사용 하도록 ObjectDataSource를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-230">Configure the ObjectDataSource to use the `StaticCache` class's `GetSuppliers()` method.</span></span>

<span data-ttu-id="b3c69-231">[![StaticCache 클래스를 사용 하도록 ObjectDataSource 구성](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="b3c69-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="b3c69-232">**그림 5**: 클래스를 `StaticCache` 사용 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="b3c69-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>

<span data-ttu-id="b3c69-233">[![GetSuppliers () 메서드를 사용 하 여 캐시 된 공급자 데이터 검색](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="b3c69-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="b3c69-234">**그림 6**: 메서드를 `GetSuppliers()` 사용 하 여 캐시 된 공급자 데이터 검색 ([전체 크기 이미지를 보려면 클릭](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="b3c69-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>

<span data-ttu-id="b3c69-235">마법사를 완료 한 후 Visual Studio는의 각 데이터 필드 `SuppliersDataTable`에 대해 BoundFields를 자동으로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="b3c69-236">GridView와 ObjectDataSource의 선언 태그는 다음과 유사 하 게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-236">Your GridView and ObjectDataSource's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="b3c69-237">그림 7은 브라우저를 통해 볼 때 페이지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="b3c69-238">출력은 BLL의 `SuppliersBLL` 클래스에서 데이터를 끌어오는 것과 동일 하지만 클래스를 `StaticCache` 사용 하면 응용 프로그램 시작 시에 캐시 된 공급자 데이터가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-238">The output is the same had we pulled the data from the BLL's `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="b3c69-239">`StaticCache` 클래스 의`GetSuppliers()` 메서드에 중단점을 설정 하 여이 동작을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-239">You can set breakpoints in the `StaticCache` class's `GetSuppliers()` method to verify this behavior.</span></span>

<span data-ttu-id="b3c69-240">[![캐시 된 공급자 데이터가 GridView에 표시 됩니다.](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="b3c69-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="b3c69-241">**그림 7**: 캐시 된 공급자 데이터가 GridView에 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](caching-data-at-application-startup-cs/_static/image17.png)).</span><span class="sxs-lookup"><span data-stu-id="b3c69-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>

## <a name="summary"></a><span data-ttu-id="b3c69-242">요약</span><span class="sxs-lookup"><span data-stu-id="b3c69-242">Summary</span></span>

<span data-ttu-id="b3c69-243">대부분의 모든 데이터 모델에는 일반적으로 조회 테이블의 형태로 구현 되는 상당한 양의 정적 데이터가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="b3c69-244">이 정보는 정적 이므로이 정보를 표시 해야 할 때마다 데이터베이스에 지속적으로 액세스할 이유가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-244">Since this information is static, there's no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="b3c69-245">또한 정적 특성으로 인해 데이터를 캐시 하는 경우 만료에 대 한 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-245">Furthermore, due to its static nature, when caching the data there's no need for an expiry.</span></span> <span data-ttu-id="b3c69-246">이 자습서에서는 이러한 데이터를 가져와서 데이터 캐시, 응용 프로그램 상태 및 정적 멤버 변수를 통해 캐시 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="b3c69-247">이 정보는 응용 프로그램 시작 시 캐시 되며 응용 프로그램의 수명 동안 캐시에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-247">This information is cached at application startup and remains in the cache throughout the application's lifetime.</span></span>

<span data-ttu-id="b3c69-248">이 자습서와 지난 두 가지에서는 시간 기반 expiries을 사용 하는 것 뿐만 아니라 응용 프로그램의 수명 기간 동안 데이터를 캐시 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application's lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="b3c69-249">그러나 데이터베이스 데이터를 캐시 하는 경우 시간 기반 만료가 이상적인 시간 보다 낮을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="b3c69-250">캐시를 주기적으로 플러시하는 대신 기본 데이터베이스 데이터가 수정 될 때 캐시 된 항목만 제거 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="b3c69-251">이러한 이상적인 방법은 다음 자습서에서 살펴볼 SQL 캐시 종속성을 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="b3c69-252">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="b3c69-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="b3c69-253">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="b3c69-253">About the Author</span></span>

<span data-ttu-id="b3c69-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="b3c69-255">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="b3c69-256">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="b3c69-257">에 연결할 수 있습니다 [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="b3c69-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="b3c69-258">또는의 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)블로그를 통해 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="b3c69-259">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-259">Special Thanks To</span></span>

<span data-ttu-id="b3c69-260">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="b3c69-261">이 자습서의 리드 검토자는 Teresa Murphy 및 Zack Jones 였습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c69-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="b3c69-262">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="b3c69-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="b3c69-263">그렇다면 줄을에 [ mitchell@4GuysFromRolla.com놓습니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="b3c69-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="b3c69-264">[이전](caching-data-in-the-architecture-cs.md)
> [다음](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="b3c69-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
