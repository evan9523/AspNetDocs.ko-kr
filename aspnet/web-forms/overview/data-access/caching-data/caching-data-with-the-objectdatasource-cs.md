---
uid: web-forms/overview/data-access/caching-data/caching-data-with-the-objectdatasource-cs
title: ObjectDataSource를 사용 하 여 데이터C#캐싱 () | Microsoft Docs
author: rick-anderson
description: 캐싱은 속도가 느리고 빠른 웹 응용 프로그램 간의 차이를 의미할 수 있습니다. 이 자습서는 ASP.NET의 캐싱을 자세히 확인 하는 4 개 중 첫 번째입니다.
ms.author: riande
ms.date: 05/30/2007
ms.assetid: bd87413c-8160-4520-a8a2-43b555c4183a
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-with-the-objectdatasource-cs
msc.type: authoredcontent
ms.openlocfilehash: c9883314d6153b9816d9bad2a281ab3c0a816448
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78420659"
---
# <a name="caching-data-with-the-objectdatasource-c"></a><span data-ttu-id="e46fc-104">ObjectDataSource를 사용하여 데이터 캐싱(C#)</span><span class="sxs-lookup"><span data-stu-id="e46fc-104">Caching Data with the ObjectDataSource (C#)</span></span>

<span data-ttu-id="e46fc-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e46fc-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e46fc-106">[샘플 앱 다운로드](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_58_CS.exe) 또는 [PDF 다운로드](caching-data-with-the-objectdatasource-cs/_static/datatutorial58cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e46fc-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_58_CS.exe) or [Download PDF](caching-data-with-the-objectdatasource-cs/_static/datatutorial58cs1.pdf)</span></span>

> <span data-ttu-id="e46fc-107">캐싱은 속도가 느리고 빠른 웹 응용 프로그램 간의 차이를 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-107">Caching can mean the difference between a slow and a fast Web application.</span></span> <span data-ttu-id="e46fc-108">이 자습서는 ASP.NET의 캐싱을 자세히 살펴보는 4 중 첫 번째입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-108">This tutorial is the first of four that take a detailed look at caching in ASP.NET.</span></span> <span data-ttu-id="e46fc-109">캐싱에 대 한 주요 개념 및 ObjectDataSource 컨트롤을 통해 프레젠테이션 계층에 캐싱을 적용 하는 방법에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-109">Learn the key concepts of caching and how to apply caching to the Presentation Layer through the ObjectDataSource control.</span></span>

## <a name="introduction"></a><span data-ttu-id="e46fc-110">소개</span><span class="sxs-lookup"><span data-stu-id="e46fc-110">Introduction</span></span>

<span data-ttu-id="e46fc-111">컴퓨터 과학에서 *캐싱은* 액세스 하는 데 더 빠른 위치에 복사본을 얻고 저장 하는 데 비용이 많이 드는 데이터 또는 정보를 가져오는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-111">In computer science, *caching* is the process of taking data or information that is expensive to obtain and storing a copy of it in a location that is quicker to access.</span></span> <span data-ttu-id="e46fc-112">데이터 기반 응용 프로그램의 경우 크고 복잡 한 쿼리는 일반적으로 대부분의 응용 프로그램 실행 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-112">For data-driven applications, large and complex queries commonly consume the majority of the application s execution time.</span></span> <span data-ttu-id="e46fc-113">이러한 응용 프로그램의 성능은 응용 프로그램의 메모리에 비용이 많이 드는 데이터베이스 쿼리 결과를 저장 하 여 자주 향상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-113">Such an application s performance, then, can often be improved by storing the results of expensive database queries in the application s memory.</span></span>

<span data-ttu-id="e46fc-114">ASP.NET 2.0는 다양 한 캐싱 옵션을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-114">ASP.NET 2.0 offers a variety of caching options.</span></span> <span data-ttu-id="e46fc-115">전체 웹 페이지 또는 사용자 정의 컨트롤의 렌더링 된 태그는 *출력 캐싱을*통해 캐시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-115">An entire web page or User Control s rendered markup can be cached through *output caching*.</span></span> <span data-ttu-id="e46fc-116">ObjectDataSource 및 SqlDataSource 컨트롤은 캐싱 기능도 제공 하므로 데이터를 컨트롤 수준에서 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-116">The ObjectDataSource and SqlDataSource controls provide caching capabilities as well, thereby allowing data to be cached at the control level.</span></span> <span data-ttu-id="e46fc-117">및 ASP.NET s *데이터 캐시* 는 페이지 개발자가 프로그래밍 방식으로 개체를 캐시 하는 데 사용할 수 있는 풍부한 캐싱 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-117">And ASP.NET s *data cache* provides a rich caching API that enables page developers to programmatically cache objects.</span></span> <span data-ttu-id="e46fc-118">이 자습서 및 다음 세 가지에서는 데이터 캐시 뿐만 아니라 ObjectDataSource s 캐싱 기능을 사용 하 여 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-118">In this tutorial and the next three we'll examine using the ObjectDataSource s caching features as well as the data cache.</span></span> <span data-ttu-id="e46fc-119">또한 시작 시 응용 프로그램 전체 데이터를 캐시 하는 방법 및 SQL 캐시 종속성을 사용 하 여 캐시 된 데이터를 최신 상태로 유지 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-119">We'll also explore how to cache application-wide data at startup and how to keep cached data fresh through the use of SQL cache dependencies.</span></span> <span data-ttu-id="e46fc-120">이러한 자습서에서는 출력 캐싱을 탐색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-120">These tutorials do not explore output caching.</span></span> <span data-ttu-id="e46fc-121">출력 캐싱에 대 한 자세한 내용은 [ASP.NET 2.0의 출력 캐싱](http://aspnet.4guysfromrolla.com/articles/121306-1.aspx)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-121">For a detailed look at output caching, see [Output Caching in ASP.NET 2.0](http://aspnet.4guysfromrolla.com/articles/121306-1.aspx).</span></span>

<span data-ttu-id="e46fc-122">캐싱은 프레젠테이션 계층을 통해 데이터 액세스 계층에서 아키텍처의 어느 위치에 나 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-122">Caching can be applied at any place in the architecture, from the Data Access Layer up through the Presentation Layer.</span></span> <span data-ttu-id="e46fc-123">이 자습서에서는 ObjectDataSource 컨트롤을 통해 프레젠테이션 계층에 캐싱을 적용 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-123">In this tutorial we'll look at applying caching to the Presentation Layer through the ObjectDataSource control.</span></span> <span data-ttu-id="e46fc-124">다음 자습서에서는 비즈니스 논리 계층에서 데이터 캐싱을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-124">In the next tutorial we'll examine caching data at the Business Logic Layer.</span></span>

## <a name="key-caching-concepts"></a><span data-ttu-id="e46fc-125">키 캐싱 개념</span><span class="sxs-lookup"><span data-stu-id="e46fc-125">Key Caching Concepts</span></span>

<span data-ttu-id="e46fc-126">캐싱은 더 효율적으로 액세스할 수 있는 위치에 복사본을 생성 하 고 저장 하는 데 비용이 많이 드는 데이터를 활용 하 여 응용 프로그램의 전반적인 성능 및 확장성을 크게 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-126">Caching can greatly improve an application s overall performance and scalability by taking data that is expensive to generate and storing a copy of it in a location that can be more efficiently accessed.</span></span> <span data-ttu-id="e46fc-127">캐시에는 실제 기본 데이터의 복사본만 포함 되므로 기본 데이터가 *변경 되 면 오래 되거나 오래*된 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-127">Since the cache holds just a copy of the actual, underlying data, it can become outdated, or *stale*, if the underlying data changes.</span></span> <span data-ttu-id="e46fc-128">이를 위해 페이지 개발자는 다음 중 하나를 사용 하 여 캐시 항목이 캐시에서 *제거* 되는 기준을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-128">To combat this, a page developer can indicate criteria by which the cache item will be *evicted* from the cache, using either:</span></span>

- <span data-ttu-id="e46fc-129">**시간 기반 조건** 절대 또는 슬라이딩 기간 동안 항목을 캐시에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-129">**Time-based criteria** an item may be added to the cache for an absolute or sliding duration.</span></span> <span data-ttu-id="e46fc-130">예를 들어, 페이지 개발자는 60 초의 기간을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-130">For example, a page developer may indicate a duration of, say, 60 seconds.</span></span> <span data-ttu-id="e46fc-131">절대 기간을 사용 하는 경우 캐시 된 항목은 액세스 빈도에 관계 없이 캐시에 추가 된 후 60 초 후에 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-131">With an absolute duration, the cached item is evicted 60 seconds after it was added to cache, regardless of how frequently it was accessed.</span></span> <span data-ttu-id="e46fc-132">슬라이딩 기간을 사용 하면 캐시 된 항목이 마지막 액세스 후 60 초 후에 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-132">With a sliding duration, the cached item is evicted 60 seconds after the last access.</span></span>
- <span data-ttu-id="e46fc-133">**종속성 기반 조건-** 캐시에 추가 될 때 종속성을 항목과 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-133">**Dependency-based criteria** a dependency can be associated with an item when added to the cache.</span></span> <span data-ttu-id="e46fc-134">항목의 종속성이 변경 되 면 캐시에서 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-134">When the item s dependency changes it is evicted from the cache.</span></span> <span data-ttu-id="e46fc-135">종속성은 파일, 다른 캐시 항목 또는 둘의 조합일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-135">The dependency may be a file, another cache item, or a combination of the two.</span></span> <span data-ttu-id="e46fc-136">ASP.NET 2.0는 또한 개발자가 캐시에 항목을 추가 하 고 기본 데이터베이스 데이터가 변경 될 때 해당 항목을 제거 하도록 하는 SQL 캐시 종속성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-136">ASP.NET 2.0 also allows SQL cache dependencies, which enable developers to add an item to the cache and have it evicted when the underlying database data changes.</span></span> <span data-ttu-id="e46fc-137">향후 [Sql 캐시 종속성 사용](using-sql-cache-dependencies-cs.md) 자습서에서 sql 캐시 종속성을 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-137">We will examine SQL cache dependencies in the upcoming [Using SQL Cache Dependencies](using-sql-cache-dependencies-cs.md) tutorial.</span></span>

<span data-ttu-id="e46fc-138">지정 된 제거 조건에 관계 없이 시간 기반 또는 종속성 기반 조건이 충족 되기 전에 캐시의 항목이 *청소* 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-138">Regardless of the eviction criteria specified, an item in the cache may be *scavenged* before the time-based or dependency-based criteria has been met.</span></span> <span data-ttu-id="e46fc-139">캐시가 용량에 도달 하면 기존 항목을 제거 해야 새 항목을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-139">If the cache has reached its capacity, existing items must be removed before new ones can be added.</span></span> <span data-ttu-id="e46fc-140">결과적으로 캐시 된 데이터를 프로그래밍 방식으로 작업 하는 경우 캐시 된 데이터가 항상 존재 하지 않을 수 있다고 가정 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-140">Consequently, when programmatically working with cached data it s vital that you always assume that the cached data may not be present.</span></span> <span data-ttu-id="e46fc-141">다음 자습서 인 *아키텍처의 데이터 캐싱*에서 프로그래밍 방식으로 캐시의 데이터에 액세스할 때 사용할 패턴을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-141">We'll look at the pattern to use when accessing data from the cache programmatically in our next tutorial, *Caching Data in the Architecture*.</span></span>

<span data-ttu-id="e46fc-142">캐싱은 응용 프로그램에서 더 많은 성능을 제공 하는 경제적 수단을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-142">Caching provides an economical means for squeezing more performance from an application.</span></span> <span data-ttu-id="e46fc-143">이 문서에서 명확히 [Smith](http://aspadvice.com/blogs/ssmith/) 는 [ASP.NET 캐싱: 기술 및 모범 사례](https://msdn.microsoft.com/library/aa478965.aspx)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-143">As [Steven Smith](http://aspadvice.com/blogs/ssmith/) articulates in his article [ASP.NET Caching: Techniques and Best Practices](https://msdn.microsoft.com/library/aa478965.aspx):</span></span>

<span data-ttu-id="e46fc-144">캐싱은 많은 시간과 분석을 요구 하지 않고 충분 한 성능을 제공 하는 좋은 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-144">Caching can be a good way to get good enough performance without requiring a lot of time and analysis.</span></span> <span data-ttu-id="e46fc-145">메모리는 저렴 하므로, 코드 또는 데이터베이스를 최적화 하는 데 하루 또는 일주일을 소비 하는 대신 30 초 동안 출력을 캐싱하여 필요한 성능을 얻을 수 있는 경우 캐싱 솔루션 (30 초 이전 데이터가 양호 하다 고 가정)을 수행 하 고 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-145">Memory is cheap, so if you can get the performance you need by caching the output for 30 seconds instead of spending a day or a week trying to optimize your code or database, do the caching solution (assuming 30-second old data is ok) and move on.</span></span> <span data-ttu-id="e46fc-146">결국 잘못 된 설계로 인해 사용자가 올바르게 구성 될 수 있으므로 응용 프로그램을 올바르게 디자인 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-146">Eventually, poor design will probably catch up to you, so of course you should try to design your applications correctly.</span></span> <span data-ttu-id="e46fc-147">그러나 지금 충분 한 성능을 제공 해야 하는 경우 캐싱은 좋은 [접근 방식]이 될 수 있으므로 나중에 응용 프로그램을 리팩터링 하는 시간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-147">But if you just need to get good enough performance today, caching can be an excellent [approach], buying you time to refactor your application at a later date when you have the time to do so.</span></span>

<span data-ttu-id="e46fc-148">캐싱은 있는 이점은 성능 향상을 제공할 수 있지만, 실시간으로 업데이트 되는 데이터를 사용 하는 응용 프로그램 또는 곧 오래 지속 되는 데이터를 사용할 수 없는 경우와 같은 일부 상황에서는 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-148">While caching can provide appreciable performance enhancements, it is not applicable in all situations, such as with applications that use real-time, frequently-updating data, or where even shortly-lived stale data is unacceptable.</span></span> <span data-ttu-id="e46fc-149">하지만 대부분의 응용 프로그램에서는 캐싱이 사용 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-149">But for the majority of applications, caching should be used.</span></span> <span data-ttu-id="e46fc-150">ASP.NET 2.0의 캐싱에 대 한 자세한 배경 정보는 [ASP.NET 2.0 빠른 시작 자습서](https://quickstarts.asp.net/QuickStartv20/aspnet/)의 [성능에 대 한 캐싱](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/default.aspx) 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-150">For more background on caching in ASP.NET 2.0, refer to the [Caching for Performance](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/default.aspx) section of the [ASP.NET 2.0 QuickStart Tutorials](https://quickstarts.asp.net/QuickStartv20/aspnet/).</span></span>

## <a name="step-1-creating-the-caching-web-pages"></a><span data-ttu-id="e46fc-151">1 단계: 캐싱 웹 페이지 만들기</span><span class="sxs-lookup"><span data-stu-id="e46fc-151">Step 1: Creating the Caching Web Pages</span></span>

<span data-ttu-id="e46fc-152">ObjectDataSource의 캐싱 기능에 대 한 탐색을 시작 하기 전에 먼저이 자습서와 다음 3 개에 필요한 웹 사이트 프로젝트에 ASP.NET 페이지를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-152">Before we start our exploration of the ObjectDataSource s caching features, let s first take a moment to create the ASP.NET pages in our website project that we'll need for this tutorial and the next three.</span></span> <span data-ttu-id="e46fc-153">`Caching`이라는 새 폴더를 추가 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-153">Start by adding a new folder named `Caching`.</span></span> <span data-ttu-id="e46fc-154">그런 다음, 다음 ASP.NET 페이지를 해당 폴더에 추가 하 여 각 페이지를 `Site.master` 마스터 페이지에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-154">Next, add the following ASP.NET pages to that folder, making sure to associate each page with the `Site.master` master page:</span></span>

- `Default.aspx`
- `ObjectDataSource.aspx`
- `FromTheArchitecture.aspx`
- `AtApplicationStartup.aspx`
- `SqlCacheDependencies.aspx`

![캐싱 관련 자습서에 대 한 ASP.NET 페이지 추가](caching-data-with-the-objectdatasource-cs/_static/image1.png)

<span data-ttu-id="e46fc-156">**그림 1**: 캐싱 관련 자습서에 대 한 ASP.NET 페이지 추가</span><span class="sxs-lookup"><span data-stu-id="e46fc-156">**Figure 1**: Add the ASP.NET Pages for the Caching-Related Tutorials</span></span>

<span data-ttu-id="e46fc-157">다른 폴더와 마찬가지로 `Caching` 폴더의 `Default.aspx`에는 해당 섹션의 자습서가 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-157">Like in the other folders, `Default.aspx` in the `Caching` folder will list the tutorials in its section.</span></span> <span data-ttu-id="e46fc-158">`SectionLevelTutorialListing.ascx` 사용자 정의 컨트롤은이 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-158">Recall that the `SectionLevelTutorialListing.ascx` User Control provides this functionality.</span></span> <span data-ttu-id="e46fc-159">따라서이 사용자 정의 컨트롤을 솔루션 탐색기에서 페이지 디자인 뷰로 끌어 `Default.aspx`에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-159">Therefore, add this User Control to `Default.aspx` by dragging it from the Solution Explorer onto the page s Design view.</span></span>

<span data-ttu-id="e46fc-160">[![그림 2: Default.aspx에 SectionLevelTutorialListing 사용자 정의 컨트롤 추가](caching-data-with-the-objectdatasource-cs/_static/image3.png)](caching-data-with-the-objectdatasource-cs/_static/image2.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-160">[![Figure 2: Add the SectionLevelTutorialListing.ascx User Control to Default.aspx](caching-data-with-the-objectdatasource-cs/_static/image3.png)](caching-data-with-the-objectdatasource-cs/_static/image2.png)</span></span>

<span data-ttu-id="e46fc-161">**그림 2**: `Default.aspx`에 `SectionLevelTutorialListing.ascx` 사용자 정의 컨트롤 추가 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-161">**Figure 2**: Figure 2: Add the `SectionLevelTutorialListing.ascx` User Control to `Default.aspx` ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image4.png))</span></span>

<span data-ttu-id="e46fc-162">마지막으로, 이러한 페이지를 `Web.sitemap` 파일에 항목으로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-162">Lastly, add these pages as entries to the `Web.sitemap` file.</span></span> <span data-ttu-id="e46fc-163">특히, 이진 데이터 작업 후 다음 태그를 추가 `<siteMapNode>`합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-163">Specifically, add the following markup after the Working with Binary Data `<siteMapNode>`:</span></span>

[!code-xml[Main](caching-data-with-the-objectdatasource-cs/samples/sample1.xml)]

<span data-ttu-id="e46fc-164">`Web.sitemap`업데이트 한 후 브라우저를 통해 자습서 웹 사이트를 잠시 기다려 주십시오.</span><span class="sxs-lookup"><span data-stu-id="e46fc-164">After updating `Web.sitemap`, take a moment to view the tutorials website through a browser.</span></span> <span data-ttu-id="e46fc-165">이제 왼쪽의 메뉴에는 캐싱 자습서에 대 한 항목이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-165">The menu on the left now includes items for the caching tutorials.</span></span>

![이제 사이트 맵에 캐싱 자습서에 대 한 항목이 포함 되어 있습니다.](caching-data-with-the-objectdatasource-cs/_static/image5.png)

<span data-ttu-id="e46fc-167">**그림 3**: 이제 사이트 맵에 캐싱 자습서에 대 한 항목이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-167">**Figure 3**: The Site Map Now Includes Entries for the Caching Tutorials</span></span>

## <a name="step-2-displaying-a-list-of-products-in-a-web-page"></a><span data-ttu-id="e46fc-168">2 단계: 웹 페이지에서 제품 목록 표시</span><span class="sxs-lookup"><span data-stu-id="e46fc-168">Step 2: Displaying a List of Products in a Web Page</span></span>

<span data-ttu-id="e46fc-169">이 자습서에서는 ObjectDataSource 컨트롤의 기본 제공 캐싱 기능을 사용 하는 방법을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-169">This tutorial explores how to use the ObjectDataSource control s built-in caching features.</span></span> <span data-ttu-id="e46fc-170">그러나 이러한 기능을 살펴보기 전에 먼저 작업할 페이지가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-170">Before we can look at these features, though, we first need a page to work from.</span></span> <span data-ttu-id="e46fc-171">에서 GridView를 사용 하 여 `ProductsBLL` 클래스에서 ObjectDataSource로 검색 되는 제품 정보를 나열 하는 웹 페이지를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-171">Let s create a web page that uses a GridView to list product information retrieved by an ObjectDataSource from the `ProductsBLL` class.</span></span>

<span data-ttu-id="e46fc-172">먼저 `Caching` 폴더에서 `ObjectDataSource.aspx` 페이지를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-172">Start by opening the `ObjectDataSource.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="e46fc-173">GridView를 도구 상자에서 디자이너로 끌고, 해당 `ID` 속성을 `Products`로 설정 하 고, 스마트 태그에서를 선택 하 여 `ProductsDataSource`라는 새 ObjectDataSource 컨트롤에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-173">Drag a GridView from the Toolbox onto the Designer, set its `ID` property to `Products`, and, from its smart tag, choose to bind it to a new ObjectDataSource control named `ProductsDataSource`.</span></span> <span data-ttu-id="e46fc-174">`ProductsBLL` 클래스를 사용 하도록 ObjectDataSource를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-174">Configure the ObjectDataSource to work with the `ProductsBLL` class.</span></span>

<span data-ttu-id="e46fc-175">[ProductsBLL 클래스를 사용 하도록 ObjectDataSource 구성 ![](caching-data-with-the-objectdatasource-cs/_static/image7.png)](caching-data-with-the-objectdatasource-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-175">[![Configure the ObjectDataSource to Use the ProductsBLL Class](caching-data-with-the-objectdatasource-cs/_static/image7.png)](caching-data-with-the-objectdatasource-cs/_static/image6.png)</span></span>

<span data-ttu-id="e46fc-176">**그림 4**: `ProductsBLL` 클래스를 사용 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-176">**Figure 4**: Configure the ObjectDataSource to Use the `ProductsBLL` Class ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image8.png))</span></span>

<span data-ttu-id="e46fc-177">이 페이지에 대해에서 GridView에 캐시 된 데이터가 GridView 인터페이스를 통해 수정 될 때 발생 하는 작업을 검토할 수 있도록 편집 가능한 GridView를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-177">For this page, let s create an editable GridView so that we can examine what happens when data cached in the ObjectDataSource is modified through the GridView s interface.</span></span> <span data-ttu-id="e46fc-178">선택 탭의 드롭다운 목록을 기본값인 `GetProducts()`로 설정 된 채로 두고 업데이트 탭에서 선택한 항목을 입력 매개 변수로 `productName`, `unitPrice`및 `productID`을 허용 하는 `UpdateProduct` 오버 로드로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-178">Leave the drop-down list in the SELECT tab set to its default, `GetProducts()`, but change the selected item in the UPDATE tab to the `UpdateProduct` overload that accepts `productName`, `unitPrice`, and `productID` as its input parameters.</span></span>

<span data-ttu-id="e46fc-179">[![업데이트 탭 드롭다운 목록을 적절 한 UpdateProduct 오버 로드로 설정 합니다.](caching-data-with-the-objectdatasource-cs/_static/image10.png)](caching-data-with-the-objectdatasource-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-179">[![Set the UPDATE Tab s Drop-Down List to the Appropriate UpdateProduct Overload](caching-data-with-the-objectdatasource-cs/_static/image10.png)](caching-data-with-the-objectdatasource-cs/_static/image9.png)</span></span>

<span data-ttu-id="e46fc-180">**그림 5**: 업데이트 탭의 드롭다운 목록을 적절 한 `UpdateProduct` 오버 로드로 설정 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-180">**Figure 5**: Set the UPDATE Tab s Drop-Down List to the Appropriate `UpdateProduct` Overload ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image11.png))</span></span>

<span data-ttu-id="e46fc-181">마지막으로 삽입 및 삭제 탭의 드롭다운 목록을 (없음)으로 설정 하 고 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-181">Finally, set the drop-down lists in the INSERT and DELETE tabs to (None) and click Finish.</span></span> <span data-ttu-id="e46fc-182">데이터 소스 구성 마법사가 완료 되 면 Visual Studio에서는 ObjectDataSource s `OldValuesParameterFormatString` 속성을 `original_{0}`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-182">Upon completing the Configure Data Source wizard, Visual Studio sets the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}`.</span></span> <span data-ttu-id="e46fc-183">[데이터 삽입, 업데이트 및 삭제에 대 한 개요](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) 에서 설명한 것 처럼이 속성은 선언적 구문에서 제거 하거나 업데이트 워크플로를 오류 없이 계속 진행 하기 위해 기본값인 `{0}`로 다시 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-183">As discussed in the [An Overview of Inserting, Updating, and Deleting Data](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) tutorial, this property needs to be removed from the declarative syntax or set back to its default value, `{0}`, in order for our update workflow to proceed without error.</span></span>

<span data-ttu-id="e46fc-184">또한 마법사가 완료 되 면 Visual Studio에서 각 제품 데이터 필드에 대 한 필드를 GridView에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-184">Furthermore, at the completion of the wizard Visual Studio adds a field to the GridView for each of the product data fields.</span></span> <span data-ttu-id="e46fc-185">`ProductName`, `CategoryName`및 `UnitPrice` BoundFields를 제외한 모든을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-185">Remove all but the `ProductName`, `CategoryName`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="e46fc-186">그런 다음 이러한 각 BoundFields의 `HeaderText` 속성을 각각 Product, Category 및 Price로 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-186">Next, update the `HeaderText` properties of each of these BoundFields to Product, Category, and Price, respectively.</span></span> <span data-ttu-id="e46fc-187">`ProductName` 필드가 필요 하므로 BoundField을 Templatefield로 변환로 변환 하 고 `EditItemTemplate`에 RequiredFieldValidator를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-187">Since the `ProductName` field is required, convert the BoundField into a TemplateField and add a RequiredFieldValidator to the `EditItemTemplate`.</span></span> <span data-ttu-id="e46fc-188">마찬가지로 `UnitPrice` BoundField을 Templatefield로 변환로 변환 하 고, 사용자가 입력 한 값이 0 보다 크거나 같은 유효한 통화 값이 되도록 CompareValidator를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-188">Similarly, convert the `UnitPrice` BoundField into a TemplateField and add a CompareValidator to ensure that the value entered by the user is a valid currency value that s greater than or equal to zero.</span></span> <span data-ttu-id="e46fc-189">이러한 수정 외에도 `UnitPrice` 값을 오른쪽에 정렬 하거나 읽기 전용 및 편집 인터페이스에서 `UnitPrice` 텍스트의 서식을 지정 하는 등의 미적 변경 작업을 자유롭게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-189">In addition to these modifications, feel free to perform any aesthetic changes, such as right-aligning the `UnitPrice` value, or specifying the formatting for the `UnitPrice` text in its read-only and editing interfaces.</span></span>

<span data-ttu-id="e46fc-190">GridView의 스마트 태그에서 편집 사용 확인란을 선택 하 여 GridView를 편집 가능 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-190">Make the GridView editable by checking the Enable Editing checkbox in the GridView s smart tag.</span></span> <span data-ttu-id="e46fc-191">또한 페이징 사용 및 정렬 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-191">Also check the Enable Paging and Enable Sorting checkboxes.</span></span>

> [!NOTE]
> <span data-ttu-id="e46fc-192">GridView 편집 인터페이스를 사용자 지정 하는 방법에 대 한 검토가 필요 한가요?</span><span class="sxs-lookup"><span data-stu-id="e46fc-192">Need a review of how to customize the GridView s editing interface?</span></span> <span data-ttu-id="e46fc-193">그렇다면 [데이터 수정 인터페이스 사용자 지정](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) 자습서를 다시 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-193">If so, refer back to the [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) tutorial.</span></span>

<span data-ttu-id="e46fc-194">[편집, 정렬 및 페이징을 위한 GridView 지원 사용 ![](caching-data-with-the-objectdatasource-cs/_static/image13.png)](caching-data-with-the-objectdatasource-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-194">[![Enable GridView Support for Editing, Sorting, and Paging](caching-data-with-the-objectdatasource-cs/_static/image13.png)](caching-data-with-the-objectdatasource-cs/_static/image12.png)</span></span>

<span data-ttu-id="e46fc-195">**그림 6**: 편집, 정렬 및 페이징에 대해 GridView 지원 사용 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-195">**Figure 6**: Enable GridView Support for Editing, Sorting, and Paging ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image14.png))</span></span>

<span data-ttu-id="e46fc-196">이러한 GridView를 수정한 후 GridView와 ObjectDataSource의 선언 태그는 다음과 유사 하 게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-196">After making these GridView modifications, the GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-with-the-objectdatasource-cs/samples/sample2.aspx)]

<span data-ttu-id="e46fc-197">그림 7에 표시 된 것 처럼 편집 가능한 GridView에는 데이터베이스에 있는 각 제품의 이름, 범주 및 가격이 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-197">As Figure 7 shows, the editable GridView lists the name, category, and price of each of the products in the database.</span></span> <span data-ttu-id="e46fc-198">잠시 페이지의 기능을 테스트 하 여 결과를 정렬 하 고, 페이지를 이동 하 고, 레코드를 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-198">Take a moment to test out the page s functionality sort the results, page through them, and edit a record.</span></span>

<span data-ttu-id="e46fc-199">[각 제품 이름, 범주 및 가격은 정렬 가능 하 고 페이징할 수 있는 편집 가능한 GridView에 나열 ![.](caching-data-with-the-objectdatasource-cs/_static/image16.png)](caching-data-with-the-objectdatasource-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-199">[![Each Product s Name, Category, and Price is Listed in a Sortable, Pageable, Editable GridView](caching-data-with-the-objectdatasource-cs/_static/image16.png)](caching-data-with-the-objectdatasource-cs/_static/image15.png)</span></span>

<span data-ttu-id="e46fc-200">**그림 7**: 각 제품의 이름, 범주 및 가격은 정렬 가능 하 고 페이징할 수 있는 편집 가능한 GridView ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image17.png))에 나열 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-200">**Figure 7**: Each Product s Name, Category, and Price is Listed in a Sortable, Pageable, Editable GridView ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image17.png))</span></span>

## <a name="step-3-examining-when-the-objectdatasource-is-requesting-data"></a><span data-ttu-id="e46fc-201">3 단계: ObjectDataSource에서 데이터를 요청 하는 경우 검사</span><span class="sxs-lookup"><span data-stu-id="e46fc-201">Step 3: Examining When the ObjectDataSource is Requesting Data</span></span>

<span data-ttu-id="e46fc-202">`Products` GridView는 `ProductsDataSource` ObjectDataSource의 `Select` 메서드를 호출 하 여 표시할 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-202">The `Products` GridView retrieves its data to display by invoking the `Select` method of the `ProductsDataSource` ObjectDataSource.</span></span> <span data-ttu-id="e46fc-203">이 ObjectDataSource는 비즈니스 논리 계층 s `ProductsBLL` 클래스의 인스턴스를 만들고 해당 `GetProducts()` 메서드를 호출 합니다. 그러면이 메서드는 데이터 액세스 계층 s `ProductsTableAdapter` s `GetProducts()` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-203">This ObjectDataSource creates an instance of the Business Logic Layer s `ProductsBLL` class and calls its `GetProducts()` method, which in turn calls the Data Access Layer s `ProductsTableAdapter` s `GetProducts()` method.</span></span> <span data-ttu-id="e46fc-204">DAL 메서드는 Northwind 데이터베이스에 연결 하 여 구성 된 `SELECT` 쿼리를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-204">The DAL method connects to the Northwind database and issues the configured `SELECT` query.</span></span> <span data-ttu-id="e46fc-205">그런 다음이 데이터는 DAL로 반환 되 고 `NorthwindDataTable`에 패키지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-205">This data is then returned to the DAL, which packages it up in a `NorthwindDataTable`.</span></span> <span data-ttu-id="e46fc-206">DataTable 개체는 BLL로 반환 됩니다. 그러면 ObjectDataSource로 반환 됩니다. 그러면 GridView로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-206">The DataTable object is returned to the BLL, which returns it to the ObjectDataSource, which returns it to the GridView.</span></span> <span data-ttu-id="e46fc-207">그런 다음 GridView는 DataTable의 각 `DataRow`에 대 한 `GridViewRow` 개체를 만들고 각 `GridViewRow`는 궁극적으로 클라이언트에 반환 되 고 방문자의 브라우저에 표시 되는 HTML로 렌더링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-207">The GridView then creates a `GridViewRow` object for each `DataRow` in the DataTable, and each `GridViewRow` is eventually rendered into the HTML that is returned to the client and displayed on the visitor s browser.</span></span>

<span data-ttu-id="e46fc-208">이러한 이벤트 시퀀스는 각각 GridView가 기본 데이터에 바인딩해야 할 때마다 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-208">This sequence of events happens each and every time the GridView needs to bind to its underlying data.</span></span> <span data-ttu-id="e46fc-209">페이지를 처음 방문할 때, GridView를 정렬할 때 또는 기본 제공 되는 인터페이스 편집 또는 삭제를 통해 GridView의 데이터를 수정 하는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-209">That happens when the page is first visited, when moving from one page of data to another, when sorting the GridView, or when modifying the GridView s data through its built-in editing or deleting interfaces.</span></span> <span data-ttu-id="e46fc-210">GridView의 뷰 상태가 사용 하지 않도록 설정 된 경우 GridView는 각 및 다시 게시에도 다시 바인딩 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-210">If the GridView s view state is disabled, the GridView will be rebound on each and every postback as well.</span></span> <span data-ttu-id="e46fc-211">또한 GridView는 해당 `DataBind()` 메서드를 호출 하 여 데이터에 명시적으로 데이터를 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-211">The GridView can also be explicitly rebound to its data by calling its `DataBind()` method.</span></span>

<span data-ttu-id="e46fc-212">데이터베이스에서 데이터를 검색 하는 빈도를 충분히 이해 하려면 데이터를 다시 검색 하는 경우를 나타내는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-212">To fully appreciate the frequency with which the data is retrieved from the database, let s display a message indicating when the data is being re-retrieved.</span></span> <span data-ttu-id="e46fc-213">`ODSEvents`라는 GridView 위에 Label 웹 컨트롤을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-213">Add a Label Web control above the GridView named `ODSEvents`.</span></span> <span data-ttu-id="e46fc-214">`Text` 속성을 지우고 `EnableViewState` 속성을 `false`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-214">Clear out its `Text` property and set its `EnableViewState` property to `false`.</span></span> <span data-ttu-id="e46fc-215">레이블 아래에서 단추 웹 컨트롤을 추가 하 고 해당 `Text` 속성을 다시 게시로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-215">Underneath the Label, add a Button Web control and set its `Text` property to Postback .</span></span>

<span data-ttu-id="e46fc-216">[GridView 위의 페이지에 레이블 및 단추를 추가 ![](caching-data-with-the-objectdatasource-cs/_static/image19.png)](caching-data-with-the-objectdatasource-cs/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-216">[![Add a Label and Button to the Page Above the GridView](caching-data-with-the-objectdatasource-cs/_static/image19.png)](caching-data-with-the-objectdatasource-cs/_static/image18.png)</span></span>

<span data-ttu-id="e46fc-217">**그림 8**: GridView 위의 페이지에 레이블 및 단추 추가 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image20.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-217">**Figure 8**: Add a Label and Button to the Page Above the GridView ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image20.png))</span></span>

<span data-ttu-id="e46fc-218">데이터 액세스 워크플로를 실행 하는 동안 ObjectDataSource s `Selecting` 이벤트는 기본 개체가 만들어지고 구성 된 메서드가 호출 되기 전에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-218">During the data access workflow, the ObjectDataSource s `Selecting` event fires before the underlying object is created and its configured method invoked.</span></span> <span data-ttu-id="e46fc-219">이 이벤트에 대 한 이벤트 처리기를 만들고 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-219">Create an event handler for this event and add the following code:</span></span>

[!code-csharp[Main](caching-data-with-the-objectdatasource-cs/samples/sample3.cs)]

<span data-ttu-id="e46fc-220">ObjectDataSource에서 데이터에 대 한 아키텍처를 요청 하면 레이블이 실행 되는 이벤트 선택이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-220">Each time the ObjectDataSource makes a request to the architecture for data, the Label will display the text Selecting event fired .</span></span>

<span data-ttu-id="e46fc-221">브라우저에서이 페이지를 방문 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-221">Visit this page in a browser.</span></span> <span data-ttu-id="e46fc-222">페이지를 처음 방문할 때 발생 한 이벤트 선택 텍스트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-222">When the page is first visited, the text Selecting event fired is shown.</span></span> <span data-ttu-id="e46fc-223">다시 게시 단추를 클릭 하면 텍스트가 사라집니다. 즉, GridView s `EnableViewState` 속성이 `true`(기본값)로 설정 되어 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-223">Click the Postback button and note that the text disappears (assuming that the GridView s `EnableViewState` property is set to `true`, the default).</span></span> <span data-ttu-id="e46fc-224">다시 게시 시 GridView가 해당 뷰 상태에서 다시 생성 되므로 데이터에 대 한 ObjectDataSource로 전환 되지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-224">This is because, on postback, the GridView is reconstructed from its view state and therefore doesn t turn to the ObjectDataSource for its data.</span></span> <span data-ttu-id="e46fc-225">그러나 데이터를 정렬, 페이징 또는 편집 하면 GridView가 해당 데이터 원본에 다시 바인딩하기 때문에 발생 한 이벤트 선택 텍스트가 다시 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-225">Sorting, paging, or editing the data, however, causes the GridView to rebind to its data source, and therefore the Selecting event fired text reappears.</span></span>

<span data-ttu-id="e46fc-226">[![GridView를 데이터 원본에 바인딩할 때마다 발생 하는 이벤트 선택이 표시 됩니다.](caching-data-with-the-objectdatasource-cs/_static/image22.png)](caching-data-with-the-objectdatasource-cs/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-226">[![Whenever the GridView is Rebound to its Data Source, Selecting event fired is Displayed](caching-data-with-the-objectdatasource-cs/_static/image22.png)](caching-data-with-the-objectdatasource-cs/_static/image21.png)</span></span>

<span data-ttu-id="e46fc-227">**그림 9**: GridView가 데이터 원본에 바인딩 될 때마다 발생 하는 이벤트 선택이 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image23.png)).</span><span class="sxs-lookup"><span data-stu-id="e46fc-227">**Figure 9**: Whenever the GridView is Rebound to its Data Source, Selecting event fired is Displayed ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image23.png))</span></span>

<span data-ttu-id="e46fc-228">[다시 게시 단추를 클릭 하면 해당 뷰 상태에서 GridView가 다시 생성 됩니다 ![](caching-data-with-the-objectdatasource-cs/_static/image25.png)](caching-data-with-the-objectdatasource-cs/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-228">[![Clicking the Postback Button Causes the GridView to be Reconstructed from its View State](caching-data-with-the-objectdatasource-cs/_static/image25.png)](caching-data-with-the-objectdatasource-cs/_static/image24.png)</span></span>

<span data-ttu-id="e46fc-229">**그림 10**: 포스트백 단추를 클릭 하면 해당 뷰 상태에서 GridView가 재구성 됩니다 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image26.png)).</span><span class="sxs-lookup"><span data-stu-id="e46fc-229">**Figure 10**: Clicking the Postback Button Causes the GridView to be Reconstructed from its View State ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image26.png))</span></span>

<span data-ttu-id="e46fc-230">데이터가 페이징 되거나 정렬 될 때마다 데이터베이스 데이터를 검색 하는 것은 불필요 한 것 처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-230">It may seem wasteful to retrieve the database data each time the data is paged through or sorted.</span></span> <span data-ttu-id="e46fc-231">모든 경우 기본 페이징이 다시 사용 되므로 ObjectDataSource는 첫 번째 페이지를 표시할 때 모든 레코드를 검색 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-231">After all, since we re using default paging, the ObjectDataSource has retrieved all of the records when displaying the first page.</span></span> <span data-ttu-id="e46fc-232">GridView에서 정렬과 페이징을 지원 하지 않는 경우에도 모든 사용자가 페이지를 처음 방문할 때마다 데이터베이스에서 데이터를 검색 해야 하며, 뷰 상태가 사용 하지 않도록 설정 된 경우에는 모든 사용자가 다시 게시할 때마다 데이터를 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-232">Even if the GridView does not provide sorting and paging support, the data must be retrieved from the database each time the page is first visited by any user (and on every postback, if view state is disabled).</span></span> <span data-ttu-id="e46fc-233">그러나 GridView가 모든 사용자에 게 동일한 데이터를 표시 하는 경우 이러한 추가 데이터베이스 요청은 불필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-233">But if the GridView is showing the same data to all users, these extra database requests are superfluous.</span></span> <span data-ttu-id="e46fc-234">`GetProducts()` 메서드에서 반환 된 결과를 캐시 하지 않고 GridView를 해당 캐시 된 결과에 바인딩 하는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="e46fc-234">Why not cache the results returned from the `GetProducts()` method and bind the GridView to those cached results?</span></span>

## <a name="step-4-caching-the-data-using-the-objectdatasource"></a><span data-ttu-id="e46fc-235">4 단계: ObjectDataSource를 사용 하 여 데이터 캐싱</span><span class="sxs-lookup"><span data-stu-id="e46fc-235">Step 4: Caching the Data Using the ObjectDataSource</span></span>

<span data-ttu-id="e46fc-236">몇 가지 속성만 설정 하면 ASP.NET 데이터 캐시에 검색 된 데이터를 자동으로 캐시 하도록 ObjectDataSource를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-236">By simply setting a few properties, the ObjectDataSource can be configured to automatically cache its retrieved data in the ASP.NET data cache.</span></span> <span data-ttu-id="e46fc-237">다음 목록에는 ObjectDataSource의 캐시 관련 속성이 요약 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-237">The following list summarizes the cache-related properties of the ObjectDataSource:</span></span>

- <span data-ttu-id="e46fc-238">캐싱을 사용 하려면 `true` [EnableCaching](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.enablecaching.aspx) 로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-238">[EnableCaching](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.enablecaching.aspx) must be set to `true` to enable caching.</span></span> <span data-ttu-id="e46fc-239">기본값은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-239">The default is `false`.</span></span>
- <span data-ttu-id="e46fc-240">[CacheDuration](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheduration.aspx) 데이터를 캐시 하는 시간 (초)입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-240">[CacheDuration](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheduration.aspx) the amount of time, in seconds, that the data is cached.</span></span> <span data-ttu-id="e46fc-241">기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-241">The default is 0.</span></span> <span data-ttu-id="e46fc-242">ObjectDataSource는 `EnableCaching` `true` 되 고 `CacheDuration` 0 보다 큰 값으로 설정 된 경우에만 데이터를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-242">The ObjectDataSource will only cache data if `EnableCaching` is `true` and `CacheDuration` is set to a value greater than zero.</span></span>
- <span data-ttu-id="e46fc-243">[CacheExpirationPolicy](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheexpirationpolicy.aspx) 은 `Absolute` 또는 `Sliding`로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-243">[CacheExpirationPolicy](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheexpirationpolicy.aspx) can be set to `Absolute` or `Sliding`.</span></span> <span data-ttu-id="e46fc-244">`Absolute`경우 ObjectDataSource는 `CacheDuration` 초 동안 검색 된 데이터를 캐시 합니다. `Sliding`경우 데이터는 `CacheDuration` 초 동안 액세스 되지 않은 후에만 만료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-244">If `Absolute`, the ObjectDataSource caches its retrieved data for `CacheDuration` seconds; if `Sliding`, the data expires only after it has not been accessed for `CacheDuration` seconds.</span></span> <span data-ttu-id="e46fc-245">기본값은 `Absolute`입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-245">The default is `Absolute`.</span></span>
- <span data-ttu-id="e46fc-246">[Cachekeydependency](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cachekeydependency.aspx) 이 속성을 사용 하 여 ObjectDataSource s 캐시 항목을 기존 캐시 종속성에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-246">[CacheKeyDependency](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cachekeydependency.aspx) use this property to associate the ObjectDataSource s cache entries with an existing cache dependency.</span></span> <span data-ttu-id="e46fc-247">ObjectDataSource s 데이터 항목은 연결 된 `CacheKeyDependency`를 만료 시켜 캐시에서 중간에 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-247">The ObjectDataSource s data entries can be prematurely evicted from the cache by expiring its associated `CacheKeyDependency`.</span></span> <span data-ttu-id="e46fc-248">이 속성은 sql 캐시 종속성을 ObjectDataSource s 캐시와 연결 하는 데 가장 일반적으로 사용 됩니다. [Sql 캐시 종속성 자습서를 사용 하 여](using-sql-cache-dependencies-cs.md) 나중에 살펴볼 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-248">This property is most commonly used to associate a SQL cache dependency with the ObjectDataSource s cache, a topic we'll explore in the future [Using SQL Cache Dependencies](using-sql-cache-dependencies-cs.md) tutorial.</span></span>

<span data-ttu-id="e46fc-249">에서 `ProductsDataSource` ObjectDataSource를 구성 하 여 해당 데이터를 30 초 동안 절대 크기로 캐시 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-249">Let s configure the `ProductsDataSource` ObjectDataSource to cache its data for 30 seconds on an absolute scale.</span></span> <span data-ttu-id="e46fc-250">ObjectDataSource s `EnableCaching` 속성을 `true`로 설정 하 고 `CacheDuration` 속성을 30으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-250">Set the ObjectDataSource s `EnableCaching` property to `true` and its `CacheDuration` property to 30.</span></span> <span data-ttu-id="e46fc-251">`CacheExpirationPolicy` 속성을 기본값인 `Absolute`으로 설정 된 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-251">Leave the `CacheExpirationPolicy` property set to its default, `Absolute`.</span></span>

<span data-ttu-id="e46fc-252">[데이터를 30 초로 캐시 하도록 ObjectDataSource를 구성 ![](caching-data-with-the-objectdatasource-cs/_static/image28.png)](caching-data-with-the-objectdatasource-cs/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="e46fc-252">[![Configure the ObjectDataSource to Cache its Data for 30 Seconds](caching-data-with-the-objectdatasource-cs/_static/image28.png)](caching-data-with-the-objectdatasource-cs/_static/image27.png)</span></span>

<span data-ttu-id="e46fc-253">**그림 11**: 데이터를 30 초로 캐시 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](caching-data-with-the-objectdatasource-cs/_static/image29.png))</span><span class="sxs-lookup"><span data-stu-id="e46fc-253">**Figure 11**: Configure the ObjectDataSource to Cache its Data for 30 Seconds ([Click to view full-size image](caching-data-with-the-objectdatasource-cs/_static/image29.png))</span></span>

<span data-ttu-id="e46fc-254">변경 내용을 저장 하 고 브라우저에서이 페이지를 다시 방문 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-254">Save your changes and revisit this page in a browser.</span></span> <span data-ttu-id="e46fc-255">처음으로 페이지를 방문할 때 데이터가 캐시에 없기 때문에 발생 한 이벤트 선택 텍스트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-255">The Selecting event fired text will appear when you first visit the page, as initially the data is not in the cache.</span></span> <span data-ttu-id="e46fc-256">그러나 다시 게시 단추를 클릭 하거나, 페이지를 정렬 하거나, 편집 또는 취소 단추를 클릭 하 여 트리거하는 이후 포스트백은 발생 하는 이벤트 발생 텍스트를 다시 표시 *하지* 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-256">But subsequent postbacks triggered by clicking the Postback button, sorting, paging, or clicking the Edit or Cancel buttons does *not* redisplay the Selecting event fired text.</span></span> <span data-ttu-id="e46fc-257">이는 ObjectDataSource가 기본 개체에서 데이터를 가져오는 경우에만 `Selecting` 이벤트가 발생 하기 때문입니다. 데이터를 데이터 캐시에서 끌어올 경우 `Selecting` 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-257">This is because the `Selecting` event only fires when the ObjectDataSource gets its data from its underlying object; the `Selecting` event does not fire if the data is pulled from the data cache.</span></span>

<span data-ttu-id="e46fc-258">30 초 후에는 캐시에서 데이터가 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-258">After 30 seconds, the data will be evicted from the cache.</span></span> <span data-ttu-id="e46fc-259">ObjectDataSource s `Insert`, `Update`또는 `Delete` 메서드를 호출 하는 경우에도 캐시에서 데이터가 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-259">The data will also be evicted from the cache if the ObjectDataSource s `Insert`, `Update`, or `Delete` methods are invoked.</span></span> <span data-ttu-id="e46fc-260">따라서 30 초가 경과 하거나 업데이트 단추를 클릭 하 여 정렬, 페이징 또는 편집 또는 취소 단추를 클릭 하면 ObjectDataSource가 기본 개체에서 데이터를 가져오고 `Selecting` 이벤트가 발생할 때 발생 하는 이벤트 선택 텍스트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-260">Consequently, after 30 seconds have passed or the Update button has been clicked, sorting, paging, or clicking the Edit or Cancel buttons will cause the ObjectDataSource to get its data from its underlying object, displaying the Selecting event fired text when the `Selecting` event fires.</span></span> <span data-ttu-id="e46fc-261">반환 된 결과는 데이터 캐시에 다시 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-261">These returned results are placed back into the data cache.</span></span>

> [!NOTE]
> <span data-ttu-id="e46fc-262">ObjectDataSource가 캐시 된 데이터와 함께 작동 하는 경우에도 이벤트가 자주 발생 하는 텍스트를 자주 선택 하는 것이 확인 되 면 메모리 제약 조건 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-262">If you see the Selecting event fired text frequently, even when you expect the ObjectDataSource to be working with cached data, it may be due to memory constraints.</span></span> <span data-ttu-id="e46fc-263">사용 가능한 메모리가 충분 하지 않은 경우 ObjectDataSource에 의해 캐시에 추가 된 데이터가 청소 되었을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-263">If there is not enough free memory, the data added to the cache by the ObjectDataSource may have been scavenged.</span></span> <span data-ttu-id="e46fc-264">ObjectDataSource가 데이터를 올바르게 캐시 하거나 데이터를 산발적으로 캐시 하지 않는 것으로 나타나는 경우 일부 응용 프로그램을 닫아 메모리를 확보 한 다음 다시 시도 하십시오.</span><span class="sxs-lookup"><span data-stu-id="e46fc-264">If the ObjectDataSource doesn t appear to be correctly caching the data or only caches the data sporadically, close some applications to free memory and try again.</span></span>

<span data-ttu-id="e46fc-265">그림 12에서는 ObjectDataSource s 캐싱 워크플로를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-265">Figure 12 illustrates the ObjectDataSource s caching workflow.</span></span> <span data-ttu-id="e46fc-266">발생 한 이벤트 선택 텍스트가 화면에 표시 되 면 데이터가 캐시에 없고 원본 개체에서 검색 되어야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-266">When the Selecting event fired text appears on your screen, it is because the data was not in the cache and had to be retrieved from the underlying object.</span></span> <span data-ttu-id="e46fc-267">그러나이 텍스트가 없으면 캐시에서 데이터를 사용할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-267">When this text is missing, however, it s because the data was available from the cache.</span></span> <span data-ttu-id="e46fc-268">캐시에서 데이터가 반환 될 때 원본 개체에 대 한 호출이 없으므로 데이터베이스 쿼리가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-268">When the data is returned from the cache there s no call to the underlying object and, therefore, no database query executed.</span></span>

![ObjectDataSource는 데이터 캐시에서 해당 데이터를 저장 하 고 검색 합니다.](caching-data-with-the-objectdatasource-cs/_static/image30.png)

<span data-ttu-id="e46fc-270">**그림 12**: ObjectDataSource는 데이터 캐시에서 데이터를 저장 하 고 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-270">**Figure 12**: The ObjectDataSource Stores and Retrieves its Data from the Data Cache</span></span>

<span data-ttu-id="e46fc-271">각 ASP.NET 응용 프로그램에는 모든 페이지와 방문자에서 공유 하는 자체 데이터 캐시 인스턴스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-271">Each ASP.NET application has its own data cache instance that s shared across all pages and visitors.</span></span> <span data-ttu-id="e46fc-272">즉, ObjectDataSource에 의해 데이터 캐시에 저장 된 데이터는 페이지를 방문 하는 모든 사용자에 게 공유 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-272">That means that the data stored in the data cache by the ObjectDataSource is likewise shared across all users who visit the page.</span></span> <span data-ttu-id="e46fc-273">이를 확인 하려면 브라우저에서 `ObjectDataSource.aspx` 페이지를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-273">To verify this, open the `ObjectDataSource.aspx` page in a browser.</span></span> <span data-ttu-id="e46fc-274">페이지를 처음 방문 하면 이전 테스트에 의해 캐시에 추가 된 데이터가 이미 제거 된 것으로 가정 하 여 이벤트가 발생 한 선택 텍스트가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-274">When first visiting the page, the Selecting event fired text will appear (assuming that the data added to the cache by previous tests has, by now, been evicted).</span></span> <span data-ttu-id="e46fc-275">두 번째 브라우저 인스턴스를 열고 URL을 복사 하 여 첫 번째 브라우저 인스턴스에 복사 하 여 붙여넣습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-275">Open a second browser instance and copy and paste the URL from the first browser instance to the second.</span></span> <span data-ttu-id="e46fc-276">두 번째 브라우저 인스턴스에서는 첫 번째 이벤트와 동일한 캐시 된 데이터를 사용 하기 때문에 발생 한 이벤트 선택 텍스트가 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-276">In the second browser instance, the Selecting event fired text is not shown because it s using the same cached data as the first.</span></span>

<span data-ttu-id="e46fc-277">검색 된 데이터를 캐시에 삽입할 때 ObjectDataSource는 `CacheDuration` 및 `CacheExpirationPolicy` 속성 값을 포함 하는 캐시 키 값을 사용 합니다. ObjectDataSource에서 사용 되는 기본 비즈니스 개체의 형식입니다 .이 형식은 [`TypeName` 속성](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.typename.aspx) (이 예제에서는`ProductsBLL`)을 통해 지정 됩니다. `SelectMethod` 속성의 값과 `SelectParameters` 컬렉션에 있는 매개 변수의 이름 및 값입니다. [사용자 지정 페이징을](../paging-and-sorting/paging-and-sorting-report-data-cs.md) 구현할 때 사용 되는 `StartRowIndex` 및 `MaximumRows` 속성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-277">When inserting its retrieved data into the cache, the ObjectDataSource uses a cache key value that includes: the `CacheDuration` and `CacheExpirationPolicy` property values; the type of the underlying business object being used by the ObjectDataSource, which is specified via the [`TypeName` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.typename.aspx) (`ProductsBLL`, in this example); the value of the `SelectMethod` property and the name and values of the parameters in the `SelectParameters` collection; and the values of its `StartRowIndex` and `MaximumRows` properties, which are used when implementing [custom paging.](../paging-and-sorting/paging-and-sorting-report-data-cs.md)</span></span>

<span data-ttu-id="e46fc-278">이러한 속성을 조합 하 여 캐시 키 값을 사용 하면 이러한 값이 변경 될 때 고유한 캐시 항목이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-278">Crafting the cache key value as a combination of these properties ensures a unique cache entry as these values change.</span></span> <span data-ttu-id="e46fc-279">예를 들어 이전 자습서에서는 지정 된 범주에 대 한 모든 제품을 반환 하는 `ProductsBLL` 클래스 `GetProductsByCategoryID(categoryID)`를 사용 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-279">For example, in past tutorials we ve looked at using the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)`, which returns all products for a specified category.</span></span> <span data-ttu-id="e46fc-280">한 명의 사용자가 페이지로 이동 하 여 `CategoryID` 1 인 음료를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-280">One user might come to the page and view beverages, which has a `CategoryID` of 1.</span></span> <span data-ttu-id="e46fc-281">ObjectDataSource가 캐시에 있는 동안 다른 사용자가 조미료를 볼 수 있도록 해당 `SelectParameters` 결과를 캐시 하는 경우에는 다른 사용자가를 볼 때 조미료 보다는 캐시 된 음료 제품을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-281">If the ObjectDataSource cached its results without regard for the `SelectParameters` values, when another user came to the page to view condiments while the beverages products were in the cache, they d see the cached beverage products rather than condiments.</span></span> <span data-ttu-id="e46fc-282">`SelectParameters`값을 포함 하는 이러한 속성에 의해 캐시 키를 변경 하 여 ObjectDataSource는 음료와 조미료에 대 한 별도의 캐시 항목을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-282">By varying the cache key by these properties, which include the values of the `SelectParameters`, the ObjectDataSource maintains a separate cache entry for beverages and condiments.</span></span>

## <a name="stale-data-concerns"></a><span data-ttu-id="e46fc-283">부실 데이터 문제</span><span class="sxs-lookup"><span data-stu-id="e46fc-283">Stale Data Concerns</span></span>

<span data-ttu-id="e46fc-284">ObjectDataSource는 `Insert`, `Update`또는 `Delete` 메서드 중 하나가 호출 될 때 캐시에서 해당 항목을 자동으로 임의로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-284">The ObjectDataSource automatically evicts its items from the cache when any one of its `Insert`, `Update`, or `Delete` methods is invoked.</span></span> <span data-ttu-id="e46fc-285">이렇게 하면 페이지를 통해 데이터를 수정할 때 캐시 엔트리를 지워 부실 데이터를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-285">This helps protect against stale data by clearing out the cache entries when the data is modified through the page.</span></span> <span data-ttu-id="e46fc-286">그러나 캐시를 사용 하 여 오래 된 데이터를 표시 하는 경우에도 ObjectDataSource를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-286">However, it is possible for an ObjectDataSource using caching to still display stale data.</span></span> <span data-ttu-id="e46fc-287">가장 간단한 경우는 데이터베이스에서 직접 데이터를 변경 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-287">In the simplest case, it can be due to the data changing directly within the database.</span></span> <span data-ttu-id="e46fc-288">아마도 데이터베이스 관리자는 데이터베이스의 일부 레코드를 수정 하는 스크립트를 실행 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-288">Perhaps a database administrator just ran a script that modifies some of the records in the database.</span></span>

<span data-ttu-id="e46fc-289">이 시나리오는 보다 미묘한 방법으로 펼침 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-289">This scenario could also unfold in a more subtle way.</span></span> <span data-ttu-id="e46fc-290">ObjectDataSource는 데이터 수정 메서드 중 하나를 호출할 때 캐시에서 해당 항목을 임의로 하 고, 제거 된 항목은 속성 값의 ObjectDataSource s 특정 조합 (`CacheDuration`, `TypeName`, `SelectMethod`등)을 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-290">While the ObjectDataSource evicts its items from the cache when one of its data modification methods is called, the cached items removed are for the ObjectDataSource s particular combination of property values (`CacheDuration`, `TypeName`, `SelectMethod`, and so on).</span></span> <span data-ttu-id="e46fc-291">다른 `SelectMethods` 또는 `SelectParameters`를 사용 하는 두 개의 ObjectDataSources 원본이 있지만 동일한 데이터를 계속 업데이트할 수 있는 경우 하나의 ObjectDataSource에서 행을 업데이트 하 고 자체 캐시 항목을 무효화할 수 있지만 두 번째 ObjectDataSource의 해당 행은 캐시 된에서 계속 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-291">If you have two ObjectDataSources that use different `SelectMethods` or `SelectParameters`, but still can update the same data, then one ObjectDataSource may update a row and invalidate its own cache entries, but the corresponding row for the second ObjectDataSource will still be served from the cached.</span></span> <span data-ttu-id="e46fc-292">이 기능을 표시 하는 페이지를 만들 것을 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-292">I encourage you to create pages to exhibit this functionality.</span></span> <span data-ttu-id="e46fc-293">캐싱을 사용 하 고 `ProductsBLL` 클래스 s `GetProducts()` 메서드에서 데이터를 가져오도록 구성 된 ObjectDataSource에서 데이터를 가져오는 편집 가능한 GridView를 표시 하는 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-293">Create a page that displays an editable GridView that pulls its data from an ObjectDataSource that uses caching and is configured to get data from the `ProductsBLL` class s `GetProducts()` method.</span></span> <span data-ttu-id="e46fc-294">이 페이지에 편집 가능한 GridView 및 ObjectDataSource를 추가 합니다. 그러나이 두 번째 ObjectDataSource에는 `GetProductsByCategoryID(categoryID)` 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-294">Add another editable GridView and ObjectDataSource to this page (or another one), but for this second ObjectDataSource have it use the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="e46fc-295">두 ObjectDataSources 원본 `SelectMethod` 속성이 다르기 때문에 각 데이터 원본에는 고유한 캐시 된 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-295">Since the two ObjectDataSources `SelectMethod` properties differ, they ll each have their own cached values.</span></span> <span data-ttu-id="e46fc-296">한 표에서 제품을 편집 하는 경우 다음에 데이터를 다른 그리드 (페이징, 정렬 등)로 다시 바인딩할 때는 이전에 캐시 된 데이터를 계속 제공 하 고 다른 그리드에서 수행한 변경 내용을 반영 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-296">If you edit a product in one grid, the next time you bind the data back to the other grid (by paging, sorting, and so forth), it will still serve the old, cached data and not reflect the change that was made from the other grid.</span></span>

<span data-ttu-id="e46fc-297">즉, 오래 된 데이터를 사용할 수 있는 경우에만 시간 기반 expiries을 사용 하 고, 데이터의 새로 고침은 중요 한 시나리오에 짧은 expiries를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-297">In short, only use time-based expiries if you are willing to have the potential of stale data, and use shorter expiries for scenarios where the freshness of data is important.</span></span> <span data-ttu-id="e46fc-298">부실 데이터를 사용할 수 없는 경우은 선형화 캐싱을 사용 하거나 SQL 캐시 종속성을 사용 합니다 (다시 캐싱이 되는 데이터베이스 데이터 라고 가정).</span><span class="sxs-lookup"><span data-stu-id="e46fc-298">If stale data is not acceptable, either forgo caching or use SQL cache dependencies (assuming it is database data you re caching).</span></span> <span data-ttu-id="e46fc-299">이후 자습서에서 SQL 캐시 종속성을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-299">We'll explore SQL cache dependencies in a future tutorial.</span></span>

## <a name="summary"></a><span data-ttu-id="e46fc-300">요약</span><span class="sxs-lookup"><span data-stu-id="e46fc-300">Summary</span></span>

<span data-ttu-id="e46fc-301">이 자습서에서는 ObjectDataSource s 기본 제공 캐싱 기능을 검사 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-301">In this tutorial we examined the ObjectDataSource s built-in caching capabilities.</span></span> <span data-ttu-id="e46fc-302">몇 가지 속성만 설정 하면 지정 된 `SelectMethod`에서 반환 된 결과를 ASP.NET 데이터 캐시로 캐시 하도록 ObjectDataSource에 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-302">By simply setting a few properties, we can instruct the ObjectDataSource to cache the results returned from the specified `SelectMethod` into the ASP.NET data cache.</span></span> <span data-ttu-id="e46fc-303">`CacheDuration` 및 `CacheExpirationPolicy` 속성은 항목이 캐시 되는 기간과 절대 또는 슬라이딩 만료 인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-303">The `CacheDuration` and `CacheExpirationPolicy` properties indicate the duration the item is cached and whether it is an absolute or sliding expiration.</span></span> <span data-ttu-id="e46fc-304">`CacheKeyDependency` 속성은 모든 ObjectDataSource s 캐시 항목을 기존 캐시 종속성에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-304">The `CacheKeyDependency` property associates all of the ObjectDataSource s cache entries with an existing cache dependency.</span></span> <span data-ttu-id="e46fc-305">이는 시간 기반 만료에 도달 하기 전에 캐시에서 ObjectDataSource 항목을 제거 하는 데 사용할 수 있으며 일반적으로 SQL 캐시 종속성과 함께 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-305">This can be used to evict the ObjectDataSource s entries from the cache before the time-based expiration is reached, and is typically used with SQL cache dependencies.</span></span>

<span data-ttu-id="e46fc-306">ObjectDataSource는 단순히 데이터 캐시에 값을 캐시 하므로 ObjectDataSource의 기본 제공 기능을 프로그래밍 방식으로 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-306">Since the ObjectDataSource simply caches its values to the data cache, we could replicate the ObjectDataSource s built-in functionality programmatically.</span></span> <span data-ttu-id="e46fc-307">ObjectDataSource는이 기능을 즉시 제공 하므로 프레젠테이션 계층에서이 작업을 수행 하는 것은 적합 하지 않지만 별도의 아키텍처 계층에서 캐싱 기능을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-307">It doesn t make sense to do this at the Presentation Layer, since the ObjectDataSource offers this functionality out of the box, but we can implement caching capabilities in a separate layer of the architecture.</span></span> <span data-ttu-id="e46fc-308">이렇게 하려면 ObjectDataSource에서 사용 하는 것과 동일한 논리를 반복 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-308">To do so, we'll need to repeat the same logic used by the ObjectDataSource.</span></span> <span data-ttu-id="e46fc-309">다음 자습서의 아키텍처 내에서 프로그래밍 방식으로 데이터 캐시를 사용 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-309">We'll explore how to programmatically work with the data cache from within the architecture in our next tutorial.</span></span>

<span data-ttu-id="e46fc-310">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="e46fc-310">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="e46fc-311">추가 참고 자료</span><span class="sxs-lookup"><span data-stu-id="e46fc-311">Further Reading</span></span>

<span data-ttu-id="e46fc-312">이 자습서에서 설명 하는 항목에 대 한 자세한 내용은 다음 리소스를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e46fc-312">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="e46fc-313">ASP.NET 캐싱: 기술 및 모범 사례</span><span class="sxs-lookup"><span data-stu-id="e46fc-313">ASP.NET Caching: Techniques and Best Practices</span></span>](https://msdn.microsoft.com/library/aa478965.aspx)
- [<span data-ttu-id="e46fc-314">.NET Framework 응용 프로그램에 대 한 캐싱 아키텍처 가이드</span><span class="sxs-lookup"><span data-stu-id="e46fc-314">Caching Architecture Guide for .NET Framework Applications</span></span>](https://msdn.microsoft.com/library/ee817645.aspx)
- [<span data-ttu-id="e46fc-315">ASP.NET 2.0의 출력 캐싱</span><span class="sxs-lookup"><span data-stu-id="e46fc-315">Output Caching in ASP.NET 2.0</span></span>](http://aspnet.4guysfromrolla.com/articles/121306-1.aspx)

## <a name="about-the-author"></a><span data-ttu-id="e46fc-316">저자 정보</span><span class="sxs-lookup"><span data-stu-id="e46fc-316">About the Author</span></span>

<span data-ttu-id="e46fc-317">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-317">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e46fc-318">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-318">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e46fc-319">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-319">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="e46fc-320">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="e46fc-320">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="e46fc-321">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-321">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="e46fc-322">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-322">Special Thanks To</span></span>

<span data-ttu-id="e46fc-323">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-323">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="e46fc-324">이 자습서의 리드 검토자는 Teresa Murphy입니다.</span><span class="sxs-lookup"><span data-stu-id="e46fc-324">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="e46fc-325">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="e46fc-325">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="e46fc-326">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="e46fc-326">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="e46fc-327">다음</span><span class="sxs-lookup"><span data-stu-id="e46fc-327">Next</span></span>](caching-data-in-the-architecture-cs.md)
