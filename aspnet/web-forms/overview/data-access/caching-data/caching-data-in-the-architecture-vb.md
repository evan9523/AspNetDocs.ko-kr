---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: 아키텍처에서 데이터 캐싱 (VB) | Microsoft Docs
author: rick-anderson
description: 이전 자습서에서는 프레젠테이션 계층에서 캐싱을 적용 하는 방법을 알아보았습니다. 이 자습서에서는 계층화 된 architectu을 활용 하는 방법에 대해 알아봅니다.
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: dc991a205fa7e61f604bc0f26e9b24b3faefd3d3
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/28/2019
ms.locfileid: "74607472"
---
# <a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="4f12e-104">아키텍처에서 데이터 캐싱(VB)</span><span class="sxs-lookup"><span data-stu-id="4f12e-104">Caching Data in the Architecture (VB)</span></span>

<span data-ttu-id="4f12e-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="4f12e-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="4f12e-106">[샘플 앱 다운로드](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) 또는 [PDF 다운로드](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="4f12e-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="4f12e-107">이전 자습서에서는 프레젠테이션 계층에서 캐싱을 적용 하는 방법을 알아보았습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="4f12e-108">이 자습서에서는 계층 아키텍처를 활용 하 여 비즈니스 논리 계층에서 데이터를 캐시 하는 방법에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="4f12e-109">캐싱 계층을 포함 하도록 아키텍처를 확장 하 여이 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-109">We do this by extending the architecture to include a Caching Layer.</span></span>

## <a name="introduction"></a><span data-ttu-id="4f12e-110">소개</span><span class="sxs-lookup"><span data-stu-id="4f12e-110">Introduction</span></span>

<span data-ttu-id="4f12e-111">이전 자습서에서 살펴본 것 처럼 ObjectDataSource s 데이터를 캐시 하는 것은 몇 가지 속성을 설정 하는 것 만큼 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="4f12e-112">아쉽게도 ObjectDataSource는 캐싱 정책을 ASP.NET 페이지와 긴밀 하 게 결합 프레젠테이션 계층에서 캐싱을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="4f12e-113">계층화 된 아키텍처를 만드는 이유 중 하나는 이러한 couplings의 중단을 허용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="4f12e-114">예를 들어 비즈니스 논리 계층은 ASP.NET 페이지에서 비즈니스 논리를 분리 데이터 액세스 계층은 데이터 액세스 정보를 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="4f12e-115">이러한 비즈니스 논리 및 데이터 액세스 세부 정보 분리는 시스템을 보다 쉽게 읽고 유지 관리할 수 있으며 유연 하 게 변경할 수 있기 때문에 매우 선호 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="4f12e-116">또한 도메인 정보를 허용 하 고 프레젠테이션 계층에서 작업 하는 개발자가 작업을 수행 하기 위해 데이터베이스 세부 정보를 잘 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="4f12e-117">프레젠테이션 계층에서 캐싱 정책을 분리 하면 비슷한 이점이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="4f12e-118">이 자습서에서는 캐싱 정책을 활용 하는 *캐싱 계층* (또는 SHORT 용 CL)을 포함 하도록 아키텍처를 보강 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="4f12e-119">캐싱 계층에는 `GetProducts()`, `GetProductsByCategoryID(categoryID)`등의 메서드를 사용 하 여 제품 정보에 대 한 액세스를 제공 하는 `ProductsCL` 클래스가 포함 됩니다 .이 클래스를 호출 하면 먼저 캐시에서 데이터를 검색 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="4f12e-120">캐시가 비어 있으면 이러한 메서드는 BLL에서 적절 한 `ProductsBLL` 메서드를 호출 하 여 DAL에서 데이터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="4f12e-121">`ProductsCL` 메서드는 반환 하기 전에 BLL에서 검색 된 데이터를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="4f12e-122">그림 1에 나와 있는 것 처럼 CL은 프레젠테이션과 비즈니스 논리 계층 사이에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>

![CL (캐싱 계층)은 아키텍처의 또 다른 계층입니다.](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="4f12e-124">**그림 1**: 아키텍처의 또 다른 계층을 위한 캐싱 계층 (CL)</span><span class="sxs-lookup"><span data-stu-id="4f12e-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>

## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="4f12e-125">1 단계: 캐싱 계층 클래스 만들기</span><span class="sxs-lookup"><span data-stu-id="4f12e-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="4f12e-126">이 자습서에서는 몇 가지 메서드만 있는 `ProductsCL` 단일 클래스를 사용 하 여 매우 간단한 CL을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="4f12e-127">전체 응용 프로그램에 대 한 완전 한 캐싱 계층을 빌드하려면 `CategoriesCL`, `EmployeesCL`및 `SuppliersCL` 클래스를 만들고 BLL의 각 데이터 액세스 또는 수정 메서드에 대해 이러한 캐싱 계층 클래스에서 메서드를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="4f12e-128">BLL 및 DAL과 마찬가지로 캐싱 계층은 별도의 클래스 라이브러리 프로젝트로 구현 하는 것이 가장 좋습니다. 그러나 `App_Code` 폴더에서 클래스로 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="4f12e-129">DAL 및 BLL 클래스에서 CL 클래스를 보다 명확 하 게 구분 하려면 `App_Code` 폴더에 새 하위 폴더를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="4f12e-130">솔루션 탐색기에서 `App_Code` 폴더를 마우스 오른쪽 단추로 클릭 하 고 새 폴더를 선택한 다음 새 폴더의 이름을 `CL`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="4f12e-131">이 폴더를 만든 후 `ProductsCL.vb`이라는 새 클래스를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>

![CL 이라는 새 폴더와 이름으로 이름이 지정 된 클래스를 추가 합니다.](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="4f12e-133">**그림 2**: `CL` 이라는 새 폴더 및 라는 클래스를 추가 `ProductsCL.vb`</span><span class="sxs-lookup"><span data-stu-id="4f12e-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>

<span data-ttu-id="4f12e-134">`ProductsCL` 클래스는 해당 하는 비즈니스 논리 계층 클래스 (`ProductsBLL`)에 있는 것과 동일한 데이터 액세스 및 수정 메서드 집합을 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="4f12e-135">이러한 메서드를 모두 생성 하는 대신, CL에서 사용 되는 패턴에 대 한 느낌을 얻기 위해 여기에 몇 가지를 작성해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="4f12e-136">특히 3 단계의 `GetProducts()` 및 `GetProductsByCategoryID(categoryID)` 메서드와 4 단계에서 `UpdateProduct` 오버 로드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="4f12e-137">레저에 나머지 `ProductsCL` 메서드와 `CategoriesCL`, `EmployeesCL`및 `SuppliersCL` 클래스를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="4f12e-138">2 단계: 데이터 캐시 읽기 및 쓰기</span><span class="sxs-lookup"><span data-stu-id="4f12e-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="4f12e-139">이전 자습서에서 살펴본 ObjectDataSource 캐싱 기능은 내부적으로 ASP.NET 데이터 캐시를 사용 하 여 BLL에서 검색 된 데이터를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="4f12e-140">ASP.NET pages 코드 숨겨진 클래스 또는 웹 응용 프로그램 아키텍처의 클래스에서 프로그래밍 방식으로 데이터 캐시에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="4f12e-141">ASP.NET page s의 코드 숨김으로 된 클래스에서 데이터 캐시를 읽고 쓰려면 다음 패턴을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="4f12e-142">[`Cache` 클래스](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) [`Insert` 메서드에](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) 는 많은 오버 로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="4f12e-143">`Cache("key") = value` 및 `Cache.Insert(key, value)`는 동의어 이며 정의 된 만료 없이 지정 된 키를 사용 하 여 캐시에 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="4f12e-144">일반적으로 캐시에 항목을 추가할 때 종속성, 시간 기반 만료 중 하나 또는 둘 다로 만료를 지정 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="4f12e-145">다른 `Insert` 메서드의 오버 로드 중 하나를 사용 하 여 종속성 또는 시간 기반 만료 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="4f12e-146">캐싱 계층의 메서드는 먼저 요청 된 데이터가 캐시에 있는지 확인 하 고, 필요한 경우 여기에서 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="4f12e-147">요청 된 데이터가 캐시에 없으면 적절 한 BLL 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="4f12e-148">다음 시퀀스 다이어그램에서 보여 주는 것 처럼 반환 값을 캐시 한 후 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>

![캐싱 계층의 메서드는 캐시에서 데이터를 반환 합니다 (사용 가능한 경우).](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="4f12e-150">**그림 3**: 캐싱 계층의 메서드를 사용할 수 있는 경우 캐시에서 데이터 반환</span><span class="sxs-lookup"><span data-stu-id="4f12e-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>

<span data-ttu-id="4f12e-151">그림 3에 표시 된 시퀀스는 다음과 같은 패턴을 사용 하 여 CL 클래스에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="4f12e-152">여기서는 `Northwind.ProductsDataTable`캐시에 저장 되는 데이터의 *형식입니다. 예를 들어* *key* 는 캐시 항목을 고유 하 게 식별 하는 키입니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="4f12e-153">지정 된 *키* 를 가진 항목이 캐시에 없으면 *인스턴스가* `Nothing` 되며 적절 한 BLL 메서드에서 데이터가 검색 되어 캐시에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="4f12e-154">`Return instance`에 도달 하면 *인스턴스* 는 캐시에서 또는 BLL에서 가져온 데이터에 대 한 참조를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="4f12e-155">캐시에서 데이터에 액세스할 때 위의 패턴을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="4f12e-156">처음에는 동일 하 게 보이는 다음 패턴은 경합 상태를 소개 하는 미묘한 차이를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="4f12e-157">경합 상태는 산발적으로 노출 되 고 재현 하기 어렵기 때문에 디버깅 하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="4f12e-158">이 두 번째 코드 조각에서는 캐시 된 항목에 대 한 참조를 지역 변수에 저장 하는 대신, 조건문 *과* `Return`에서 직접 데이터 캐시에 액세스할 수 있다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="4f12e-159">이 코드에 도달 하면 `Cache("key")` `Nothing`되지 않지만 `Return` 문에 도달 하기 전에 캐시에서 system 임의로 *키* 를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="4f12e-160">드문 경우 지만 코드에서 필요한 형식의 개체가 아닌 `Nothing`을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="4f12e-161">데이터 캐시는 스레드로부터 안전 하므로 단순 읽기 또는 쓰기를 위해 스레드 액세스를 동기화 할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="4f12e-162">그러나 원자성 이어야 하는 캐시의 데이터에 대해 여러 작업을 수행 해야 하는 경우에는 스레드 안전을 보장 하기 위해 잠금 또는 다른 메커니즘을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="4f12e-163">자세한 내용은 [ASP.NET Cache에 대 한 액세스 동기화를](http://www.ddj.com/184406369) 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4f12e-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>

<span data-ttu-id="4f12e-164">다음과 같이 [`Remove` 메서드](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) 를 사용 하 여 프로그래밍 방식으로 데이터 캐시에서 항목을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="4f12e-165">3 단계:`ProductsCL`클래스에서 제품 정보 반환</span><span class="sxs-lookup"><span data-stu-id="4f12e-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="4f12e-166">이 자습서에서는 `GetProducts()` 및 `GetProductsByCategoryID(categoryID)``ProductsCL` 클래스에서 제품 정보를 반환 하는 두 가지 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="4f12e-167">비즈니스 논리 계층의 `ProductsBL` 클래스와 마찬가지로, CL의 `GetProducts()` 메서드는 모든 제품에 대 한 정보를 `Northwind.ProductsDataTable` 개체로 반환 하는 반면 `GetProductsByCategoryID(categoryID)`는 지정 된 범주의 모든 제품을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="4f12e-168">다음 코드는 `ProductsCL` 클래스의 메서드 일부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="4f12e-169">먼저 클래스 및 메서드에 적용 된 `DataObject` 및 `DataObjectMethodAttribute` 특성을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="4f12e-170">이러한 특성은 마법사의 단계에 표시 되어야 하는 클래스 및 메서드를 나타내는 정보를 ObjectDataSource s 마법사에 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="4f12e-171">CL 클래스와 메서드는 프레젠테이션 계층의 ObjectDataSource에서 액세스 되므로 디자인 타임 환경을 향상 시키기 위해 이러한 특성을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="4f12e-172">이러한 특성 및 해당 효과에 대 한 자세한 설명은 [비즈니스 논리 계층 만들기](../introduction/creating-a-business-logic-layer-vb.md) 자습서를 다시 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4f12e-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="4f12e-173">`GetProducts()` 및 `GetProductsByCategoryID(categoryID)` 메서드에서는 `GetCacheItem(key)` 메서드에서 반환 되는 데이터가 지역 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="4f12e-174">잠시 후에 검사할 `GetCacheItem(key)` 메서드는 지정 된 *키*를 기준으로 캐시에서 특정 항목을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="4f12e-175">이러한 데이터를 캐시에서 찾을 수 없으면 해당 `ProductsBLL` 클래스 메서드에서 검색 된 다음 `AddCacheItem(key, value)` 메서드를 사용 하 여 캐시에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="4f12e-176">`GetCacheItem(key)` 및 `AddCacheItem(key, value)` 메서드는 각각 데이터 캐시로 인터페이스 하 고 값을 읽고 씁니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="4f12e-177">`GetCacheItem(key)` 방법은 두 가지 보다 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="4f12e-178">단지 전달 된 *키*를 사용 하 여 Cache 클래스에서 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="4f12e-179">`GetCacheItem(key)`는 제공 되는 *키* 값을 사용 하지 않고 대신 `GetCacheKey(key)` 메서드를 호출 합니다 .이 메서드는 ProductsCache-앞에 있는 *키* 를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="4f12e-180">ProductsCache 문자열을 포함 하는 `MasterCacheKeyArray`은 일시적으로 표시 되는 것 처럼 `AddCacheItem(key, value)` 메서드에서도 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="4f12e-181">ASP.NET page s의 코드 숨김이 클래스 [`Cache` 속성](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)을 사용 하 여 데이터 캐시에 액세스할 수 있으며, 2 단계에 설명 `Page` 된 대로 `Cache("key") = value`와 같은 구문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="4f12e-182">아키텍처 내의 클래스에서 데이터 캐시는 `HttpRuntime.Cache` 또는 `HttpContext.Current.Cache`를 사용 하 여 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="4f12e-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)의 블로그 항목 HttpRuntime `HttpContext.Current`와 대신 `HttpRuntime`를 사용 하는 경우 성능이 약간 향상 [되었습니다.](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) 따라서 `ProductsCL`는 `HttpRuntime`를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="4f12e-184">클래스 라이브러리 프로젝트를 사용 하 여 아키텍처가 구현 된 경우 [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) 및 [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) 클래스를 사용 하려면 `System.Web` 어셈블리에 대 한 참조를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>

<span data-ttu-id="4f12e-185">캐시에서 항목을 찾을 수 없는 경우 `ProductsCL` 클래스의 메서드는 `AddCacheItem(key, value)` 메서드를 사용 하 여 BLL에서 데이터를 가져온 다음 캐시에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="4f12e-186">캐시에 *값* 을 추가 하려면 다음 코드를 사용할 수 있습니다 .이 코드는 60 초 만료 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="4f12e-187">`DateTime.Now.AddSeconds(CacheDuration)`는 앞으로 시간 기반 만료 60 초를 지정 하 고 [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) 는 슬라이딩 만료가 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="4f12e-188">이 `Insert` 메서드 오버 로드에는 절대 및 슬라이딩 만료 모두에 대 한 입력 매개 변수가 있지만 둘 중 하나만 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="4f12e-189">절대 시간과 시간 범위를 모두 지정 하려고 하면 `Insert` 메서드가 `ArgumentException` 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="4f12e-190">현재 `AddCacheItem(key, value)` 메서드의 구현에는 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="4f12e-191">4 단계에서 이러한 문제를 해결 하 고 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-191">We'll address and overcome these issues in Step 4.</span></span>

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="4f12e-192">4 단계: 아키텍처를 통해 데이터가 수정 될 때 캐시 무효화</span><span class="sxs-lookup"><span data-stu-id="4f12e-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="4f12e-193">데이터 검색 방법과 함께 캐싱 계층은 데이터 삽입, 업데이트 및 삭제를 위한 BLL과 동일한 메서드를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="4f12e-194">CL의 데이터 수정 메서드는 캐시 된 데이터를 수정 하지 않고 BLL의 해당 데이터 수정 메서드를 호출한 다음 캐시를 무효화 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="4f12e-195">앞의 자습서에서 살펴본 것 처럼이는 캐싱 기능을 사용 하도록 설정 하 고 해당 `Insert`, `Update`또는 `Delete` 메서드를 호출할 때 ObjectDataSource가 적용 하는 동작과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="4f12e-196">다음 `UpdateProduct` 오버 로드에서는 CL에서 데이터 수정 메서드를 구현 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="4f12e-197">적절 한 데이터 수정 비즈니스 논리 계층 메서드가 호출 되지만 응답이 반환 되기 전에 캐시를 무효화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="4f12e-198">불행 하 게, `ProductsCL` 클래스 s `GetProducts()` 및 `GetProductsByCategoryID(categoryID)` 메서드가 각각 다른 키를 사용 하 여 캐시에 항목을 추가 하 고 `GetProductsByCategoryID(categoryID)` 메서드는 각 고유 *categoryID*에 대해 서로 다른 캐시 항목을 추가 하기 때문에 캐시를 무효화 하는 것은 간단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="4f12e-199">캐시를 무효화 하는 경우 `ProductsCL` 클래스에서 추가 했을 수 있는 *모든* 항목을 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="4f12e-200">*캐시 종속성* 을 `AddCacheItem(key, value)` 메서드의 캐시에 추가 된 각 항목과 연결 하 여이를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="4f12e-201">일반적으로 캐시 종속성은 캐시에 있는 다른 항목, 파일 시스템의 파일 또는 Microsoft SQL Server 데이터베이스의 데이터가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="4f12e-202">종속성이 변경 되거나 캐시에서 제거 되 면 연결 된 캐시 항목이 캐시에서 자동으로 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="4f12e-203">이 자습서에서는 `ProductsCL` 클래스를 통해 추가 된 모든 항목에 대 한 캐시 종속성으로 사용 되는 추가 항목을 캐시에 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="4f12e-204">이렇게 하면 캐시 종속성을 제거 하 여 이러한 모든 항목을 캐시에서 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="4f12e-205">를 사용 하 여이 메서드를 통해 캐시에 추가 된 각 항목이 단일 캐시 종속성과 연결 되도록 `AddCacheItem(key, value)` 메서드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="4f12e-206">`MasterCacheKeyArray`는 단일 값 ProductsCache을 포함 하는 문자열 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="4f12e-207">먼저 캐시 항목을 캐시에 추가 하 고 현재 날짜 및 시간을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="4f12e-208">캐시 항목이 이미 있으면 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="4f12e-209">그런 다음 캐시 종속성을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="4f12e-210">[`CacheDependency` 클래스](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) 의 생성자에는 많은 오버 로드가 있지만 여기에서 사용 되는 생성자에는 두 개의 `String` 배열 입력이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="4f12e-211">첫 번째는 종속성으로 사용할 파일 집합을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="4f12e-212">파일 기반 종속성을 사용 하지 않으려는 경우 첫 번째 입력 매개 변수에 `Nothing` 값이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="4f12e-213">두 번째 입력 매개 변수는 종속성으로 사용할 캐시 키 집합을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="4f12e-214">여기서는 `MasterCacheKeyArray`단일 종속성을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="4f12e-215">그런 다음 `CacheDependency` `Insert` 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="4f12e-216">이러한 수정 작업을 `AddCacheItem(key, value)`하 여 캐시를 사용 하는 것은 종속성을 제거 하는 것 만큼 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="4f12e-217">5 단계: 프레젠테이션 계층에서 캐싱 계층 호출</span><span class="sxs-lookup"><span data-stu-id="4f12e-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="4f12e-218">캐싱 계층의 클래스 및 메서드를 사용 하 여 이러한 자습서에서 검사 한 기술을 사용 하 여 데이터 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="4f12e-219">캐시 된 데이터를 사용 하 여 작업 하는 방법을 설명 하려면 `ProductsCL` 클래스에 변경 내용을 저장 한 다음 `Caching` 폴더에서 `FromTheArchitecture.aspx` 페이지를 열고 GridView를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="4f12e-220">GridView s 스마트 태그에서 새 ObjectDataSource를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="4f12e-221">마법사의 첫 번째 단계에서는 `ProductsCL` 클래스가 드롭다운 목록의 옵션 중 하나로 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>

<span data-ttu-id="4f12e-222">[비즈니스 개체 드롭다운 목록에 제품 Scl 클래스 ![포함 되어 있습니다.](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="4f12e-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="4f12e-223">**그림 4**: `ProductsCL` 클래스가 비즈니스 개체 드롭다운 목록에 포함 되어 있습니다 ([전체 크기 이미지를 보려면 클릭](caching-data-in-the-architecture-vb/_static/image6.png)).</span><span class="sxs-lookup"><span data-stu-id="4f12e-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>

<span data-ttu-id="4f12e-224">`ProductsCL`를 선택한 후 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="4f12e-225">선택 탭의 드롭다운 목록에는 `GetProducts()` 및 `GetProductsByCategoryID(categoryID)`의 두 항목이 있으며 업데이트 탭에는 유일한 `UpdateProduct` 오버 로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="4f12e-226">선택 탭에서 `GetProducts()` 메서드를 선택 하 고 업데이트 탭에서 `UpdateProducts` 방법을 선택한 다음 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>

<span data-ttu-id="4f12e-227">[![는 제품 Scl 클래스의 메서드는 드롭다운 목록에 나열 됩니다.](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="4f12e-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="4f12e-228">**그림 5**: `ProductsCL` 클래스의 메서드는 드롭다운 목록에 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](caching-data-in-the-architecture-vb/_static/image9.png)).</span><span class="sxs-lookup"><span data-stu-id="4f12e-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>

<span data-ttu-id="4f12e-229">마법사를 완료 한 후 Visual Studio에서는 ObjectDataSource s `OldValuesParameterFormatString` 속성을 `original_{0}` 설정 하 고 적절 한 필드를 GridView에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="4f12e-230">`OldValuesParameterFormatString` 속성을 `{0}`기본값으로 다시 변경 하 고 페이징, 정렬 및 편집을 지원 하도록 GridView를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="4f12e-231">CL에서 사용 하는 `UploadProducts` 오버 로드는 편집 된 제품 이름 및 가격만 허용 하므로 이러한 필드만 편집할 수 있도록 GridView를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="4f12e-232">이전 자습서에서는 `ProductName`, `CategoryName`및 `UnitPrice` 필드에 대 한 필드를 포함 하도록 GridView를 정의 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="4f12e-233">이 형식 및 구조를 자유롭게 복제할 수 있습니다 .이 경우 GridView 및 ObjectDataSource의 선언적 태그가 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="4f12e-234">이 시점에서 캐싱 계층을 사용 하는 페이지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="4f12e-235">작업 중인 캐시를 보려면 `ProductsCL` 클래스 `GetProducts()` 및 `UpdateProduct` 메서드에 중단점을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="4f12e-236">브라우저에서 페이지를 방문 하 고 정렬 및 페이징을 통해 코드를 단계별로 실행 하 여 캐시에서 끌어온 데이터를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="4f12e-237">그런 다음 레코드를 업데이트 하면 캐시가 무효화 되 고 데이터가 GridView에 다시 바인딩 되었을 때 BLL에서 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="4f12e-238">이 문서와 함께 다운로드에 제공 된 캐싱 계층이 완전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="4f12e-239">이 클래스에는 소수의 메서드만 스포츠 하는 하나의 클래스 `ProductsCL`포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="4f12e-240">또한 단일 ASP.NET 페이지만 CL (`~/Caching/FromTheArchitecture.aspx`)을 사용 하 고 다른 모든 페이지는 여전히 BLL을 직접 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="4f12e-241">응용 프로그램에서 CL 사용을 계획 하는 경우 프레젠테이션 계층의 모든 호출은 CL로 이동 해야 합니다. 그러면 cl의 클래스 및 메서드가 프레젠테이션 계층에서 현재 사용 하 고 있는 BLL의 클래스와 메서드를 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>

## <a name="summary"></a><span data-ttu-id="4f12e-242">요약</span><span class="sxs-lookup"><span data-stu-id="4f12e-242">Summary</span></span>

<span data-ttu-id="4f12e-243">캐싱을 ASP.NET 2.0 s SqlDataSource 및 ObjectDataSource 컨트롤과 함께 프레젠테이션 계층에 적용할 수 있지만, 아키텍처의 개별 계층에 가장 적합 한 캐싱 책임이 위임 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="4f12e-244">이 자습서에서는 프레젠테이션 계층과 비즈니스 논리 계층 사이에 있는 캐싱 계층을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="4f12e-245">캐싱 계층은 BLL에 존재 하 고 프레젠테이션 계층에서 호출 되는 동일한 클래스 및 메서드 집합을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="4f12e-246">이에 대해 살펴본 캐싱 계층 예제와 앞의 자습서에는 *사후 로드*가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="4f12e-247">사후 로드를 사용 하면 데이터에 대 한 요청을 수행 하 고 캐시에 데이터가 없는 경우에만 데이터가 캐시에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="4f12e-248">데이터는 실제로 필요 하기 전에 캐시에 데이터를 로드 하는 기술인 캐시에 *사전 로드* 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="4f12e-249">다음 자습서에서는 응용 프로그램 시작 시 캐시에 정적 값을 저장 하는 방법을 살펴볼 때 사전 로드의 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="4f12e-250">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="4f12e-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="4f12e-251">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="4f12e-251">About the Author</span></span>

<span data-ttu-id="4f12e-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="4f12e-253">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="4f12e-254">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="4f12e-255">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="4f12e-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="4f12e-256">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="4f12e-257">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-257">Special Thanks To</span></span>

<span data-ttu-id="4f12e-258">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="4f12e-259">이 자습서의 리드 검토자는 Teresa Murphy입니다.</span><span class="sxs-lookup"><span data-stu-id="4f12e-259">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="4f12e-260">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="4f12e-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="4f12e-261">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="4f12e-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4f12e-262">[이전](caching-data-with-the-objectdatasource-vb.md)
> [다음](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="4f12e-262">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
