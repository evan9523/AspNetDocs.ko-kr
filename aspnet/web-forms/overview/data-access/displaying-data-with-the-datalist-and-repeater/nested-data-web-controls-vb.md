---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
title: 중첩 된 데이터 웹 컨트롤 (VB) | Microsoft Docs
author: rick-anderson
description: 이 자습서에서는 다른 리피터 안에 중첩 된 리피터를 사용 하는 방법을 살펴봅니다. 이 예에서는 내부 반복기를 모두 채우는 방법을 보여 줍니다.
ms.author: riande
ms.date: 09/13/2006
ms.assetid: 8b7fcf7b-722b-498d-a4e4-7c93701e0c95
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
msc.type: authoredcontent
ms.openlocfilehash: c3c62ce4293498d3b325031ac9817f8935b183b2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78495431"
---
# <a name="nested-data-web-controls-vb"></a><span data-ttu-id="afd9e-104">중첩된 데이터 웹 컨트롤(VB)</span><span class="sxs-lookup"><span data-stu-id="afd9e-104">Nested Data Web Controls (VB)</span></span>

<span data-ttu-id="afd9e-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="afd9e-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="afd9e-106">[샘플 앱 다운로드](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) 또는 [PDF 다운로드](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="afd9e-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) or [Download PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span></span>

> <span data-ttu-id="afd9e-107">이 자습서에서는 다른 리피터 안에 중첩 된 리피터를 사용 하는 방법을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="afd9e-108">이 예제에서는 내부 반복기를 선언적으로 프로그래밍 방식으로 채우는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

## <a name="introduction"></a><span data-ttu-id="afd9e-109">소개</span><span class="sxs-lookup"><span data-stu-id="afd9e-109">Introduction</span></span>

<span data-ttu-id="afd9e-110">정적 HTML 및 데이터 바인딩 구문 외에도 템플릿에서는 웹 컨트롤 및 사용자 정의 컨트롤을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="afd9e-111">이러한 웹 컨트롤은 선언적, 데이터 바인딩 구문을 통해 할당 된 속성을 포함 하거나 적절 한 서버 쪽 이벤트 처리기에서 프로그래밍 방식으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="afd9e-112">템플릿 내에 컨트롤을 포함 하면 모양과 사용자 환경을 사용자 지정 하 고에 맞게 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="afd9e-113">예를 들어 [Gridview 컨트롤의 템플릿 필드 사용](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) 자습서에서는 직원 채용 날짜를 표시 하는 일정 컨트롤을 templatefield로 변환에 추가 하 여 GridView s 표시를 사용자 지정 하는 방법을 살펴보았습니다. [편집 및 삽입 인터페이스에 유효성 검사 컨트롤 추가](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) 및 [데이터 수정 인터페이스 사용자 지정](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) 자습서에서는 유효성 검사 컨트롤, 텍스트 상자, dropdownlist 및 기타 웹 컨트롤을 추가 하 여 편집 및 삽입 인터페이스를 사용자 지정 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="afd9e-114">템플릿에 다른 데이터 웹 컨트롤이 포함 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="afd9e-115">즉, 해당 템플릿 내에서 다른 DataList (또는 Repeater, GridView 또는 DetailsView 등)를 포함 하는 DataList를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="afd9e-116">이러한 인터페이스의 문제는 적절 한 데이터를 내부 데이터 웹 컨트롤에 바인딩하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="afd9e-117">ObjectDataSource를 사용 하는 선언적 옵션에서 프로그래밍 방식으로 사용할 수 있는 몇 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="afd9e-118">이 자습서에서는 다른 리피터 안에 중첩 된 리피터를 사용 하는 방법을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="afd9e-119">외부 Repeater는 범주 이름과 설명을 표시 하는 데이터베이스의 각 범주에 대 한 항목을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="afd9e-120">각 범주 항목의 내부 리피터는 글머리 기호 목록에서 해당 범주에 속하는 각 제품에 대 한 정보를 표시 합니다 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="afd9e-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="afd9e-121">이 예제에서는 내부 반복기를 선언적으로 프로그래밍 방식으로 채우는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

<span data-ttu-id="afd9e-122">[각 범주와 제품과 함께 ![나열 됩니다.](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="afd9e-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span></span>

<span data-ttu-id="afd9e-123">**그림 1**: 각 범주 (제품 포함)가 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image3.png)).</span><span class="sxs-lookup"><span data-stu-id="afd9e-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-vb/_static/image3.png))</span></span>

## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="afd9e-124">1 단계: 범주 목록 만들기</span><span class="sxs-lookup"><span data-stu-id="afd9e-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="afd9e-125">중첩 된 데이터 웹 컨트롤을 사용 하는 페이지를 만들 때 내부 중첩 된 컨트롤에 대해 걱정 하지 않고 가장 바깥쪽 데이터 웹 컨트롤을 먼저 디자인, 작성 및 테스트 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="afd9e-126">따라서 각 범주에 대 한 이름 및 설명을 나열 하는 페이지에 리피터를 추가 하는 데 필요한 단계를 시작 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="afd9e-127">먼저 `DataListRepeaterBasics` 폴더에서 `NestedControls.aspx` 페이지를 열고 `ID` 속성을 `CategoryList`로 설정 하 여 Repeater 컨트롤을 페이지에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="afd9e-128">Repeater s 스마트 태그에서 `CategoriesDataSource`라는 새 ObjectDataSource를 만들도록 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>

<span data-ttu-id="afd9e-129">[새 ObjectDataSource 범주 Datasource의 이름을 ![합니다.](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="afd9e-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span></span>

<span data-ttu-id="afd9e-130">**그림 2**: 새 ObjectDataSource `CategoriesDataSource` 이름 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="afd9e-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-vb/_static/image6.png))</span></span>

<span data-ttu-id="afd9e-131">`CategoriesBLL` 클래스 s `GetCategories` 메서드에서 데이터를 끌어올 수 있도록 ObjectDataSource를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>

<span data-ttu-id="afd9e-132">[범주 Bll 클래스 GetCategories 메서드를 사용 하도록 ObjectDataSource를 구성 ![](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="afd9e-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span></span>

<span data-ttu-id="afd9e-133">**그림 3**: `CategoriesBLL` 클래스 s `GetCategories` 메서드를 사용 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="afd9e-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-vb/_static/image9.png))</span></span>

<span data-ttu-id="afd9e-134">반복기의 템플릿 콘텐츠를 지정 하려면 소스 뷰로 이동 하 여 선언적 구문을 수동으로 입력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="afd9e-135">`<h4>` 요소에 범주 이름을 표시 하는 `ItemTemplate`을 추가 하 고 단락 요소 (`<p>`)에 범주에 대 한 설명을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="afd9e-136">또한 각 범주를 가로 규칙 (`<hr>`)으로 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="afd9e-137">이러한 변경을 수행한 후에는 페이지에 다음과 유사한 Repeater와 ObjectDataSource에 대 한 선언 구문이 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample1.aspx)]

<span data-ttu-id="afd9e-138">그림 4는 브라우저를 통해 볼 때의 진행률을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-138">Figure 4 shows our progress when viewed through a browser.</span></span>

<span data-ttu-id="afd9e-139">[각 범주 이름 및 설명이 나열 되어 ![수평선 규칙으로 구분 됩니다.](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="afd9e-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span></span>

<span data-ttu-id="afd9e-140">**그림 4**: 각 범주 이름 및 설명이 가로 규칙에 따라 구분 되어 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image12.png)).</span><span class="sxs-lookup"><span data-stu-id="afd9e-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-vb/_static/image12.png))</span></span>

## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="afd9e-141">2 단계: 중첩 된 제품 리피터 추가</span><span class="sxs-lookup"><span data-stu-id="afd9e-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="afd9e-142">범주 목록이 완료 되 면 다음 작업은 해당 범주에 속하는 제품에 대 한 정보를 표시 하는 `CategoryList` s `ItemTemplate`에 대 한 Repeater를 추가 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="afd9e-143">이 내부 리피터의 데이터를 검색할 수 있는 여러 가지 방법이 있으며,이 중 두 가지는 곧 살펴볼 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="afd9e-144">지금은 `CategoryList` Repeater s `ItemTemplate`내에서 제품 리피터를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="afd9e-145">특히 제품의 이름과 가격을 포함 하 여 각 목록 항목을 포함 하는 제품 리피터가 각 제품을 글머리 기호 목록에 표시 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="afd9e-146">이 반복을 만들려면 `CategoryList` s `ItemTemplate`에 내부 Repeater s 선언적 구문 및 템플릿을 수동으로 입력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="afd9e-147">`CategoryList` Repeater s `ItemTemplate`안에 다음 태그를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="afd9e-148">3 단계: ProductsByCategoryList Repeater에 범주 관련 제품 바인딩</span><span class="sxs-lookup"><span data-stu-id="afd9e-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="afd9e-149">이 시점에서 브라우저를 통해 페이지를 방문 하는 경우에는 데이터를 Repeater에 바인딩하지 못했기 때문에 화면이 그림 4와 동일 하 게 보입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="afd9e-150">적절 한 제품 레코드를 찾아 Repeater에 바인딩할 수 있는 몇 가지 방법이 있습니다. 다른 방법 보다 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="afd9e-151">여기서 가장 중요 한 문제는 지정 된 범주에 대 한 적절 한 제품을 다시 가져오는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="afd9e-152">내부 Repeater 컨트롤에 바인딩할 데이터는 `CategoryList` Repeater s `ItemTemplate`의 ObjectDataSource를 통해 또는 프로그래밍 방식으로 ASP.NET 페이지의 코드 숨김이 페이지에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="afd9e-153">마찬가지로,이 데이터는 내부 반복에서 `DataSourceID` 선언적으로 또는 선언적 데이터 바인딩 구문을 통해 또는 선언적으로 `CategoryList` Repeater s `ItemDataBound` 이벤트 처리기에서 내부 반복기를 참조 하 고 프로그래밍 방식으로 `DataSource` 속성을 설정 하 고 해당 `DataBind()` 메서드를 호출 하 여 프로그래밍 방식으로 내부 Repeater에 바인딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="afd9e-154">이러한 각 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="afd9e-155">ObjectDataSource 컨트롤과`ItemDataBound`이벤트 처리기를 사용 하 여 선언적으로 데이터 액세스</span><span class="sxs-lookup"><span data-stu-id="afd9e-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="afd9e-156">이 자습서 시리즈를 통해 ObjectDataSource를 광범위 하 게 사용 했기 때문에이 예제에서 데이터에 액세스 하는 가장 일반적인 선택은 ObjectDataSource를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="afd9e-157">`ProductsBLL` 클래스에는 지정 된 *`categoryID`* 에 속하는 해당 제품에 대 한 정보를 반환 하는 `GetProductsByCategoryID(categoryID)` 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="afd9e-158">따라서 `CategoryList` Repeater s `ItemTemplate`에 ObjectDataSource를 추가 하 고이 클래스의 메서드를 사용 하 여 데이터에 액세스 하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="afd9e-159">아쉽게도 반복기는 디자인 뷰를 통해 해당 템플릿을 편집할 수 없도록 하므로이 ObjectDataSource 컨트롤의 선언 구문을 직접 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="afd9e-160">다음 구문에서는이 새 ObjectDataSource (`ProductsByCategoryDataSource`)를 추가한 후 `CategoryList` Repeater s `ItemTemplate`를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample3.aspx)]

<span data-ttu-id="afd9e-161">ObjectDataSource 방법을 사용 하는 경우 `ProductsByCategoryList` Repeater s `DataSourceID` 속성을 ObjectDataSource의 `ID` (`ProductsByCategoryDataSource`)로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="afd9e-162">또한 ObjectDataSource에는 `GetProductsByCategoryID(categoryID)` 메서드에 전달 되는 *`categoryID`* 값을 지정 하는 `<asp:Parameter>` 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="afd9e-163">그러나이 값을 지정 하는 방법은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="afd9e-163">But how do we specify this value?</span></span> <span data-ttu-id="afd9e-164">이상적으로는 다음과 같이 데이터 바인딩 구문을 사용 하 여 `<asp:Parameter>` 요소의 `DefaultValue` 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample4.aspx)]

<span data-ttu-id="afd9e-165">아쉽게도 데이터 바인딩 구문은 `DataBinding` 이벤트를 포함 하는 컨트롤 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="afd9e-166">`Parameter` 클래스는 이러한 이벤트를 사용할 수 없으므로 위의 구문이 잘못 되어 런타임 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="afd9e-167">이 값을 설정 하려면 `CategoryList` Repeater s `ItemDataBound` 이벤트에 대 한 이벤트 처리기를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="afd9e-168">`ItemDataBound` 이벤트는 Repeater에 바인딩된 각 항목에 대해 한 번씩 발생 한다는 것을 기억 하세요.</span><span class="sxs-lookup"><span data-stu-id="afd9e-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="afd9e-169">따라서 외부 Repeater에 대해이 이벤트가 발생 될 때마다 현재 `CategoryID` 값을 `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` 매개 변수에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="afd9e-170">다음 코드를 사용 하 여 `CategoryList` Repeater s `ItemDataBound` 이벤트에 대 한 이벤트 처리기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample5.vb)]

<span data-ttu-id="afd9e-171">이 이벤트 처리기는 머리글, 바닥글 또는 구분 기호 항목이 아닌 데이터 항목을 다시 처리 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="afd9e-172">다음으로 현재 `RepeaterItem`에 바인딩된 실제 `CategoriesRow` 인스턴스를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="afd9e-173">마지막으로 `ItemTemplate`에서 ObjectDataSource를 참조 하 고 현재 `RepeaterItem`의 `CategoryID`에 `CategoryID` 매개 변수 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="afd9e-174">이 이벤트 처리기를 사용 하 여 각 `RepeaterItem`의 `ProductsByCategoryList` Repeater는 `RepeaterItem` s 범주의 해당 제품에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="afd9e-175">그림 5는 결과 출력의 스크린샷을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-175">Figure 5 shows a screen shot of the resulting output.</span></span>

<span data-ttu-id="afd9e-176">[외부 Repeater에는 각 범주가 나열 ![. 내부는 해당 범주에 대 한 제품을 나열 합니다.](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="afd9e-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span></span>

<span data-ttu-id="afd9e-177">**그림 5**: 외부 리피터는 각 범주를 나열 합니다. 내부 항목에는 해당 범주에 대 한 제품이 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image15.png)).</span><span class="sxs-lookup"><span data-stu-id="afd9e-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-vb/_static/image15.png))</span></span>

## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="afd9e-178">프로그래밍 방식으로 범주 데이터로 제품 액세스</span><span class="sxs-lookup"><span data-stu-id="afd9e-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="afd9e-179">ObjectDataSource를 사용 하 여 현재 범주에 대 한 제품을 검색 하는 대신, `CategoryID`에 전달 될 때 적절 한 제품 집합을 반환 하는 ASP.NET 페이지의 코드 숨김이 클래스 (또는 `App_Code` 폴더 또는 별도의 클래스 라이브러리 프로젝트)에서 메서드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="afd9e-180">ASP.NET 페이지의 코드 숨김이 클래스에 이러한 메서드가 있고 `GetProductsInCategory(categoryID)`이름이 지정 되어 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="afd9e-181">이 메서드를 사용 하면 다음 선언 구문을 사용 하 여 현재 범주의 제품을 내부 Repeater에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample6.aspx)]

<span data-ttu-id="afd9e-182">Repeater s `DataSource` 속성은 데이터 바인딩 구문을 사용 하 여 해당 데이터가 `GetProductsInCategory(categoryID)` 메서드에서 제공 됨을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="afd9e-183">`Eval("CategoryID")`는 `Object`형식의 값을 반환 하므로 `GetProductsInCategory(categoryID)` 메서드에 전달 하기 전에 개체를 `Integer` 캐스팅 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="afd9e-184">데이터 바인딩 구문을 통해 여기에서 액세스 하는 `CategoryID`는 *외부* 리피터 (`CategoryList`)에서 `Categories` 테이블의 레코드에 바인딩된 `CategoryID`입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="afd9e-185">따라서 `CategoryID`는 데이터베이스 `NULL` 값이 될 수 없다는 것을 알고 있으므로 `DBNull`를 다시 처리 하 고 있는지 확인 하지 않고 `Eval` 메서드를 무조건 캐스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="afd9e-186">이 방법을 사용 하면 `GetProductsInCategory(categoryID)` 메서드를 만들고 제공 된 *`categoryID`* 제공 된 적절 한 제품 집합을 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="afd9e-187">이 작업을 수행 하려면 `ProductsBLL` 클래스 s `GetProductsByCategoryID(categoryID)` 메서드에서 반환 된 `ProductsDataTable` 반환 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="afd9e-188">`NestedControls.aspx` 페이지에 대 한 코드 숨김이 클래스에서 `GetProductsInCategory(categoryID)` 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="afd9e-189">이렇게 하려면 다음 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-189">Do so using the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample7.vb)]

<span data-ttu-id="afd9e-190">이 메서드는 단순히 `ProductsBLL` 메서드의 인스턴스를 만들고 `GetProductsByCategoryID(categoryID)` 메서드의 결과를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="afd9e-191">메서드는 `Public` 또는 `Protected`로 표시 되어야 합니다. 메서드가 `Private`표시 되는 경우에는 ASP.NET 페이지의 선언적 태그에서 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="afd9e-192">이 새로운 기술을 사용 하도록 이러한 변경을 수행한 후 잠시 시간을 들 여 브라우저를 통해 페이지를 봅니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="afd9e-193">ObjectDataSource 및 `ItemDataBound` 이벤트 처리기 접근 방식을 사용할 때 출력이 출력과 동일 해야 합니다 (스크린샷 보려면 그림 5 참조).</span><span class="sxs-lookup"><span data-stu-id="afd9e-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="afd9e-194">ASP.NET page s 코드 busywork 클래스에 `GetProductsInCategory(categoryID)` 메서드를 만드는 것 처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="afd9e-195">이 메서드는 모두 `ProductsBLL` 클래스의 인스턴스를 만들고 해당 `GetProductsByCategoryID(categoryID)` 메서드의 결과를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="afd9e-196">`DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?와 같이 내부 Repeater의 데이터 바인딩 구문에서이 메서드를 직접 호출 하지 않는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="afd9e-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span></span> <span data-ttu-id="afd9e-197">이 구문은 `ProductsBLL` 클래스의 현재 구현에서 작동 하지 않지만 (`GetProductsByCategoryID(categoryID)` 메서드가 인스턴스 메서드 이기 때문) 정적 `GetProductsByCategoryID(categoryID)` 메서드를 포함 하거나 클래스에 정적 `Instance()` 메서드를 포함 하 여 `ProductsBLL` 클래스의 새 인스턴스를 반환 하도록 `ProductsBLL`를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-197">Although this syntax won't work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>

<span data-ttu-id="afd9e-198">이러한 수정 작업을 수행 하면 ASP.NET page s의 코드 숨김이 클래스에서 `GetProductsInCategory(categoryID)` 메서드가 필요 하지 않지만 코드를 사용 하는 클래스 메서드를 사용 하면 검색 된 데이터를 더 유연 하 게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="afd9e-199">모든 제품 정보를 한 번에 검색</span><span class="sxs-lookup"><span data-stu-id="afd9e-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="afd9e-200">이전 클래스의 `GetProductsByCategoryID(categoryID)` 메서드 `ProductsBLL`를 호출 하 여 현재 범주에 대 한 제품을 확인 하는 두 가지 방법입니다. 첫 번째 방법은 ObjectDataSource를 통해, 두 번째는 코드 숨김이 클래스의 `GetProductsInCategory(categoryID)` 메서드를 통해 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="afd9e-201">이 메서드가 호출 될 때마다 비즈니스 논리 계층은 데이터 액세스 계층으로 이동 하 여 `CategoryID` 필드가 제공 된 입력 매개 변수와 일치 하는 `Products` 테이블의 행을 반환 하는 SQL 문을 사용 하 여 데이터베이스를 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="afd9e-202">시스템에서 *n* 개의 범주를 지정 하는 경우이 방법은 데이터베이스 하나에 대 한 안전망 *n* + 1을 호출 하 여 모든 범주를 가져온 다음 *n* 을 호출 하 여 각 범주와 관련 된 제품을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="afd9e-203">그러나 한 번의 호출로 두 개의 데이터베이스를 호출 하 여 모든 범주를 가져오고 모든 제품을 가져오는 데 필요한 모든 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="afd9e-204">모든 제품을 설치한 후에는 해당 제품을 필터링 하 여 현재 `CategoryID`와 일치 하는 제품만 해당 범주에 있는 내부 리피터에 게 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="afd9e-205">이 기능을 제공 하기 위해 ASP.NET 페이지의 코드 숨김이 클래스에서 `GetProductsInCategory(categoryID)` 메서드를 약간만 수정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="afd9e-206">`ProductsBLL` 클래스 `GetProductsByCategoryID(categoryID)` 메서드의 결과를 무조건 반환 하는 대신, 먼저 *모든* 제품에 액세스 (이미 액세스 하지 않은 경우) 한 다음 전달 된 `CategoryID`에 따라 제품의 필터링 된 보기만 반환 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven't been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample8.vb)]

<span data-ttu-id="afd9e-207">페이지 수준 변수를 추가 `allProducts`합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="afd9e-208">이는 모든 제품에 대 한 정보를 포함 하며 `GetProductsInCategory(categoryID)` 메서드가 처음 호출 될 때 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="afd9e-209">`allProducts` 개체가 생성 되 고 채워져 있는지 확인 한 후에는이 메서드는 `CategoryID` 지정 된 `CategoryID`와 일치 하는 행만 액세스할 수 있도록 DataTable의 결과를 필터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="afd9e-210">이 접근 방식은 *N* + 1에서 2로 데이터베이스에 액세스 하는 횟수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="afd9e-211">이 향상 된 기능은 페이지의 렌더링 된 태그에 변경 내용을 적용 하지 않으며 다른 방법 보다 더 작은 레코드를 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="afd9e-212">단지 데이터베이스에 대 한 호출 수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="afd9e-213">데이터베이스 액세스의 수를 줄이면 성능이 명확.</span><span class="sxs-lookup"><span data-stu-id="afd9e-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="afd9e-214">그러나 그렇지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-214">However, this might not be the case.</span></span> <span data-ttu-id="afd9e-215">예를 들어 `CategoryID` `NULL`된 많은 수의 제품이 있는 경우 `GetProducts` 메서드를 호출 하면 표시 되지 않는 많은 제품이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="afd9e-216">또한 범주 하위 집합만 표시 하는 경우에는 모든 제품을 반환 하는 것이 불필요 한 것일 수 있습니다 .이 경우 페이징이 구현 된 경우에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>

<span data-ttu-id="afd9e-217">두 기술의 성능을 분석 하는 경우에만 surefire 유일한 방법은 응용 프로그램의 일반적인 사례 시나리오에 맞게 조정 된 제어 된 테스트를 실행 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="afd9e-218">요약</span><span class="sxs-lookup"><span data-stu-id="afd9e-218">Summary</span></span>

<span data-ttu-id="afd9e-219">이 자습서에서는 하나의 데이터 웹 컨트롤 내에 데이터 웹 컨트롤을 중첩 하는 방법을 살펴보았습니다. 특히 외부 반복을 사용 하 여 각 범주에 대 한 항목을 글머리 기호 목록에 있는 각 범주에 대 한 제품을 나열 하는 내부 리피터로 표시 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="afd9e-220">중첩 된 사용자 인터페이스를 빌드하는 주된 문제는 올바른 데이터를 내부 데이터 웹 컨트롤에 액세스 하 고 바인딩하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="afd9e-221">이 자습서에서는 다양 한 기술을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="afd9e-222">첫 번째 방법은 `DataSourceID` 속성을 통해 내부 데이터 웹 컨트롤에 바인딩된 `ItemTemplate` 외부 데이터 웹 컨트롤에서 ObjectDataSource를 사용 하 여 검사 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="afd9e-223">두 번째 기술은 ASP.NET 페이지의 코드 숨김으로 된 클래스의 메서드를 통해 데이터에 액세스 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="afd9e-224">그런 다음이 메서드를 데이터 바인딩 구문을 통해 내부 데이터 웹 컨트롤 `DataSource` 속성에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="afd9e-225">이 자습서에서 검사 한 중첩 된 사용자 인터페이스가 Repeater 내에 중첩 된 Repeater를 사용 했지만 이러한 기술은 다른 데이터 웹 컨트롤로 확장 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="afd9e-226">표를 GridView 내에서 중첩 하거나 DataList 내에서 GridView를 중첩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="afd9e-227">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="afd9e-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="afd9e-228">저자 정보</span><span class="sxs-lookup"><span data-stu-id="afd9e-228">About the Author</span></span>

<span data-ttu-id="afd9e-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="afd9e-230">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="afd9e-231">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="afd9e-232">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="afd9e-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="afd9e-233">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-233">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="afd9e-234">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-234">Special Thanks To</span></span>

<span data-ttu-id="afd9e-235">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-235">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="afd9e-236">이 자습서의 리드 검토자는 Zack Jones 및 Liz Shulok입니다.</span><span class="sxs-lookup"><span data-stu-id="afd9e-236">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="afd9e-237">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="afd9e-237">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="afd9e-238">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="afd9e-238">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="afd9e-239">이전</span><span class="sxs-lookup"><span data-stu-id="afd9e-239">Previous</span></span>](showing-multiple-records-per-row-with-the-datalist-control-vb.md)
