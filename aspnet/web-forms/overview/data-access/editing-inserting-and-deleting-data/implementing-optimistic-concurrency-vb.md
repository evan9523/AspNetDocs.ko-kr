---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb
title: 낙관적 동시성 구현 (VB) | Microsoft Docs
author: rick-anderson
description: 여러 사용자가 데이터를 편집할 수 있도록 허용 하는 웹 응용 프로그램의 경우 두 사용자가 동시에 동일한 데이터를 편집할 수 있습니다. 이 tutori
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 2646968c-2826-4418-b1d0-62610ed177e3
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb
msc.type: authoredcontent
ms.openlocfilehash: 28c39fe2a290cc3a5b093fdd09de341630606137
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78492365"
---
# <a name="implementing-optimistic-concurrency-vb"></a><span data-ttu-id="4ee7e-104">낙관적 동시성 구현(VB)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-104">Implementing Optimistic Concurrency (VB)</span></span>

<span data-ttu-id="4ee7e-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="4ee7e-106">[샘플 앱 다운로드](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_VB.exe) 또는 [PDF 다운로드](implementing-optimistic-concurrency-vb/_static/datatutorial21vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_VB.exe) or [Download PDF](implementing-optimistic-concurrency-vb/_static/datatutorial21vb1.pdf)</span></span>

> <span data-ttu-id="4ee7e-107">여러 사용자가 데이터를 편집할 수 있도록 허용 하는 웹 응용 프로그램의 경우 두 사용자가 동시에 동일한 데이터를 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="4ee7e-108">이 자습서에서는이 위험을 처리 하는 낙관적 동시성 제어를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>

## <a name="introduction"></a><span data-ttu-id="4ee7e-109">소개</span><span class="sxs-lookup"><span data-stu-id="4ee7e-109">Introduction</span></span>

<span data-ttu-id="4ee7e-110">사용자가 데이터를 볼 수 있도록 허용 하는 웹 응용 프로그램 또는 데이터를 수정할 수 있는 단일 사용자만 포함 된 웹 응용 프로그램의 경우 두 명의 동시 사용자가 다른 사용자의 변경 내용을 실수로 덮어쓰는 위협 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="4ee7e-111">그러나 여러 사용자가 데이터를 업데이트 하거나 삭제할 수 있도록 하는 웹 응용 프로그램의 경우 한 사용자가 다른 동시 사용자와 충돌 하도록 수정할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="4ee7e-112">동시성 정책을 적용 하지 않은 경우 두 사용자가 동시에 단일 레코드를 편집 하는 경우 해당 변경 내용을 마지막으로 커밋한 사용자가 첫 번째에서 변경한 내용을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="4ee7e-113">예를 들어 두 사용자가 모두 응용 프로그램의 페이지를 방문 하 여 방문자가 GridView 컨트롤을 통해 제품을 업데이트 하 고 삭제할 수 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="4ee7e-114">동시에 GridView에서 편집 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="4ee7e-115">Jisun은 제품 이름을 "Chai Tea"로 변경 하 고 업데이트 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="4ee7e-116">Net result는 데이터베이스로 전송 되는 `UPDATE` 문으로, *모든* 제품의 업데이트 가능한 필드 `ProductName`를 설정 합니다 (Jisun은 한 필드만 업데이트 된 경우에도).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="4ee7e-117">이 시점에서 데이터베이스에는이 특정 제품에 대 한 "Chai Tea", 범주 음료, 공급자 Exotic Liquids 등의 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="4ee7e-118">그러나 Sam 화면에서 GridView는 편집 가능한 GridView 행의 제품 이름을 "Chai"로 계속 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="4ee7e-119">Jisun의 변경 내용이 커밋된 후 몇 초 후에 Sam이 범주를 조미료로 업데이트 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="4ee7e-120">이렇게 하면 제품 이름을 "Chai"로 설정 하는 데이터베이스와 해당 음료 범주 ID로 `CategoryID` 전송 되는 `UPDATE` 문이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="4ee7e-121">제품 이름에 대 한 jisun 변경을 덮어썼습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="4ee7e-122">그림 1에서는 이러한 일련의 이벤트를 그래픽으로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-122">Figure 1 graphically depicts this series of events.</span></span>

<span data-ttu-id="4ee7e-123">[두 사용자가 레코드를 동시에 업데이트 하는 경우를 ![한 사용자의 변경 내용이 다른 사용자의 변경 내용을 덮어쓸 가능성이 있습니다.](implementing-optimistic-concurrency-vb/_static/image2.png)](implementing-optimistic-concurrency-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-123">[![When Two Users Simultaneously Update a Record There s Potential for One User 's Changes to Overwrite the Other 's](implementing-optimistic-concurrency-vb/_static/image2.png)](implementing-optimistic-concurrency-vb/_static/image1.png)</span></span>

<span data-ttu-id="4ee7e-124">**그림 1**: 두 사용자가 동시에 레코드를 업데이트 하는 경우 한 사용자가 다른 사용자의 변경 내용을 덮어쓸 가능성이 있습니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image3.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User 's Changes to Overwrite the Other 's ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image3.png))</span></span>

<span data-ttu-id="4ee7e-125">마찬가지로, 두 사용자가 페이지를 방문 하는 경우 한 사용자가 다른 사용자에 의해 삭제 될 때 레코드를 업데이트 하 고 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="4ee7e-126">또는 사용자가 페이지를 로드 하 고 삭제 단추를 클릭할 때 사이에 다른 사용자가 해당 레코드의 내용을 수정 했을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="4ee7e-127">세 가지 [동시성 제어](http://en.wikipedia.org/wiki/Concurrency_control) 전략을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="4ee7e-128">**아무 작업도 수행 하지 않음** -동시 사용자가 동일한 레코드를 수정 하는 경우 마지막 커밋 (기본 동작)을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="4ee7e-129">[**낙관적 동시성**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) -현재 마다 동시성 충돌이 있을 수 있지만 이러한 충돌은 거의 발생 하지 않는 것으로 가정 합니다. 따라서 충돌이 발생 하는 경우 다른 사용자가 동일한 데이터를 수정 했기 때문에 변경 내용을 저장할 수 없다고 사용자에 게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="4ee7e-130">**비관적 동시성** -동시성 충돌이 일반적이 고 사용자가 다른 사용자의 동시 작업으로 인해 변경 내용이 저장 되지 않은 것으로 가정 합니다. 따라서 한 사용자가 레코드 업데이트를 시작 하면 해당 레코드를 잠가 사용자가 수정 내용을 커밋할 때까지 다른 사용자가 해당 레코드를 편집 하거나 삭제할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="4ee7e-131">지금까지 모든 자습서에서 기본 동시성 해결 전략을 사용 했습니다. 즉, 마지막 쓰기가 성공 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="4ee7e-132">이 자습서에서는 낙관적 동시성 제어를 구현 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="4ee7e-133">이 자습서 시리즈의 비관적 동시성 예는 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="4ee7e-134">비관적 동시성은 거의 사용 되지 않습니다. 이러한 잠금의 경우 적절 한 하므로 없는 경우 다른 사용자가 데이터를 업데이트 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="4ee7e-135">예를 들어 사용자가 편집을 위해 레코드를 잠근 다음 해당 날짜를 잠금 해제 하기 전에 남겨 둔 경우 원래 사용자가 업데이트를 반환 하 고 완료할 때까지 다른 사용자가 해당 레코드를 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="4ee7e-136">따라서 비관적 동시성을 사용 하는 경우 일반적으로 시간 제한이 발생 하 여 잠금을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="4ee7e-137">사용자가 주문 프로세스를 완료 하는 동안 짧은 기간 동안 특정 좌석 위치를 잠그는 티켓 판매 websites는 비관적 동시성 제어의 한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>

## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="4ee7e-138">1 단계: 낙관적 동시성을 구현 하는 방법 보기</span><span class="sxs-lookup"><span data-stu-id="4ee7e-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="4ee7e-139">낙관적 동시성 제어는 업데이트 또는 삭제 하는 레코드의 값이 업데이트 또는 삭제 프로세스가 시작 된 것과 동일한 지 확인 하는 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="4ee7e-140">예를 들어 편집 가능한 GridView에서 편집 단추를 클릭 하면 레코드의 값이 데이터베이스에서 읽어서 텍스트 상자와 다른 웹 컨트롤에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="4ee7e-141">이러한 원래 값은 GridView에 의해 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="4ee7e-142">나중에 사용자가 변경 하 고 업데이트 단추를 클릭 하면 원래 값과 새 값이 비즈니스 논리 계층으로 전송 된 다음 데이터 액세스 계층으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="4ee7e-143">데이터 액세스 계층은 사용자가 편집을 시작한 원래 값이 데이터베이스에 있는 값과 동일한 경우에만 레코드를 업데이트 하는 SQL 문을 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="4ee7e-144">그림 2에서는 이러한 이벤트 시퀀스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-144">Figure 2 depicts this sequence of events.</span></span>

<span data-ttu-id="4ee7e-145">[업데이트 또는 삭제에 대 한 ![성공 하려면 원래 값이 현재 데이터베이스 값과 같아야 합니다.](implementing-optimistic-concurrency-vb/_static/image5.png)](implementing-optimistic-concurrency-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-vb/_static/image5.png)](implementing-optimistic-concurrency-vb/_static/image4.png)</span></span>

<span data-ttu-id="4ee7e-146">**그림 2**: 업데이트 또는 삭제가 성공 하려면 원래 값이 현재 데이터베이스 값과 같아야 합니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image6.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image6.png))</span></span>

<span data-ttu-id="4ee7e-147">낙관적 동시성을 구현 하는 방법에는 여러 가지가 있습니다 (여러 옵션에 대 한 간략 한 개요는 [Peter Bromberg](http://peterbromberg.net/)의 [낙관적 동시성 업데이트 논리](http://www.eggheadcafe.com/articles/20050719.asp) 참조).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="4ee7e-148">ADO.NET 형식화 된 데이터 집합은 확인란의 틱 으로만 구성할 수 있는 하나의 구현을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="4ee7e-149">형식화 된 데이터 집합에서 TableAdapter에 대해 낙관적 동시성을 사용 하도록 설정 하면 TableAdapter의 `UPDATE` 및 `DELETE` 문을 보강 하 여 `WHERE` 절의 모든 원래 값에 대 한 비교를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="4ee7e-150">예를 들어 다음 `UPDATE` 문은 현재 데이터베이스 값이 GridView의 레코드를 업데이트할 때 원래 검색 된 값과 동일한 경우에만 제품의 이름과 가격을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="4ee7e-151">`@ProductName` 및 `@UnitPrice` 매개 변수는 사용자가 입력 한 새 값을 포함 하는 반면 `@original_ProductName` 및 `@original_UnitPrice`에는 편집 단추를 클릭 했을 때 원래 GridView로 로드 된 값이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-vb/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="4ee7e-152">이 `UPDATE` 문은 가독성을 위해 간소화 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="4ee7e-153">실제로 `WHERE` 절의 `UnitPrice` 검사는 `NULL`를 포함 하 고 `NULL = NULL`에서 항상 False를 반환 하는지 여부를 확인 하기 `UnitPrice` 때문에 더 많은 관련이 있습니다 (대신 `IS NULL`를 사용 해야 함).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>

<span data-ttu-id="4ee7e-154">다른 기본 `UPDATE` 문을 사용 하는 것 외에도, 낙관적 동시성을 사용 하도록 TableAdapter를 구성 하는 것은 DB 직접 메서드의 서명을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="4ee7e-155">첫 번째 자습서를 통해 [*데이터 액세스 계층을 만들고*](../introduction/creating-a-data-access-layer-cs.md), 해당 DB 직접 메서드는 스칼라 값 목록을 강력한 형식의 DataRow 또는 DataTable 인스턴스가 아닌 입력 매개 변수로 허용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="4ee7e-156">낙관적 동시성을 사용 하는 경우 DB direct `Update()` 및 `Delete()` 메서드에 원래 값에 대 한 입력 매개 변수도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="4ee7e-157">또한 batch 업데이트 패턴을 사용 하기 위한 BLL의 코드 `Update()` (스칼라 값이 아닌 Datarow 및 Datatable를 허용 하는 메서드 오버 로드)도 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="4ee7e-158">낙관적 동시성을 사용 하기 위해 기존 DAL의 Tableadapter를 확장 하는 대신 낙관적 동시성을 사용 하도록 변경 하는 것이 좋습니다 .이는 낙관적 동시성을 사용 하는 `Products` TableAdapter를 추가할 `NorthwindOptimisticConcurrency`이라는 새 형식화 된 데이터 집합을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="4ee7e-159">다음으로 낙관적 동시성 DAL을 지원 하기 위해 적절 한 수정이 있는 `ProductsOptimisticConcurrencyBLL` 비즈니스 논리 계층 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="4ee7e-160">이 기반이 배치 된 후에는 ASP.NET 페이지를 만들 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="4ee7e-161">2 단계: 낙관적 동시성을 지 원하는 데이터 액세스 계층 만들기</span><span class="sxs-lookup"><span data-stu-id="4ee7e-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="4ee7e-162">새 형식화 된 데이터 집합을 만들려면 `App_Code` 폴더 내의 `DAL` 폴더를 마우스 오른쪽 단추로 클릭 하 고 `NorthwindOptimisticConcurrency`라는 새 데이터 집합을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="4ee7e-163">첫 번째 자습서에서 살펴본 것 처럼이 작업을 수행 하면 형식화 된 데이터 집합에 새 TableAdapter가 추가 되어 TableAdapter 구성 마법사가 자동으로 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="4ee7e-164">첫 번째 화면에는 연결할 데이터베이스를 지정 하 라는 메시지가 표시 됩니다.-`Web.config`에서 `NORTHWNDConnectionString` 설정을 사용 하 여 동일한 Northwind 데이터베이스에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>

<span data-ttu-id="4ee7e-165">[동일한 Northwind 데이터베이스에 연결 ![](implementing-optimistic-concurrency-vb/_static/image8.png)](implementing-optimistic-concurrency-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-vb/_static/image8.png)](implementing-optimistic-concurrency-vb/_static/image7.png)</span></span>

<span data-ttu-id="4ee7e-166">**그림 3**: 동일한 Northwind 데이터베이스에 연결 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image9.png))</span></span>

<span data-ttu-id="4ee7e-167">다음으로, 임시 SQL 문, 새 저장 프로시저 또는 기존 저장 프로시저를 통해 데이터를 쿼리 하는 방법에 대 한 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="4ee7e-168">원래 DAL에서 임시 SQL 쿼리를 사용 했으므로 여기에서이 옵션을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>

<span data-ttu-id="4ee7e-169">[임시 SQL 문을 사용 하 여 검색할 데이터를 지정 ![](implementing-optimistic-concurrency-vb/_static/image11.png)](implementing-optimistic-concurrency-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-vb/_static/image11.png)](implementing-optimistic-concurrency-vb/_static/image10.png)</span></span>

<span data-ttu-id="4ee7e-170">**그림 4**: 임시 SQL 문을 사용 하 여 검색할 데이터 지정 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image12.png))</span></span>

<span data-ttu-id="4ee7e-171">다음 화면에서 제품 정보를 검색 하는 데 사용할 SQL 쿼리를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="4ee7e-172">원래 DAL의 `Products` TableAdapter에 사용 되는 것과 정확히 동일한 SQL 쿼리를 사용 하 여 제품의 공급자 및 범주 이름과 함께 모든 `Product` 열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-vb/samples/sample2.sql)]

<span data-ttu-id="4ee7e-173">[원본 DAL의 TableAdapter 제품에서 동일한 SQL 쿼리를 사용 ![](implementing-optimistic-concurrency-vb/_static/image14.png)](implementing-optimistic-concurrency-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-vb/_static/image14.png)](implementing-optimistic-concurrency-vb/_static/image13.png)</span></span>

<span data-ttu-id="4ee7e-174">**그림 5**: 원래 DAL에서 `Products` TableAdapter와 동일한 SQL 쿼리 사용 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image15.png))</span></span>

<span data-ttu-id="4ee7e-175">다음 화면으로 이동 하기 전에 고급 옵션 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="4ee7e-176">이 TableAdapter에서 낙관적 동시성 제어를 사용 하도록 하려면 "낙관적 동시성 사용" 확인란을 선택 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>

<span data-ttu-id="4ee7e-177">[낙관적 동시성 제어 사용 &quot;를 선택 하 여 낙관적 동시성 제어를 사용 하도록 설정 ![&quot; 확인란](implementing-optimistic-concurrency-vb/_static/image17.png)](implementing-optimistic-concurrency-vb/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-vb/_static/image17.png)](implementing-optimistic-concurrency-vb/_static/image16.png)</span></span>

<span data-ttu-id="4ee7e-178">**그림 6**: "낙관적 동시성 사용" 확인란을 선택 하 여 낙관적 동시성 제어 사용 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image18.png))</span></span>

<span data-ttu-id="4ee7e-179">마지막으로 TableAdapter가 DataTable을 채우고 DataTable을 반환 하는 데이터 액세스 패턴을 사용 하도록 지정 합니다. 또한 DB 직접 메서드를 만들어야 함을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="4ee7e-180">원래 DAL에서 사용한 명명 규칙을 미러 하기 위해 GetData에서 GetProducts로 DataTable 패턴을 반환 하도록 메서드 이름을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>

<span data-ttu-id="4ee7e-181">[TableAdapter가 모든 데이터 액세스 패턴을 활용 하는 ![](implementing-optimistic-concurrency-vb/_static/image20.png)](implementing-optimistic-concurrency-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-vb/_static/image20.png)](implementing-optimistic-concurrency-vb/_static/image19.png)</span></span>

<span data-ttu-id="4ee7e-182">**그림 7**: TableAdapter에서 모든 데이터 액세스 패턴을 사용 하도록[하려면 (전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image21.png))</span></span>

<span data-ttu-id="4ee7e-183">마법사를 완료 한 후 데이터 집합 디자이너에는 강력한 형식의 `Products` DataTable 및 TableAdapter가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="4ee7e-184">Datatable의 제목 표시줄을 마우스 오른쪽 단추로 클릭 하 고 상황에 맞는 메뉴에서 이름 바꾸기를 선택 하 여 DataTable의 이름을 `Products`에서 `ProductsOptimisticConcurrency`로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>

<span data-ttu-id="4ee7e-185">[DataTable 및 TableAdapter가 형식화 된 데이터 집합에 추가 ![](implementing-optimistic-concurrency-vb/_static/image23.png)](implementing-optimistic-concurrency-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-vb/_static/image23.png)](implementing-optimistic-concurrency-vb/_static/image22.png)</span></span>

<span data-ttu-id="4ee7e-186">**그림 8**: DataTable 및 TableAdapter가 형식화 된 데이터 집합에 추가 되었습니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image24.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image24.png))</span></span>

<span data-ttu-id="4ee7e-187">`UPDATE`와 `DELETE` 간의 차이점을 확인 하려면 tableadapter (낙관적 동시성을 사용 하는)와 Products (`ProductsOptimisticConcurrency`) 간의 차이점을 확인 하 고 tableadapter를 클릭 한 다음 속성 창로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="4ee7e-188">`DeleteCommand` 및 `UpdateCommand` 속성 `CommandText` 하위 속성에서 DAL의 업데이트 또는 삭제 관련 메서드가 호출 될 때 데이터베이스로 전송 되는 실제 SQL 구문을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="4ee7e-189">`ProductsOptimisticConcurrency` TableAdapter의 경우 사용 되는 `DELETE` 문은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-vb/samples/sample3.sql)]

<span data-ttu-id="4ee7e-190">원래 DAL의 제품 TableAdapter에 대 한 `DELETE` 문은 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-vb/samples/sample4.sql)]

<span data-ttu-id="4ee7e-191">여기에서 볼 수 있듯이 낙관적 동시성을 사용 하는 TableAdapter에 대 한 `DELETE` 문의 `WHERE` 절에는 GridView (또는 DetailsView 또는 FormView)가 마지막으로 채워질 때의 원래 값과 `Product` 테이블의 기존 열 값을 비교 하는 작업이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="4ee7e-192">`ProductID`, `ProductName`및 `Discontinued` 이외의 모든 필드에는 `NULL` 값이 있을 수 있으므로 `NULL` 절의 `WHERE` 값을 올바르게 비교 하기 위해 추가 매개 변수 및 검사가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="4ee7e-193">ASP.NET 페이지는 제품 정보만 업데이트 하 고 삭제할 수 있으므로이 자습서의 낙관적 동시성 지원 데이터 집합에 추가 Datatable를 추가 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="4ee7e-194">그러나 `ProductsOptimisticConcurrency` TableAdapter에 `GetProductByProductID(productID)` 메서드를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="4ee7e-195">이렇게 하려면 TableAdapter의 제목 표시줄을 마우스 오른쪽 단추로 클릭 하 고 `Fill` 바로 위의 영역 및 메서드 이름 `GetProducts` 하 고 상황에 맞는 메뉴에서 쿼리 추가를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="4ee7e-196">TableAdapter 쿼리 구성 마법사가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="4ee7e-197">TableAdapter의 초기 구성과 마찬가지로 임시 SQL 문을 사용 하 여 `GetProductByProductID(productID)` 메서드를 만들도록 옵트인 합니다 (그림 4 참조).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="4ee7e-198">`GetProductByProductID(productID)` 메서드는 특정 제품에 대 한 정보를 반환 하므로이 쿼리가 행을 반환 하는 `SELECT` 쿼리 유형인 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>

<span data-ttu-id="4ee7e-199">[행을 반환 하는 &quot;SELECT로 쿼리 유형을 표시 ![&quot;](implementing-optimistic-concurrency-vb/_static/image26.png)](implementing-optimistic-concurrency-vb/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-vb/_static/image26.png)](implementing-optimistic-concurrency-vb/_static/image25.png)</span></span>

<span data-ttu-id="4ee7e-200">**그림 9**: 쿼리 유형을 "행을 반환 하는`SELECT`"로 표시 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image27.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image27.png))</span></span>

<span data-ttu-id="4ee7e-201">다음 화면에서 TableAdapter의 기본 쿼리를 미리 로드 하 여 사용할 SQL 쿼리를 묻는 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="4ee7e-202">그림 10에 표시 된 것 처럼 `WHERE ProductID = @ProductID`절을 포함 하도록 기존 쿼리를 보강 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>

<span data-ttu-id="4ee7e-203">[![특정 제품 레코드를 반환 하기 위해 미리 로드 된 쿼리에 WHERE 절을 추가 합니다.](implementing-optimistic-concurrency-vb/_static/image29.png)](implementing-optimistic-concurrency-vb/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-vb/_static/image29.png)](implementing-optimistic-concurrency-vb/_static/image28.png)</span></span>

<span data-ttu-id="4ee7e-204">**그림 10**: 미리 로드 된 쿼리에 `WHERE` 절을 추가 하 여 특정 제품 레코드 반환 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image30.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image30.png))</span></span>

<span data-ttu-id="4ee7e-205">마지막으로 생성 된 메서드 이름을 `FillByProductID`로 변경 하 고 `GetProductByProductID`합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>

<span data-ttu-id="4ee7e-206">[메서드의 이름을 FillByProductID 및 Getproductid Byproductid로 바꾸기 ![](implementing-optimistic-concurrency-vb/_static/image32.png)](implementing-optimistic-concurrency-vb/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-vb/_static/image32.png)](implementing-optimistic-concurrency-vb/_static/image31.png)</span></span>

<span data-ttu-id="4ee7e-207">**그림 11**: `FillByProductID` 및 `GetProductByProductID` 메서드 이름 바꾸기 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image33.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image33.png))</span></span>

<span data-ttu-id="4ee7e-208">이 마법사를 완료 하면 TableAdapter에는 데이터를 검색 하는 두 가지 메서드인 `GetProducts()`이 포함 됩니다 .이는 *모든* 제품을 반환 합니다. 지정 된 제품을 반환 하는 및를 `GetProductByProductID(productID)`합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="4ee7e-209">3 단계: 낙관적 동시성 사용 DAL에 대 한 비즈니스 논리 계층 만들기</span><span class="sxs-lookup"><span data-stu-id="4ee7e-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="4ee7e-210">기존 `ProductsBLL` 클래스에는 batch 업데이트 및 DB 직접 패턴을 모두 사용 하는 예가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="4ee7e-211">`AddProduct` 메서드와 `UpdateProduct` 오버 로드는 모두 일괄 업데이트 패턴을 사용 하 여 `ProductRow` 인스턴스를 TableAdapter의 업데이트 메서드로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="4ee7e-212">반면에 `DeleteProduct` 메서드는 DB direct 패턴을 사용 하 여 TableAdapter의 `Delete(productID)` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="4ee7e-213">새 `ProductsOptimisticConcurrency` TableAdapter를 사용 하는 경우 DB direct 메서드는 이제 원래 값도 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="4ee7e-214">예를 들어 `Delete` 메서드는 이제 원래 `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`의 입력 매개 변수를 예상 합니다.`Discontinued`</span><span class="sxs-lookup"><span data-stu-id="4ee7e-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="4ee7e-215">데이터베이스에 전송 된 `DELETE` 문의 `WHERE` 절에 이러한 추가 입력 매개 변수의 값을 사용 하 고 데이터베이스의 현재 값이 원래 값으로 매핑되는 경우에만 지정 된 레코드만 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="4ee7e-216">일괄 처리 업데이트 패턴에 사용 된 TableAdapter의 `Update` 메서드에 대 한 메서드 시그니처는 변경 되지 않지만 원래 값과 새 값을 기록 하는 데 필요한 코드는입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="4ee7e-217">따라서 기존 `ProductsBLL` 클래스에서 낙관적 동시성을 사용 하는 DAL을 사용 하는 대신 새 DAL 작업을 위한 새로운 비즈니스 논리 계층 클래스를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="4ee7e-218">`ProductsOptimisticConcurrencyBLL` 라는 클래스를 `App_Code` 폴더 내의 `BLL` 폴더에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>

![ProductsOptimisticConcurrencyBLL 클래스를 BLL 폴더에 추가 합니다.](implementing-optimistic-concurrency-vb/_static/image34.png)

<span data-ttu-id="4ee7e-220">**그림 12**: BLL 폴더에 `ProductsOptimisticConcurrencyBLL` 클래스 추가</span><span class="sxs-lookup"><span data-stu-id="4ee7e-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>

<span data-ttu-id="4ee7e-221">그런 다음 `ProductsOptimisticConcurrencyBLL` 클래스에 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>

[!code-vb[Main](implementing-optimistic-concurrency-vb/samples/sample5.vb)]

<span data-ttu-id="4ee7e-222">클래스 선언 시작 부분 위에 using `NorthwindOptimisticConcurrencyTableAdapters` 문을 적어둡니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="4ee7e-223">`NorthwindOptimisticConcurrencyTableAdapters` 네임 스페이스는 DAL의 메서드를 제공 하는 `ProductsOptimisticConcurrencyTableAdapter` 클래스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="4ee7e-224">또한 클래스 선언 이전에는이 클래스를 ObjectDataSource 마법사의 드롭다운 목록에 포함 하도록 Visual Studio에 지시 하는 `System.ComponentModel.DataObject` 특성을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="4ee7e-225">`ProductsOptimisticConcurrencyBLL`의 `Adapter` 속성은 `ProductsOptimisticConcurrencyTableAdapter` 클래스의 인스턴스에 대 한 빠른 액세스를 제공 하며 원래 BLL 클래스 (`ProductsBLL`, `CategoriesBLL`등)에서 사용 되는 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="4ee7e-226">마지막으로 `GetProducts()` 메서드는 DAL의 `GetProducts()` 메서드를 호출 하 고 데이터베이스의 각 제품 레코드에 대해 `ProductsOptimisticConcurrencyRow` 인스턴스로 채워진 `ProductsOptimisticConcurrencyDataTable` 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="4ee7e-227">낙관적 동시성을 사용 하는 DB Direct 패턴을 사용 하 여 제품 삭제</span><span class="sxs-lookup"><span data-stu-id="4ee7e-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="4ee7e-228">낙관적 동시성을 사용 하는 DAL에 대해 DB direct 패턴을 사용 하는 경우 메서드에 새 값과 원래 값이 전달 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="4ee7e-229">삭제의 경우 새 값이 없으므로 원래 값만 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="4ee7e-230">그러면 BLL에서 모든 원래 매개 변수를 입력 매개 변수로 수락 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="4ee7e-231">`ProductsOptimisticConcurrencyBLL` 클래스의 `DeleteProduct` 메서드가 DB direct 메서드를 사용 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="4ee7e-232">즉,이 메서드는 다음 코드에 표시 된 것 처럼 모든 10 개의 제품 데이터 필드를 입력 매개 변수로 사용 하 고 DAL에 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>

[!code-vb[Main](implementing-optimistic-concurrency-vb/samples/sample6.vb)]

<span data-ttu-id="4ee7e-233">사용자가 삭제 단추를 클릭할 때 원래 값 (또는 DetailsView 또는 FormView)에 마지막으로 로드 된 값이 데이터베이스의 값과 다를 경우에는 `WHERE` 절이 데이터베이스 레코드와 일치 하지 않으며 레코드는 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="4ee7e-234">따라서 TableAdapter의 `Delete` 메서드는 `0`를 반환 하 고 BLL의 `DeleteProduct` 메서드는 `false`을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="4ee7e-235">낙관적 동시성을 사용 하 여 Batch 업데이트 패턴을 사용 하 여 제품 업데이트</span><span class="sxs-lookup"><span data-stu-id="4ee7e-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="4ee7e-236">앞에서 설명한 대로 일괄 처리 업데이트 패턴에 대 한 TableAdapter의 `Update` 메서드는 낙관적 동시성을 사용 하는지 여부에 관계 없이 동일한 메서드 시그니처를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="4ee7e-237">즉, `Update` 메서드에는 DataRow, Datarow 배열, DataTable 또는 형식화 된 데이터 집합이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="4ee7e-238">원래 값을 지정 하기 위한 추가 입력 매개 변수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="4ee7e-239">DataTable은 해당 DataRow의 원래 값과 수정 된 값을 추적 하기 때문에 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="4ee7e-240">DAL이 해당 `UPDATE` 문을 발급 하면 `@original_ColumnName` 매개 변수가 DataRow의 원래 값으로 채워지고, `@ColumnName` 매개 변수는 DataRow의 수정 된 값으로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="4ee7e-241">기존의 비 낙관적 동시성 DAL을 사용 하는 `ProductsBLL` 클래스에서 batch 업데이트 패턴을 사용 하 여 제품 정보를 업데이트 하는 경우 코드에서 다음과 같은 이벤트 시퀀스를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="4ee7e-242">TableAdapter의 `GetProductByProductID(productID)` 메서드를 사용 하 여 `ProductRow` 인스턴스로 현재 데이터베이스 제품 정보를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="4ee7e-243">1 단계의 `ProductRow` 인스턴스에 새 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="4ee7e-244">TableAdapter의 `Update` 메서드를 호출 하 여 `ProductRow` 인스턴스를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="4ee7e-245">그러나이 일련의 단계는 1 단계에서 채운 `ProductRow` 데이터베이스에서 직접 채워지기 때문에 낙관적 동시성을 올바르게 지원 하지 않습니다. 즉, DataRow에서 사용 되는 원래 값이 데이터베이스에 현재 존재 하는 값이 고 편집 프로세스 시작 시 GridView에 바인딩된 값이 아닌 경우에는 낙관적 동시성을 올바르게 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="4ee7e-246">대신 낙관적 동시성을 사용 하는 DAL을 사용 하는 경우 다음 단계를 사용 하도록 `UpdateProduct` 메서드 오버 로드를 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="4ee7e-247">TableAdapter의 `GetProductByProductID(productID)` 메서드를 사용 하 여 `ProductsOptimisticConcurrencyRow` 인스턴스로 현재 데이터베이스 제품 정보를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="4ee7e-248">1 단계의 `ProductsOptimisticConcurrencyRow` 인스턴스에 *원래* 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="4ee7e-249">`ProductsOptimisticConcurrencyRow` 인스턴스의 `AcceptChanges()` 메서드를 호출 합니다 .이 메서드는 DataRow에 현재 값이 "원본" 임을 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="4ee7e-250">`ProductsOptimisticConcurrencyRow` 인스턴스에 *새* 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="4ee7e-251">TableAdapter의 `Update` 메서드를 호출 하 여 `ProductsOptimisticConcurrencyRow` 인스턴스를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="4ee7e-252">1 단계는 지정 된 제품 레코드에 대 한 모든 현재 데이터베이스 값을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="4ee7e-253">이 단계는 2 단계에서 이러한 값을 덮어쓸 때 *모든* 제품 열을 업데이트 하는 `UpdateProduct` 오버 로드에서 불필요 하지만 열 값의 하위 집합만 입력 매개 변수로 전달 되는 경우에는 이러한 오버 로드에 반드시 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="4ee7e-254">`ProductsOptimisticConcurrencyRow` 인스턴스에 원래 값이 할당 되 면 `AcceptChanges()` 메서드가 호출 됩니다 .이 메서드는 현재 DataRow 값을 `UPDATE` 문의 `@original_ColumnName` 매개 변수에 사용할 원래 값으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="4ee7e-255">그런 다음 `ProductsOptimisticConcurrencyRow`에 새 매개 변수 값을 할당 하 고 마지막으로 `Update` 메서드를 호출 하 여 DataRow를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="4ee7e-256">다음 코드에서는 모든 제품 데이터 필드를 입력 매개 변수로 허용 하는 `UpdateProduct` 오버 로드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="4ee7e-257">여기에 표시 되지 않은 경우이 자습서에 대 한 다운로드에 포함 된 `ProductsOptimisticConcurrencyBLL` 클래스에는 제품의 이름과 가격만 입력 매개 변수로 허용 하는 `UpdateProduct` 오버 로드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>

[!code-vb[Main](implementing-optimistic-concurrency-vb/samples/sample7.vb)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="4ee7e-258">4 단계: ASP.NET 페이지의 원래 값과 새 값을 BLL 메서드로 전달</span><span class="sxs-lookup"><span data-stu-id="4ee7e-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="4ee7e-259">DAL 및 BLL이 완료 되 면 시스템에 기본 제공 되는 낙관적 동시성 논리를 활용할 수 있는 ASP.NET 페이지를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="4ee7e-260">특히 데이터 웹 컨트롤 (GridView, DetailsView 또는 FormView)은 원래 값을 명심 해야 하며 ObjectDataSource는 두 값 집합을 모두 비즈니스 논리 계층에 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="4ee7e-261">또한 동시성 위반을 정상적으로 처리 하도록 ASP.NET 페이지를 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="4ee7e-262">먼저 `EditInsertDelete` 폴더에서 `OptimisticConcurrency.aspx` 페이지를 열고 GridView를 디자이너에 추가 하 여 `ID` 속성을 `ProductsGrid`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="4ee7e-263">GridView의 스마트 태그에서 `ProductsOptimisticConcurrencyDataSource`라는 새 ObjectDataSource를 만들도록 옵트인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="4ee7e-264">이 ObjectDataSource에서 낙관적 동시성을 지 원하는 DAL을 사용 하려고 하므로 `ProductsOptimisticConcurrencyBLL` 개체를 사용 하도록 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>

<span data-ttu-id="4ee7e-265">[ObjectDataSource에서 ProductsOptimisticConcurrencyBLL 개체를 사용 ![](implementing-optimistic-concurrency-vb/_static/image36.png)](implementing-optimistic-concurrency-vb/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-vb/_static/image36.png)](implementing-optimistic-concurrency-vb/_static/image35.png)</span></span>

<span data-ttu-id="4ee7e-266">**그림 13**: ObjectDataSource에서 `ProductsOptimisticConcurrencyBLL` 개체 사용 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image37.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image37.png))</span></span>

<span data-ttu-id="4ee7e-267">마법사의 드롭다운 목록에서 `GetProducts`, `UpdateProduct`및 `DeleteProduct` 메서드를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="4ee7e-268">UpdateProduct 메서드의 경우 모든 제품의 데이터 필드를 허용 하는 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="4ee7e-269">ObjectDataSource 컨트롤의 속성 구성</span><span class="sxs-lookup"><span data-stu-id="4ee7e-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="4ee7e-270">마법사를 완료 한 후 ObjectDataSource의 선언 태그는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-vb/samples/sample8.aspx)]

<span data-ttu-id="4ee7e-271">여기에서 볼 수 있듯이 `DeleteParameters` 컬렉션에는 `ProductsOptimisticConcurrencyBLL` 클래스의 `DeleteProduct` 메서드에서 각각의 10 개의 입력 매개 변수에 대 한 `Parameter` 인스턴스가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="4ee7e-272">마찬가지로 `UpdateParameters` 컬렉션에는 `UpdateProduct`의 각 입력 매개 변수에 대 한 `Parameter` 인스턴스가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="4ee7e-273">데이터 수정과 관련 된 이전 자습서의 경우,이 속성은이 시점에서 ObjectDataSource의 `OldValuesParameterFormatString` 속성을 제거 합니다 .이 속성은 BLL 메서드에 이전 (또는 원래) 값이 전달 될 것으로 예상 하 고 새 값을 전달 한다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="4ee7e-274">또한이 속성 값은 원래 값에 대 한 입력 매개 변수 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="4ee7e-275">원래 값을 BLL에 전달 하기 때문에이 속성을 제거 *하지* 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="4ee7e-276">`OldValuesParameterFormatString` 속성의 값은 원래 값이 필요한 BLL의 입력 매개 변수 이름에 매핑되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="4ee7e-277">이러한 매개 변수를 `original_productName`, `original_supplierID`등으로 명명 했으므로 `OldValuesParameterFormatString` 속성 값을 `original_{0}`로 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="4ee7e-278">그러나 BLL 메서드의 입력 매개 변수에 `old_productName`, `old_supplierID`등과 같은 이름이 있는 경우 `OldValuesParameterFormatString` 속성을 `old_{0}`로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>

<span data-ttu-id="4ee7e-279">ObjectDataSource가 원래 값을 BLL 메서드에 올바르게 전달 하기 위해 수행 해야 하는 최종 속성 설정이 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="4ee7e-280">ObjectDataSource에는 다음 [두 값 중 하나](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx)에 할당할 수 있는 [ConflictDetection 속성이](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="4ee7e-281">`OverwriteChanges`-기본값입니다. 는 원래 값을 BLL 메서드의 원래 입력 매개 변수로 보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="4ee7e-282">`CompareAllValues`-원래 값을 BLL 메서드로 보냅니다. 낙관적 동시성을 사용 하는 경우이 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="4ee7e-283">잠시 시간을 사용 하 여 `ConflictDetection` 속성을 `CompareAllValues`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="4ee7e-284">GridView의 속성 및 필드 구성</span><span class="sxs-lookup"><span data-stu-id="4ee7e-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="4ee7e-285">ObjectDataSource의 속성이 제대로 구성 된 상태에서 GridView를 설정 하는 데 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="4ee7e-286">먼저 GridView에서 편집 및 삭제를 지원 하기 때문에 GridView의 스마트 태그에서 편집 사용 및 삭제할 수 있습니다 확인란을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="4ee7e-287">그러면 `ShowEditButton`와 `ShowDeleteButton` 모두 `true`으로 설정 된 CommandField가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="4ee7e-288">`ProductsOptimisticConcurrencyDataSource` ObjectDataSource에 바인딩되는 경우 GridView는 각 제품의 데이터 필드에 대 한 필드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="4ee7e-289">이러한 GridView를 편집할 수 있지만 사용자 환경에는 무엇이 든 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="4ee7e-290">`CategoryID` 및 `SupplierID` BoundFields는 입력란으로 렌더링 되므로 사용자가 적절 한 범주와 공급 업체를 ID 번호로 입력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="4ee7e-291">숫자 필드에 대 한 서식은 없으며, 제품 이름을 제공 하 고 단가, 재고 단위, 주문 단위 및 다시 정렬 수준 값을 모두 적절 한 숫자 값으로 지정 하 고, 보다 크거나 같은지 확인 하는 유효성 검사 컨트롤은 없습니다. 0입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="4ee7e-292">*편집 및 삽입 인터페이스에 유효성 검사 컨트롤 추가* 및 *데이터 수정 인터페이스* 자습서 사용자 지정에서 설명한 대로 BoundFields를 템플릿 필드로 바꿔 사용자 인터페이스를 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="4ee7e-293">다음 방법으로이 GridView 및 편집 인터페이스를 수정 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="4ee7e-294">`ProductID`, `SupplierName`및 `CategoryName` BoundFields 제거 됨</span><span class="sxs-lookup"><span data-stu-id="4ee7e-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="4ee7e-295">`ProductName` BoundField를 Templatefield로 변환로 변환 하 고 RequiredFieldValidation 컨트롤을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="4ee7e-296">`CategoryID` 및 `SupplierID`를 템플릿 필드로 변환 하 고 텍스트 상자 대신 Dropdownlist를 사용 하도록 편집 인터페이스를 조정 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="4ee7e-297">이러한 템플릿 필드의 `ItemTemplates`에는 `CategoryName` 및 `SupplierName` 데이터 필드가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="4ee7e-298">`UnitPrice`, `UnitsInStock`, `UnitsOnOrder`및 `ReorderLevel` BoundFields를 템플릿 필드로 변환 하 고 CompareValidator 컨트롤을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="4ee7e-299">이전 자습서에서 이러한 작업을 수행 하는 방법을 이미 검토 했으므로 여기에서 최종 선언 구문을 나열 하 고 구현 방법을 그대로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-vb/samples/sample9.aspx)]

<span data-ttu-id="4ee7e-300">완전히 작동 하는 예제는 매우 가깝습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="4ee7e-301">그러나 몇 가지 미묘한 문제로 인해 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="4ee7e-302">또한 동시성 위반이 발생 했을 때 사용자에 게 경고 하는 인터페이스가 여전히 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="4ee7e-303">데이터 웹 컨트롤에서 원래 값을 ObjectDataSource (BLL에 전달 됨)에 올바르게 전달 하려면 GridView의 `EnableViewState` 속성이 `true` (기본값)로 설정 되어 있는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="4ee7e-304">뷰 상태를 사용 하지 않도록 설정 하면 다시 게시할 때 원래 값이 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-304">If you disable view state, the original values are lost on postback.</span></span>

## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="4ee7e-305">ObjectDataSource에 올바른 원래 값 전달</span><span class="sxs-lookup"><span data-stu-id="4ee7e-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="4ee7e-306">GridView가 구성 된 방법과 관련 된 몇 가지 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="4ee7e-307">ObjectDataSource의 `ConflictDetection` 속성이 `CompareAllValues`으로 설정 된 경우 (예를 들어) objectdatasource의 `Update()` 또는 `Delete()` 메서드가 GridView (또는 DetailsView 또는 FormView)에 의해 호출 되 면 ObjectDataSource에서 GridView의 원래 값을 적절 한 `Parameter` 인스턴스로 복사 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="4ee7e-308">이 프로세스를 그래픽으로 표시 하려면 그림 2를 다시 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="4ee7e-309">특히 GridView의 원래 값에는 데이터가 GridView에 바인딩될 때마다 양방향 데이터 바인딩 문에서 값이 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="4ee7e-310">따라서 필수적인 원래 값은 모두 양방향 데이터 바인딩을 통해 캡처되고 변환 가능한 형식으로 제공 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="4ee7e-311">이 사항이 중요 한 이유를 확인 하려면 잠시 시간을 들 여 브라우저에서 페이지를 방문 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="4ee7e-312">예상 대로 GridView는 맨 왼쪽 열에 편집 및 삭제 단추가 있는 각 제품을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>

<span data-ttu-id="4ee7e-313">[GridView에 제품이 나열 ![](implementing-optimistic-concurrency-vb/_static/image39.png)](implementing-optimistic-concurrency-vb/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-vb/_static/image39.png)](implementing-optimistic-concurrency-vb/_static/image38.png)</span></span>

<span data-ttu-id="4ee7e-314">**그림 14**: 제품이 GridView에 나열 되어 있습니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image40.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image40.png))</span></span>

<span data-ttu-id="4ee7e-315">모든 제품에 대 한 삭제 단추를 클릭 하면 `FormatException` throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>

<span data-ttu-id="4ee7e-316">[FormatException에서 제품 결과를 삭제 하는 ![](implementing-optimistic-concurrency-vb/_static/image42.png)](implementing-optimistic-concurrency-vb/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-vb/_static/image42.png)](implementing-optimistic-concurrency-vb/_static/image41.png)</span></span>

<span data-ttu-id="4ee7e-317">**그림 15**: `FormatException` ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image43.png))에서 제품을 삭제 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image43.png))</span></span>

<span data-ttu-id="4ee7e-318">ObjectDataSource가 원래 `UnitPrice` 값에서 읽으려고 할 때 `FormatException` 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="4ee7e-319">`ItemTemplate`에는 통화 (`<%# Bind("UnitPrice", "{0:C}") %>`)로 서식이 지정 된 `UnitPrice` 있으므로 $19.95와 같은 통화 기호가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="4ee7e-320">`FormatException`은 ObjectDataSource가이 문자열을 `decimal`변환 하려고 할 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="4ee7e-321">이 문제를 방지 하기 위해 다음과 같은 다양 한 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="4ee7e-322">`ItemTemplate`에서 통화 서식을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="4ee7e-323">즉, `<%# Bind("UnitPrice", "{0:C}") %>`를 사용 하는 대신 `<%# Bind("UnitPrice") %>`를 사용 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="4ee7e-324">이로 인해 가격은 더 이상 서식이 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="4ee7e-325">`ItemTemplate`통화로 형식이 지정 된 `UnitPrice` 표시 하지만 `Eval` 키워드를 사용 하 여이를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="4ee7e-326">`Eval`는 단방향 데이터 바인딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="4ee7e-327">여전히 원래 값에 대 한 `UnitPrice` 값을 제공 해야 하기 때문에 `ItemTemplate`에 양방향 데이터 바인딩 문이 필요 하지만 `Visible` 속성이 `false`로 설정 된 레이블 웹 컨트롤에 배치 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="4ee7e-328">ItemTemplate에서 다음 태그를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-328">We could use the following markup in the ItemTemplate:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-vb/samples/sample10.aspx)]

- <span data-ttu-id="4ee7e-329">`<%# Bind("UnitPrice") %>`를 사용 하 여 `ItemTemplate`에서 통화 서식을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="4ee7e-330">GridView의 `RowDataBound` 이벤트 처리기에서 `UnitPrice` 값이 표시 되는 Label 웹 컨트롤에 프로그래밍 방식으로 액세스 하 고 `Text` 속성을 형식이 지정 된 버전으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="4ee7e-331">`UnitPrice` 서식을 통화로 그대로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="4ee7e-332">GridView의 `RowDeleting` 이벤트 처리기에서 `Decimal.Parse`을 사용 하 여 기존의 원래 `UnitPrice` 값 ($19.95)을 실제 10 진수 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="4ee7e-333">[*ASP.NET 페이지 자습서의 BLL 및 DAL 수준 예외 처리*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) 에서 `RowUpdating` 이벤트 처리기와 유사한 작업을 수행 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="4ee7e-334">다음 예제에서는 두 번째 방법을 사용 하 여 `Text` 속성이 형식이 지정 되지 않은 `UnitPrice` 값에 바인딩된 양방향 데이터 인 숨겨진 Label 웹 컨트롤을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="4ee7e-335">이 문제를 해결 한 후에는 모든 제품에 대 한 삭제 단추를 다시 클릭 하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="4ee7e-336">이번에는 ObjectDataSource가 BLL의 `UpdateProduct` 메서드를 호출 하려고 할 때 `InvalidOperationException`을 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>

<span data-ttu-id="4ee7e-337">[![ObjectDataSource에서 전송 하려는 입력 매개 변수가 있는 메서드를 찾을 수 없습니다.](implementing-optimistic-concurrency-vb/_static/image45.png)](implementing-optimistic-concurrency-vb/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-vb/_static/image45.png)](implementing-optimistic-concurrency-vb/_static/image44.png)</span></span>

<span data-ttu-id="4ee7e-338">**그림 16**: ObjectDataSource에서 보내려고 하는 입력 매개 변수가 있는 메서드를 찾을 수 없음 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image46.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image46.png))</span></span>

<span data-ttu-id="4ee7e-339">예외의 메시지를 살펴보면 ObjectDataSource가 `original_CategoryName` 및 `original_SupplierName` 입력 매개 변수를 포함 하는 BLL `DeleteProduct` 메서드를 호출 하려고 한다는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="4ee7e-340">`CategoryID` 및 `SupplierID` 템플릿 필드의 `ItemTemplate`에는 현재 `CategoryName` 및 `SupplierName` 데이터 필드를 포함 하는 양방향 바인드 문이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="4ee7e-341">대신 `CategoryID` 및 `SupplierID` 데이터 필드를 사용 하 여 `Bind` 문을 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="4ee7e-342">이렇게 하려면 기존 Bind 문을 `Eval` 문으로 바꾼 다음 아래와 같이 `Text` 속성이 `CategoryID`에 바인딩되어 있는 숨겨진 레이블 컨트롤을 추가 하 고 양방향 데이터 바인딩을 사용 하 여 데이터 필드를 `SupplierID` 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-vb/samples/sample11.aspx)]

<span data-ttu-id="4ee7e-343">이러한 변경으로 이제 제품 정보를 성공적으로 삭제 하 고 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="4ee7e-344">5 단계에서는 동시성 위반이 감지 되는지 확인 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="4ee7e-345">그러나 지금은 소수의 레코드를 업데이트 하 고 삭제 하는 데 몇 분 정도 걸리며, 단일 사용자에 대 한 업데이트 및 삭제가 예상 대로 작동 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="4ee7e-346">5 단계: 낙관적 동시성 지원 테스트</span><span class="sxs-lookup"><span data-stu-id="4ee7e-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="4ee7e-347">동시성 위반이 감지 되는지 확인 하기 위해 (무조건 덮어쓰는 데이터를 생성 하는 대신)이 페이지에서 두 개의 브라우저 창을 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="4ee7e-348">두 브라우저 인스턴스 모두에서 Chai에 대 한 편집 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="4ee7e-349">그런 다음 브라우저 중 하나 에서만 이름을 "Chai Tea"로 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="4ee7e-350">업데이트에 성공 하 고 GridView를 미리 편집 상태로 되돌립니다. "Chai Tea"를 새 제품 이름으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="4ee7e-351">그러나 다른 브라우저 창 인스턴스에서는 제품 이름 텍스트 상자에 "Chai"가 계속 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="4ee7e-352">이 두 번째 브라우저 창에서 `UnitPrice` `25.00`로 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="4ee7e-353">낙관적 동시성을 지원 하지 않으면 두 번째 브라우저 인스턴스에서 업데이트를 클릭 하면 제품 이름을 "Chai"로 변경 하 여 첫 번째 브라우저 인스턴스의 변경 내용을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="4ee7e-354">그러나 낙관적 동시성을 사용 하는 경우 두 번째 브라우저 인스턴스에서 업데이트 단추를 클릭 하면 [system.data.dbconcurrencyexception](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx)이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>

<span data-ttu-id="4ee7e-355">[![동시성 위반이 감지 되 면 System.data.dbconcurrencyexception이 Throw 됩니다.](implementing-optimistic-concurrency-vb/_static/image48.png)](implementing-optimistic-concurrency-vb/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-vb/_static/image48.png)](implementing-optimistic-concurrency-vb/_static/image47.png)</span></span>

<span data-ttu-id="4ee7e-356">**그림 17**: 동시성 위반이 감지 되 면 `DBConcurrencyException`이 throw 됩니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image49.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image49.png))</span></span>

<span data-ttu-id="4ee7e-357">`DBConcurrencyException`는 DAL의 batch 업데이트 패턴이 사용 되는 경우에만 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="4ee7e-358">DB 직접 패턴은 예외를 발생 시 키 지 않으며, 단순히 영향을 받은 행이 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="4ee7e-359">이를 설명 하기 위해 브라우저 인스턴스 GridView를 모두 미리 편집 상태로 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="4ee7e-360">그런 다음, 첫 번째 브라우저 인스턴스에서 편집 단추를 클릭 하 고 제품 이름을 "Chai Tea"에서 "Chai"로 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="4ee7e-361">두 번째 브라우저 창에서 Chai에 대 한 삭제 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="4ee7e-362">삭제를 클릭 하면 페이지가 다시 게시 되 고, GridView는 ObjectDataSource의 `Delete()` 메서드를 호출 하 고, ObjectDataSource는 `ProductsOptimisticConcurrencyBLL` 클래스의 `DeleteProduct` 메서드를 호출 하 여 원래 값을 따라 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="4ee7e-363">두 번째 브라우저 인스턴스의 원래 `ProductName` 값은 "Chai Tea" 이며 데이터베이스의 현재 `ProductName` 값과 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="4ee7e-364">따라서 데이터베이스에 `WHERE` 절이 충족 하는 레코드가 없으므로 데이터베이스에 대해 실행 되는 `DELETE` 문은 0 개 행에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="4ee7e-365">`DeleteProduct` 메서드는 `false`를 반환 하 고 ObjectDataSource의 데이터를 GridView에 바인딩 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="4ee7e-366">최종 사용자의 관점에서 두 번째 브라우저 창에서 Chai Tea에 대 한 삭제 단추를 클릭 하면 화면이 깜박이는 것으로 표시 되 고, 이제는 "Chai" (첫 번째 브라우저에서 변경한 제품 이름)로 표시 되는 제품도 있습니다. 인스턴스).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="4ee7e-367">사용자가 삭제 단추를 다시 클릭 하면 GridView의 원래 `ProductName` 값 ("Chai")이 데이터베이스의 값과 일치 하므로 삭제가 성공적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="4ee7e-368">이러한 두 경우 모두 사용자 환경이 이상적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="4ee7e-369">Batch 업데이트 패턴을 사용 하는 경우 `DBConcurrencyException` 예외에 대 한 핵심 사항을 정보를 사용자에 게 표시 하지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="4ee7e-370">DB 직접 패턴을 사용할 때의 동작은 사용자 명령이 실패 하는 경우와 다소 혼동 되지만 이유를 정확 하 게 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="4ee7e-371">이러한 두 가지 문제를 해결 하기 위해 업데이트 또는 삭제가 실패 한 이유에 대 한 설명을 제공 하는 레이블 웹 컨트롤을 페이지에 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="4ee7e-372">일괄 처리 업데이트 패턴의 경우 GridView의 사후 수준 이벤트 처리기에서 `DBConcurrencyException` 예외가 발생 했는지 여부를 확인 하 고 필요에 따라 경고 레이블을 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="4ee7e-373">DB direct 메서드의 경우 BLL 메서드의 반환 값 (한 행이 영향을 받는 경우 `false`에는 `true`)을 검토 하 고 필요에 따라 정보 메시지를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="4ee7e-374">6 단계: 정보 메시지를 추가 하 고 동시성 위반이 발생할 때 표시</span><span class="sxs-lookup"><span data-stu-id="4ee7e-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="4ee7e-375">동시성 위반이 발생할 경우 발생 하는 동작은 DAL의 batch 업데이트 또는 DB direct 패턴의 사용 여부에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="4ee7e-376">이 자습서에서는 업데이트에 사용 되는 일괄 처리 업데이트 패턴 및 삭제에 사용 되는 DB direct 패턴을 사용 하 여 두 패턴을 모두 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="4ee7e-377">시작 하려면 데이터를 삭제 하거나 업데이트 하려고 할 때 동시성 위반이 발생 했음을 설명 하는 두 개의 Label 웹 컨트롤을 페이지에 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="4ee7e-378">레이블 컨트롤의 `Visible` 및 `EnableViewState` 속성을 `false`로 설정 합니다. 이렇게 하면 해당 `Visible` 속성이 `true`으로 프로그래밍 방식으로 설정 된 특정 페이지 방문을 제외 하 고 각 페이지를 방문할 때마다 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-vb/samples/sample12.aspx)]

<span data-ttu-id="4ee7e-379">`Visible`, `EnabledViewState`및 `Text` 속성을 설정 하는 것 외에도 `CssClass` 속성을 `Warning`로 설정 하 여 레이블이 크고 빨강, 기울임꼴, 굵은 글꼴로 표시 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="4ee7e-380">이 CSS `Warning` 클래스를 정의 하 고 스타일에 추가 하 여 자습서 *삽입, 업데이트 및 삭제와 관련 된 이벤트를 검사* 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="4ee7e-381">이러한 레이블을 추가한 후 Visual Studio의 디자이너는 그림 18과 유사 하 게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>

<span data-ttu-id="4ee7e-382">[![두 개의 Label 컨트롤이 페이지에 추가 되었습니다.](implementing-optimistic-concurrency-vb/_static/image51.png)](implementing-optimistic-concurrency-vb/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-vb/_static/image51.png)](implementing-optimistic-concurrency-vb/_static/image50.png)</span></span>

<span data-ttu-id="4ee7e-383">**그림 18**: 페이지에 두 개의 Label 컨트롤이 추가 되었습니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image52.png)).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image52.png))</span></span>

<span data-ttu-id="4ee7e-384">이러한 레이블 웹 컨트롤을 사용 하면 동시성 위반이 발생 한 시기를 확인 하는 방법을 검토할 수 있습니다 .이 시점에서 적절 한 레이블의 `Visible` 속성을 `true`으로 설정 하 여 정보 메시지를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="4ee7e-385">업데이트할 때 동시성 위반 처리</span><span class="sxs-lookup"><span data-stu-id="4ee7e-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="4ee7e-386">먼저 batch 업데이트 패턴을 사용할 때 동시성 위반을 처리 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="4ee7e-387">이러한 위반으로 인해 `DBConcurrencyException` 예외가 throw 되기 때문에 업데이트 프로세스 중에 `DBConcurrencyException` 예외가 발생 했는지 여부를 확인 하려면 ASP.NET 페이지에 코드를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="4ee7e-388">이 경우 다른 사용자가 레코드 편집을 시작 하 고 업데이트 단추를 클릭할 때와 동일한 데이터를 수정 했기 때문에 변경 내용이 저장 되지 않았습니다 .를 설명 하는 메시지를 사용자에 게 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="4ee7e-389">*ASP.NET 페이지 자습서의 BLL 및 DAL 수준 예외 처리* 에서 살펴본 것 처럼 이러한 예외는 데이터 웹 컨트롤의 사후 수준 이벤트 처리기에서 검색 되 고 표시 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="4ee7e-390">따라서 `DBConcurrencyException` 예외가 throw 되었는지 확인 하는 GridView의 `RowUpdated` 이벤트에 대 한 이벤트 처리기를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="4ee7e-391">이 이벤트 처리기는 아래 이벤트 처리기 코드에 표시 된 것 처럼 업데이트 프로세스 중에 발생 한 모든 예외에 대 한 참조를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>

[!code-vb[Main](implementing-optimistic-concurrency-vb/samples/sample13.vb)]

<span data-ttu-id="4ee7e-392">`DBConcurrencyException` 예외가 발생할 경우이 이벤트 처리기는 `UpdateConflictMessage` 레이블 컨트롤을 표시 하 고 예외가 처리 되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="4ee7e-393">이 코드를 사용 하면 레코드를 업데이트할 때 동시성 위반이 발생할 때 다른 사용자의 수정 내용을 동시에 덮어쓸 수 있기 때문에 사용자의 변경 내용이 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="4ee7e-394">특히 GridView는 사전 편집 상태로 반환 되 고 현재 데이터베이스 데이터에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="4ee7e-395">이렇게 하면 이전에 표시 되지 않은 다른 사용자의 변경 내용으로 GridView 행이 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="4ee7e-396">또한 `UpdateConflictMessage` Label 컨트롤은 사용자에 게 발생 한 작업을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="4ee7e-397">이 이벤트 시퀀스는 그림 19에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-397">This sequence of events is detailed in Figure 19.</span></span>

<span data-ttu-id="4ee7e-398">[동시성 위반이 발생 하는 경우 사용자 업데이트가 손실 ![](implementing-optimistic-concurrency-vb/_static/image54.png)](implementing-optimistic-concurrency-vb/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-vb/_static/image54.png)](implementing-optimistic-concurrency-vb/_static/image53.png)</span></span>

<span data-ttu-id="4ee7e-399">**그림 19**: 동시성 위반이 발생 한 경우 사용자 업데이트 손실 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image55.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image55.png))</span></span>

> [!NOTE]
> <span data-ttu-id="4ee7e-400">또는 GridView를 미리 편집 상태로 되돌리는 대신 전달 된 `GridViewUpdatedEventArgs` 개체의 `KeepInEditMode` 속성을 true로 설정 하 여 GridView를 편집 상태로 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="4ee7e-401">그러나이 방법을 사용 하는 경우 다른 사용자의 값이 편집 인터페이스에 로드 되도록 해당 `DataBind()` 메서드를 호출 하 여 데이터를 GridView에 다시 바인딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="4ee7e-402">이 자습서에서 다운로드할 수 있는 코드에는 `RowUpdated` 이벤트 처리기에서 주석으로 처리 된 두 줄의 코드가 있습니다. 이러한 코드 줄의 주석 처리를 제거 하면 동시성 위반 후 GridView가 편집 모드로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>

## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="4ee7e-403">삭제할 때 동시성 위반에 대 한 응답</span><span class="sxs-lookup"><span data-stu-id="4ee7e-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="4ee7e-404">DB 직접 패턴을 사용 하면 동시성 위반이 발생 하는 경우 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="4ee7e-405">대신, WHERE 절이 레코드와 일치 하지 않기 때문에 데이터베이스 문은 단순히 레코드에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="4ee7e-406">BLL에서 만든 모든 데이터 수정 메서드는 정확히 하나의 레코드에 영향을 미치는지 여부를 나타내는 부울 값을 반환 하도록 디자인 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="4ee7e-407">따라서 레코드를 삭제할 때 동시성 위반이 발생 했는지 확인 하려면 BLL의 `DeleteProduct` 메서드에 대 한 반환 값을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="4ee7e-408">BLL 메서드의 반환 값은 이벤트 처리기로 전달 되는 `ObjectDataSourceStatusEventArgs` 개체의 `ReturnValue` 속성을 통해 ObjectDataSource의 사후 수준 이벤트 처리기에서 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="4ee7e-409">`DeleteProduct` 메서드에서 반환 값을 결정 하는 데 관심이 있으므로 ObjectDataSource의 `Deleted` 이벤트에 대 한 이벤트 처리기를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="4ee7e-410">`ReturnValue` 속성은 `object` 형식이 며, 예외가 발생 하 고 메서드가 값을 반환 하기 전에 중단 된 경우에 `null` 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="4ee7e-411">따라서 먼저 `ReturnValue` 속성이 `null` 없고 부울 값 인지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="4ee7e-412">이 검사를 통과 한다고 가정 하면 `ReturnValue` `false`경우 `DeleteConflictMessage` 레이블 컨트롤을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="4ee7e-413">다음 코드를 사용 하 여이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-413">This can be accomplished by using the following code:</span></span>

[!code-vb[Main](implementing-optimistic-concurrency-vb/samples/sample14.vb)]

<span data-ttu-id="4ee7e-414">동시성 위반이 발생 하면 사용자의 삭제 요청이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="4ee7e-415">GridView가 새로 고쳐지고 사용자가 페이지를 로드 한 시간과 삭제 단추를 클릭 한 시간 사이에 해당 레코드에 발생 한 변경 내용을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="4ee7e-416">이러한 위반이 transpires 면 발생 한 상황을 설명 하는 `DeleteConflictMessage` 레이블이 표시 됩니다 (그림 20 참조).</span><span class="sxs-lookup"><span data-stu-id="4ee7e-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>

<span data-ttu-id="4ee7e-417">[동시성 위반이 발생 하는 경우 사용자 삭제가 취소 ![](implementing-optimistic-concurrency-vb/_static/image57.png)](implementing-optimistic-concurrency-vb/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-vb/_static/image57.png)](implementing-optimistic-concurrency-vb/_static/image56.png)</span></span>

<span data-ttu-id="4ee7e-418">**그림 20**: 동시성 위반이 발생 하는 경우 사용자 삭제 취소 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-vb/_static/image58.png))</span><span class="sxs-lookup"><span data-stu-id="4ee7e-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-vb/_static/image58.png))</span></span>

## <a name="summary"></a><span data-ttu-id="4ee7e-419">요약</span><span class="sxs-lookup"><span data-stu-id="4ee7e-419">Summary</span></span>

<span data-ttu-id="4ee7e-420">여러 동시 사용자가 데이터를 업데이트 하거나 삭제할 수 있도록 하는 모든 응용 프로그램에서 동시성 위반에 대 한 기회가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="4ee7e-421">이러한 위반이에 대해 고려 되지 않는 경우 두 사용자가 마지막 쓰기 "wins"에서 가져오는 것과 동일한 데이터를 동시에 업데이트 하는 경우 다른 사용자의 변경 내용을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="4ee7e-422">또는 개발자가 낙관적 또는 비관적 동시성 제어를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="4ee7e-423">낙관적 동시성 제어에서는 동시성 위반이 자주 발생 하지 않으며, 단순히 동시성 위반을 구성 하는 update 또는 delete 명령을 허용 하지 않는다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="4ee7e-424">비관적 동시성 제어에서는 동시성 위반이 자주 발생 하 고 사용자의 업데이트 또는 삭제 명령을 거부 하는 것이 허용 되지 않는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="4ee7e-425">비관적 동시성 제어를 사용 하는 경우 레코드를 업데이트 하는 작업을 수행 하면 다른 사용자가 잠겨 있는 동안 레코드를 수정 하거나 삭제할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="4ee7e-426">.NET의 형식화 된 데이터 집합은 낙관적 동시성 제어를 지원 하기 위한 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="4ee7e-427">특히 데이터베이스에 대해 실행 되는 `UPDATE` 및 `DELETE` 문은 모든 테이블의 열을 포함 하 여 레코드의 현재 데이터가 사용자가 업데이트 또는 삭제를 수행할 때 수행한 원래 데이터와 일치 하는 경우에만 업데이트 또는 삭제를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="4ee7e-428">DAL이 낙관적 동시성을 지원 하도록 구성 되 면 BLL 메서드를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="4ee7e-429">또한 해당 데이터 웹 컨트롤에서 원래 값을 검색 하 여 BLL에 전달 하도록 BLL로 다운을 호출 하는 ASP.NET 페이지를 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="4ee7e-430">이 자습서에서 살펴본 것 처럼 ASP.NET 웹 응용 프로그램에서 낙관적 동시성 제어를 구현 하려면 DAL 및 BLL을 업데이트 하 고 ASP.NET 페이지에서 지원을 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="4ee7e-431">이 추가 된 작업은 사용자의 응용 프로그램에 따라 달라 지는 시간 및 노력에 따라 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="4ee7e-432">동시 사용자가 데이터를 업데이트 하거나 업데이트 하는 데이터가 서로 다른 경우 동시성 제어는 주요 문제가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="4ee7e-433">그러나 사이트의 여러 사용자가 동일한 데이터를 사용 하 여 작업을 정기적으로 수행 하는 경우 동시성 제어를 통해 한 사용자의 업데이트나 삭제가 다른의를 덮어쓰는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="4ee7e-434">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="4ee7e-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="4ee7e-435">저자 정보</span><span class="sxs-lookup"><span data-stu-id="4ee7e-435">About the Author</span></span>

<span data-ttu-id="4ee7e-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="4ee7e-437">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="4ee7e-438">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="4ee7e-439">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="4ee7e-440">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee7e-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4ee7e-441">[이전](customizing-the-data-modification-interface-vb.md)
> [다음](adding-client-side-confirmation-when-deleting-vb.md)</span><span class="sxs-lookup"><span data-stu-id="4ee7e-441">[Previous](customizing-the-data-modification-interface-vb.md)
[Next](adding-client-side-confirmation-when-deleting-vb.md)</span></span>
