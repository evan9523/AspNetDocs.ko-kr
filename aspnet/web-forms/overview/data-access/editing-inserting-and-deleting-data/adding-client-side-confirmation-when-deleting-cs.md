---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/adding-client-side-confirmation-when-deleting-cs
title: 삭제할 때 클라이언트 쪽 확인 추가 (C#) | Microsoft Docs
author: rick-anderson
description: 지금까지 만든 인터페이스에서 사용자는 편집 단추를 클릭할 때 삭제 단추를 클릭 하 여 실수로 데이터를 삭제할 수 있습니다. 이 t ...
ms.author: riande
ms.date: 07/17/2006
ms.assetid: f6e2a12a-2b5e-48fd-8db3-1e94a500c19a
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/adding-client-side-confirmation-when-deleting-cs
msc.type: authoredcontent
ms.openlocfilehash: e7d53bc65fdbbfa9ce9bfa5fbdbfa0dea598eebe
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78479819"
---
# <a name="adding-client-side-confirmation-when-deleting-c"></a><span data-ttu-id="e7018-104">삭제할 때 클라이언트 쪽 확인 추가(C#)</span><span class="sxs-lookup"><span data-stu-id="e7018-104">Adding Client-Side Confirmation When Deleting (C#)</span></span>

<span data-ttu-id="e7018-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e7018-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e7018-106">[샘플 앱 다운로드](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_22_CS.exe) 또는 [PDF 다운로드](adding-client-side-confirmation-when-deleting-cs/_static/datatutorial22cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e7018-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_22_CS.exe) or [Download PDF](adding-client-side-confirmation-when-deleting-cs/_static/datatutorial22cs1.pdf)</span></span>

> <span data-ttu-id="e7018-107">지금까지 만든 인터페이스에서 사용자는 편집 단추를 클릭할 때 삭제 단추를 클릭 하 여 실수로 데이터를 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-107">In the interfaces we've created so far, a user can accidentally delete data by clicking the Delete button when they meant to click the Edit button.</span></span> <span data-ttu-id="e7018-108">이 자습서에서는 삭제 단추를 클릭할 때 표시 되는 클라이언트 쪽 확인 대화 상자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-108">In this tutorial we'll add a client-side confirmation dialog box that appears when the Delete button is clicked.</span></span>

## <a name="introduction"></a><span data-ttu-id="e7018-109">소개</span><span class="sxs-lookup"><span data-stu-id="e7018-109">Introduction</span></span>

<span data-ttu-id="e7018-110">지난 몇 가지 자습서에서는 응용 프로그램 아키텍처, ObjectDataSource 및 데이터 웹 컨트롤을 사용 하 여 삽입, 편집 및 삭제 기능을 제공 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-110">Over the past several tutorials we ve seen how to use our application architecture, ObjectDataSource, and the data Web controls in concert to provide inserting, editing, and deleting capabilities.</span></span> <span data-ttu-id="e7018-111">지금까지 검사 한 삭제 인터페이스는 클릭 하면 다시 게시를 발생 시키고 ObjectDataSource s `Delete()` 메서드를 호출 하는 삭제 단추로 구성 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-111">The deleting interfaces we ve examined thus far have been composed of a Delete button that, when clicked, causes a postback and invokes the ObjectDataSource s `Delete()` method.</span></span> <span data-ttu-id="e7018-112">그런 다음 `Delete()` 메서드는 데이터 액세스 계층에 대 한 호출을 전파 하 여 데이터베이스에 대 한 실제 `DELETE` 문을 실행 하는 비즈니스 논리 계층에서 구성 된 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-112">The `Delete()` method then invokes the configured method from the Business Logic Layer, which propagates the call down to the Data Access Layer, issuing the actual `DELETE` statement to the database.</span></span>

<span data-ttu-id="e7018-113">이 사용자 인터페이스를 사용 하면 방문자가 GridView, DetailsView 또는 FormView 컨트롤을 통해 레코드를 삭제할 수 있지만, 사용자가 삭제 단추를 클릭 하면 어떠한 종류의 확인도 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-113">While this user interface enables visitors to delete records through the GridView, DetailsView, or FormView controls, it lacks any sort of confirmation when the user clicks the Delete button.</span></span> <span data-ttu-id="e7018-114">사용자가 편집을 클릭 하려는 경우 실수로 삭제 단추를 클릭 하면 업데이트 하려는 레코드가 대신 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-114">If a user accidentally clicks the Delete button when they meant to click Edit, the record they meant to update will instead be deleted.</span></span> <span data-ttu-id="e7018-115">이를 방지 하기 위해이 자습서에서는 삭제 단추를 클릭할 때 표시 되는 클라이언트 쪽 확인 대화 상자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-115">To help prevent this, in this tutorial we'll add a client-side confirmation dialog box that appears when the Delete button is clicked.</span></span>

<span data-ttu-id="e7018-116">JavaScript `confirm(string)` 함수는 문자열 입력 매개 변수를 모달 대화 상자에 표시 된 텍스트로 표시 합니다 .이 대화 상자에는 두 가지 단추 (확인 및 취소)가 제공 됩니다 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="e7018-116">The JavaScript `confirm(string)` function displays its string input parameter as the text inside a modal dialog box that comes equipped with two buttons - OK and Cancel (see Figure 1).</span></span> <span data-ttu-id="e7018-117">`confirm(string)` 함수는 클릭 한 단추에 따라 부울 값을 반환 합니다 (`true`, 사용자가 확인을 클릭 하면 `false` 하 고 취소를 클릭 하는 경우).</span><span class="sxs-lookup"><span data-stu-id="e7018-117">The `confirm(string)` function returns a Boolean value depending on what button is clicked (`true`, if the user clicks OK, and `false` if they click Cancel).</span></span>

![JavaScript confirm (string) 메서드는 모달 클라이언트 쪽 Messagebox를 표시 합니다.](adding-client-side-confirmation-when-deleting-cs/_static/image1.png)

<span data-ttu-id="e7018-119">**그림 1**: JavaScript `confirm(string)` 메서드는 모달 클라이언트 쪽 Messagebox를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-119">**Figure 1**: The JavaScript `confirm(string)` Method Displays a Modal, Client-Side Messagebox</span></span>

<span data-ttu-id="e7018-120">폼을 전송 하는 동안 클라이언트 쪽 이벤트 처리기에서 `false` 값이 반환 되 면 양식 전송이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-120">During a form submission, if a value of `false` is returned from a client-side event handler then the form submission is cancelled.</span></span> <span data-ttu-id="e7018-121">이 기능을 사용 하 여 삭제 단추를 사용 하 여 클라이언트 쪽 `onclick` 이벤트 처리기가 `confirm("Are you sure you want to delete this product?")`에 대 한 호출 값을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-121">Using this feature, we can have the Delete button s client-side `onclick` event handler return the value of a call to `confirm("Are you sure you want to delete this product?")`.</span></span> <span data-ttu-id="e7018-122">사용자가 취소를 클릭 하면 `confirm(string)` false를 반환 하 여 양식 제출을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-122">If the user clicks Cancel, `confirm(string)` will return false, thereby causing the form submission to cancel.</span></span> <span data-ttu-id="e7018-123">다시 게시를 사용 하지 않으면 삭제 단추가 클릭 된 제품은 삭제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-123">With no postback, the product whose Delete button was clicked won't be deleted.</span></span> <span data-ttu-id="e7018-124">그러나 사용자가 확인 대화 상자에서 확인을 클릭 하면 다시 게시가 계속 적용 되지 않으며 제품이 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-124">If, however, the user clicks OK in the confirmation dialog box, the postback will continue unabated and the product will be deleted.</span></span> <span data-ttu-id="e7018-125">이 기술에 대 한 자세한 내용은 [JavaScript s `confirm()` 메서드를 사용 하 여 양식 전송 제어를](http://www.webreference.com/programming/javascript/confirm/) 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e7018-125">Consult [Using JavaScript s `confirm()` Method to Control Form Submission](http://www.webreference.com/programming/javascript/confirm/) for more information on this technique.</span></span>

<span data-ttu-id="e7018-126">CommandField를 사용할 때 보다 템플릿을 사용 하는 경우 필요한 클라이언트 쪽 스크립트를 추가 하는 것은 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-126">Adding the necessary client-side script differs slightly if using templates than when using a CommandField.</span></span> <span data-ttu-id="e7018-127">따라서이 자습서에서는 FormView 및 GridView 예제를 모두 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-127">Therefore, in this tutorial we will look at both a FormView and GridView example.</span></span>

> [!NOTE]
> <span data-ttu-id="e7018-128">이 자습서에 설명 된 것과 같은 클라이언트 쪽 확인 기법을 사용 하면 사용자가 JavaScript를 지 원하는 브라우저를 방문 하 고 JavaScript를 사용 하도록 설정한 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-128">Using client-side confirmation techniques, like the ones discussed in this tutorial, assumes that your users are visiting with browsers that support JavaScript and that they have JavaScript enabled.</span></span> <span data-ttu-id="e7018-129">이러한 가정 중 하나가 특정 사용자에 대해 true가 아니면 삭제 단추를 클릭 하면 즉시 다시 게시 (messagebox 확인 표시 안 함)가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-129">If either of these assumptions are not true for a particular user, clicking the Delete button will immediately cause a postback (not displaying a confirm messagebox).</span></span>

## <a name="step-1-creating-a-formview-that-supports-deletion"></a><span data-ttu-id="e7018-130">1 단계: 삭제를 지 원하는 FormView 만들기</span><span class="sxs-lookup"><span data-stu-id="e7018-130">Step 1: Creating a FormView That Supports Deletion</span></span>

<span data-ttu-id="e7018-131">먼저 `EditInsertDelete` 폴더의 `ConfirmationOnDelete.aspx` 페이지에 FormView를 추가 하 고 `ProductsBLL` 클래스 `GetProducts()` 메서드를 통해 제품 정보를 다시 가져오는 새 ObjectDataSource에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-131">Start by adding a FormView to the `ConfirmationOnDelete.aspx` page in the `EditInsertDelete` folder, binding it to a new ObjectDataSource that pulls back the product information via the `ProductsBLL` class s `GetProducts()` method.</span></span> <span data-ttu-id="e7018-132">또한 `ProductsBLL` 클래스 s `DeleteProduct(productID)` 메서드가 ObjectDataSource s `Delete()` 메서드에 매핑되도록 ObjectDataSource를 구성 합니다. 삽입 및 업데이트 탭 드롭다운 목록이 (없음)로 설정 되어 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-132">Also configure the ObjectDataSource so that the `ProductsBLL` class s `DeleteProduct(productID)` method is mapped to the ObjectDataSource s `Delete()` method; ensure that the INSERT and UPDATE tabs drop-down lists are set to (None).</span></span> <span data-ttu-id="e7018-133">마지막으로 FormView의 스마트 태그에서 페이징 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-133">Finally, check the Enable Paging checkbox in the FormView s smart tag.</span></span>

<span data-ttu-id="e7018-134">이러한 단계를 수행 하면 새 ObjectDataSource의 선언적 태그가 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-134">After these steps, the new ObjectDataSource s declarative markup will look like the following:</span></span>

[!code-aspx[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample1.aspx)]

<span data-ttu-id="e7018-135">낙관적 동시성을 사용 하지 않는 이전 예제와 마찬가지로 ObjectDataSource s `OldValuesParameterFormatString` 속성을 지우십시오.</span><span class="sxs-lookup"><span data-stu-id="e7018-135">As in our past examples that did not use optimistic concurrency, take a moment to clear out the ObjectDataSource s `OldValuesParameterFormatString` property.</span></span>

<span data-ttu-id="e7018-136">삭제만 지 원하는 ObjectDataSource 컨트롤에 바인딩 되었으므로 FormView s `ItemTemplate`는 삭제 단추만 제공 하 고 새 및 업데이트 단추는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-136">Since it has been bound to an ObjectDataSource control that only supports deleting, the FormView s `ItemTemplate` offers only the Delete button, lacking the New and Update buttons.</span></span> <span data-ttu-id="e7018-137">그러나 FormView의 선언적 태그는 제거 될 수 있는 불필요 한 `EditItemTemplate` 및 `InsertItemTemplate`를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-137">The FormView s declarative markup, however, includes a superfluous `EditItemTemplate` and `InsertItemTemplate`, which can be removed.</span></span> <span data-ttu-id="e7018-138">를 사용 하 여 제품 데이터 필드의 하위 집합만 표시 되도록 `ItemTemplate`를 사용자 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-138">Take a moment to customize the `ItemTemplate` so that is shows only a subset of the product data fields.</span></span> <span data-ttu-id="e7018-139">삭제 단추와 함께 공급자 및 범주 이름 위의 `<h3>` 제목에 제품 이름을 표시 하도록 광산을 구성 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-139">I ve configured mine to show the product s name in an `<h3>` heading above its supplier and category names (along with the Delete button).</span></span>

[!code-aspx[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample2.aspx)]

<span data-ttu-id="e7018-140">이러한 변경 내용으로, 사용자가 한 번에 하나씩 제품을 전환할 수 있는 완전 한 기능을 제공 하는 웹 페이지를 사용 하 여 삭제 단추를 클릭 하기만 하면 제품을 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-140">With these changes, we have a fully functional web page that allows a user to toggle through the products one at a time, with the ability to delete a product by simply clicking the Delete button.</span></span> <span data-ttu-id="e7018-141">그림 2에서는 브라우저를 통해 볼 때의 진행 상황을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-141">Figure 2 shows a screen shot of our progress thus far when viewed through a browser.</span></span>

<span data-ttu-id="e7018-142">[FormView ![단일 제품에 대 한 정보를 표시 합니다.](adding-client-side-confirmation-when-deleting-cs/_static/image3.png)](adding-client-side-confirmation-when-deleting-cs/_static/image2.png)</span><span class="sxs-lookup"><span data-stu-id="e7018-142">[![The FormView Shows Information About a Single Product](adding-client-side-confirmation-when-deleting-cs/_static/image3.png)](adding-client-side-confirmation-when-deleting-cs/_static/image2.png)</span></span>

<span data-ttu-id="e7018-143">**그림 2**: FormView는 단일 제품에 대 한 정보를 보여 줍니다 ([전체 크기 이미지를 보려면 클릭](adding-client-side-confirmation-when-deleting-cs/_static/image4.png)).</span><span class="sxs-lookup"><span data-stu-id="e7018-143">**Figure 2**: The FormView Shows Information About a Single Product ([Click to view full-size image](adding-client-side-confirmation-when-deleting-cs/_static/image4.png))</span></span>

## <a name="step-2-calling-the-confirmstring-function-from-the-delete-buttons-client-side-onclick-event"></a><span data-ttu-id="e7018-144">2 단계: 클라이언트 쪽 onclick 이벤트 삭제 단추에서 confirm (string) 함수 호출</span><span class="sxs-lookup"><span data-stu-id="e7018-144">Step 2: Calling the confirm(string) Function from the Delete Buttons Client-Side onclick Event</span></span>

<span data-ttu-id="e7018-145">FormView를 만든 후 마지막 단계는 방문자가 클릭할 때 JavaScript `confirm(string)` 함수가 호출 되도록 삭제 단추를 구성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-145">With the FormView created, the final step is to configure the Delete button such that when it s clicked by the visitor, the JavaScript `confirm(string)` function is invoked.</span></span> <span data-ttu-id="e7018-146">ASP.NET 2.0에 새로 추가 된 `OnClientClick property`를 사용 하 여 클라이언트 쪽 `onclick` 이벤트에 대 한 클라이언트 쪽 스크립트를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-146">Adding client-side script to a Button, LinkButton, or ImageButton s client-side `onclick` event can be accomplished through the use of the `OnClientClick property`, which is new to ASP.NET 2.0.</span></span> <span data-ttu-id="e7018-147">`confirm(string)` 함수의 값을 반환 하려고 하므로이 속성을로 설정 하면 됩니다. `return confirm('Are you certain that you want to delete this product?');`</span><span class="sxs-lookup"><span data-stu-id="e7018-147">Since we want to have the value of the `confirm(string)` function returned, simply set this property to: `return confirm('Are you certain that you want to delete this product?');`</span></span>

<span data-ttu-id="e7018-148">이 변경 후 Delete LinkButton s 선언적 구문은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-148">After this change the Delete LinkButton s declarative syntax should look something like:</span></span>

[!code-aspx[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample3.aspx)]

<span data-ttu-id="e7018-149">이것이 전부입니다!</span><span class="sxs-lookup"><span data-stu-id="e7018-149">That s all there is to it!</span></span> <span data-ttu-id="e7018-150">그림 3에서는이 확인 작업의 스크린 샷을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-150">Figure 3 shows a screen shot of this confirmation in action.</span></span> <span data-ttu-id="e7018-151">삭제 단추를 클릭 하면 확인 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-151">Clicking the Delete button brings up the confirm dialog box.</span></span> <span data-ttu-id="e7018-152">사용자가 취소를 클릭 하면 포스트백이 취소 되 고 제품이 삭제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-152">If the user clicks Cancel, the postback is cancelled and the product is not deleted.</span></span> <span data-ttu-id="e7018-153">그러나 사용자가 확인을 클릭 하면 다시 게시가 계속 되 고 ObjectDataSource s `Delete()` 메서드가 호출 되 고 culminating 데이터베이스가 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-153">If, however, the user clicks OK, the postback continues and the ObjectDataSource s `Delete()` method is invoked, culminating in the database record being deleted.</span></span>

> [!NOTE]
> <span data-ttu-id="e7018-154">`confirm(string)` JavaScript 함수로 전달 되는 문자열은 따옴표 대신 아포스트로피를 사용 하 여 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-154">The string passed into the `confirm(string)` JavaScript function is delimited with apostrophes (rather than quotation marks).</span></span> <span data-ttu-id="e7018-155">JavaScript에서는 두 문자를 사용 하 여 문자열을 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-155">In JavaScript, strings can be delimited using either character.</span></span> <span data-ttu-id="e7018-156">여기에 아포스트로피를 사용 하 여 `confirm(string)`에 전달 된 문자열에 대 한 구분 기호가 `OnClientClick` 속성 값에 사용 된 구분 기호와 모호 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-156">We use apostrophes here so that the delimiters for the string passed into `confirm(string)` do not introduce an ambiguity with the delimiters used for the `OnClientClick` property value.</span></span>

<span data-ttu-id="e7018-157">[![삭제 단추를 클릭 하면 확인 메시지가 표시 됩니다.](adding-client-side-confirmation-when-deleting-cs/_static/image6.png)](adding-client-side-confirmation-when-deleting-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="e7018-157">[![A Confirmation is Now Displayed When Clicking the Delete Button](adding-client-side-confirmation-when-deleting-cs/_static/image6.png)](adding-client-side-confirmation-when-deleting-cs/_static/image5.png)</span></span>

<span data-ttu-id="e7018-158">**그림 3**: 삭제 단추를 클릭 하면 확인이 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](adding-client-side-confirmation-when-deleting-cs/_static/image7.png)).</span><span class="sxs-lookup"><span data-stu-id="e7018-158">**Figure 3**: A Confirmation is Now Displayed When Clicking the Delete Button ([Click to view full-size image](adding-client-side-confirmation-when-deleting-cs/_static/image7.png))</span></span>

## <a name="step-3-configuring-the-onclientclick-property-for-the-delete-button-in-a-commandfield"></a><span data-ttu-id="e7018-159">3 단계: CommandField에서 삭제 단추에 대 한 OnClientClick 속성 구성</span><span class="sxs-lookup"><span data-stu-id="e7018-159">Step 3: Configuring the OnClientClick Property for the Delete Button in a CommandField</span></span>

<span data-ttu-id="e7018-160">템플릿에서 직접 LinkButton 또는 ImageButton 단추를 사용할 때 JavaScript `confirm(string)` 함수의 결과를 반환 하도록 해당 `OnClientClick` 속성을 구성 하 여 확인 대화 상자를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-160">When working with a Button, LinkButton, or ImageButton directly in a template, a confirmation dialog box can be associated with it by simply configuring its `OnClientClick` property to return the results of the JavaScript `confirm(string)` function.</span></span> <span data-ttu-id="e7018-161">그러나 GridView 또는 DetailsView에 삭제 단추 필드를 추가 하는 CommandField는 선언적으로 설정할 수 있는 `OnClientClick` 속성을 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-161">However, the CommandField - which adds a field of Delete buttons to a GridView or DetailsView - does not have an `OnClientClick` property that can be set declaratively.</span></span> <span data-ttu-id="e7018-162">대신 GridView 또는 DetailsView의 적절 한 `DataBound` 이벤트 처리기에서 삭제 단추를 프로그래밍 방식으로 참조 한 다음 해당 `OnClientClick` 속성을 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-162">Instead, we must programmatically reference the Delete button in the GridView or DetailsView s appropriate `DataBound` event handler, and then set its `OnClientClick` property there.</span></span>

> [!NOTE]
> <span data-ttu-id="e7018-163">적절 한 `DataBound` 이벤트 처리기에서 삭제 단추 s `OnClientClick` 속성을 설정 하는 경우 데이터에 대 한 액세스 권한이 현재 레코드에 바인딩되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-163">When setting the Delete button s `OnClientClick` property in the appropriate `DataBound` event handler, we have access to the data was bound to the current record.</span></span> <span data-ttu-id="e7018-164">즉, "Chai 제품을 삭제 하 시겠습니까?"와 같은 특정 레코드에 대 한 세부 정보를 포함 하도록 확인 메시지를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-164">This means we can extend the confirmation message to include details about the particular record, such as, "Are you sure you want to delete the Chai product?"</span></span> <span data-ttu-id="e7018-165">이러한 사용자 지정은 데이터 바인딩 구문을 사용 하는 템플릿에서도 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-165">Such customization is also possible in templates using databinding syntax.</span></span>

<span data-ttu-id="e7018-166">CommandField에서 삭제 단추에 대 한 `OnClientClick` 속성을 설정 하는 연습을 위해 페이지에 GridView를 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-166">To practice setting the `OnClientClick` property for the Delete button(s) in a CommandField, let s add a GridView to the page.</span></span> <span data-ttu-id="e7018-167">FormView에서 사용 하는 것과 동일한 ObjectDataSource 컨트롤을 사용 하도록 GridView를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-167">Configure this GridView to use the same ObjectDataSource control that the FormView uses.</span></span> <span data-ttu-id="e7018-168">또한 제품 이름, 범주 및 공급자를 포함 하도록 GridView s BoundFields 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-168">Also limit the GridView s BoundFields to only include the product s name, category, and supplier.</span></span> <span data-ttu-id="e7018-169">마지막으로 GridView의 스마트 태그에서 삭제 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-169">Lastly, check the Enable Deleting checkbox from the GridView s smart tag.</span></span> <span data-ttu-id="e7018-170">이렇게 하면 `ShowDeleteButton` 속성이 `true`로 설정 된 `Columns` 컬렉션에 CommandField가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-170">This will add a CommandField to the GridView s `Columns` collection with its `ShowDeleteButton` property set to `true`.</span></span>

<span data-ttu-id="e7018-171">이러한 변경을 수행한 후 GridView의 선언 태그는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-171">After making these changes, your GridView s declarative markup should look like the following:</span></span>

[!code-aspx[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample4.aspx)]

<span data-ttu-id="e7018-172">CommandField는 GridView s `RowDataBound` 이벤트 처리기에서 프로그래밍 방식으로 액세스할 수 있는 단일 Delete LinkButton 인스턴스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-172">The CommandField contains a single Delete LinkButton instance that can be accessed programmatically from the GridView s `RowDataBound` event handler.</span></span> <span data-ttu-id="e7018-173">참조 된 `OnClientClick` 속성을 적절 하 게 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-173">Once referenced, we can set its `OnClientClick` property accordingly.</span></span> <span data-ttu-id="e7018-174">다음 코드를 사용 하 여 `RowDataBound` 이벤트에 대 한 이벤트 처리기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-174">Create an event handler for the `RowDataBound` event using the following code:</span></span>

[!code-csharp[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample5.cs)]

<span data-ttu-id="e7018-175">이 이벤트 처리기는 삭제 단추를 포함 하는 데이터 행에서 작동 하 고 삭제 단추를 프로그래밍 방식으로 참조 하 여 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-175">This event handler works with data rows (those that will have the Delete button) and begins by programmatically referencing the Delete button.</span></span> <span data-ttu-id="e7018-176">일반적으로 다음 패턴을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-176">In general use the following pattern:</span></span>

[!code-csharp[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample6.cs)]

<span data-ttu-id="e7018-177">*ButtonType* 는 commandfield-Button, LinkButton 또는 ImageButton에서 사용 되는 단추의 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-177">*ButtonType* is the type of button being used by the CommandField - Button, LinkButton, or ImageButton.</span></span> <span data-ttu-id="e7018-178">기본적으로 CommandField는 Linkbutton을 사용 하지만 `ButtonType property`CommandField s를 통해 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-178">By default, the CommandField uses LinkButtons, but this can be customized via the CommandField s `ButtonType property`.</span></span> <span data-ttu-id="e7018-179">*Commandfieldindex* 는 GridView `Columns` 컬렉션 내에서 commandfield의 서 수 인덱스이 고 *ControlIndex* 는 commandfield s `Controls` collection에 있는 삭제 단추의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-179">The *commandFieldIndex* is the ordinal index of the CommandField within the GridView s `Columns` collection, whereas the *controlIndex* is the index of the Delete button within the CommandField s `Controls` collection.</span></span> <span data-ttu-id="e7018-180">*ControlIndex* 값은 commandfield의 다른 단추를 기준으로 하는 단추 위치에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-180">The *controlIndex* value depends on the button s position relative to other buttons in the CommandField.</span></span> <span data-ttu-id="e7018-181">예를 들어 CommandField에 표시 되는 유일한 단추가 삭제 단추인 경우 0의 인덱스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-181">For example, if the only button displayed in the CommandField is the Delete button, use an index of 0.</span></span> <span data-ttu-id="e7018-182">그러나 삭제 단추 앞에 편집 단추가 있는 경우 인덱스 2를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-182">If, however, there s an Edit button that precedes the Delete button, use an index of 2.</span></span> <span data-ttu-id="e7018-183">인덱스 2를 사용 하는 이유는 삭제 단추 앞에 두 개의 컨트롤이 추가 됩니다. 즉, 편집 단추와 편집 및 삭제 단추 사이에 공백을 추가 하는 데 사용 되는 LiteralControl 편집 단추입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-183">The reason an index of 2 is used is because two controls are added by the CommandField before the Delete button: the Edit button and a LiteralControl that s used to add some space between the Edit and Delete buttons.</span></span>

<span data-ttu-id="e7018-184">특정 예의 경우 CommandField는 Linkbutton을 사용 하 고, 맨 왼쪽 필드에는 *Commandfieldindex* 가 0입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-184">For our particular example, the CommandField uses LinkButtons and, being the left-most field, has a *commandFieldIndex* of 0.</span></span> <span data-ttu-id="e7018-185">CommandField에는 다른 단추가 없고 삭제 단추도 있으므로 *controlIndex* 0을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-185">Since there are no other buttons but the Delete button in the CommandField, we use a *controlIndex* of 0.</span></span>

<span data-ttu-id="e7018-186">CommandField에서 삭제 단추를 참조 한 후에는 현재 GridView 행에 바인딩된 제품에 대 한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-186">After referencing the Delete button in the CommandField, we next grab information about the product bound to the current GridView row.</span></span> <span data-ttu-id="e7018-187">마지막으로 삭제 단추 s `OnClientClick` 속성을 제품 이름을 포함 하는 적절 한 JavaScript로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-187">Finally, we set the Delete button s `OnClientClick` property to the appropriate JavaScript, which includes the product s name.</span></span> <span data-ttu-id="e7018-188">`confirm(string)` 함수에 전달 된 JavaScript 문자열은 아포스트로피를 사용 하 여 구분 되므로 제품 이름 내에 표시 되는 모든 아포스트로피를 이스케이프 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-188">Since the JavaScript string passed into the `confirm(string)` function is delimited using apostrophes we must escape any apostrophes that appear within the product s name.</span></span> <span data-ttu-id="e7018-189">특히 제품 이름의 아포스트로피는 "`\'`"로 이스케이프 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-189">In particular, any apostrophes in the product s name are escaped with "`\'`".</span></span>

<span data-ttu-id="e7018-190">이러한 변경이 완료 되 면 GridView에서 삭제 단추를 클릭 하면 사용자 지정 된 확인 대화 상자가 표시 됩니다 (그림 4 참조).</span><span class="sxs-lookup"><span data-stu-id="e7018-190">With these changes complete, clicking on a Delete button in the GridView displays a customized confirmation dialog box (see Figure 4).</span></span> <span data-ttu-id="e7018-191">FormView의 확인 messagebox와 마찬가지로, 사용자가 취소를 클릭 하면 다시 게시가 취소 되어 삭제가 발생 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-191">As with the confirmation messagebox from the FormView, if the user clicks Cancel the postback is cancelled, thereby preventing the deletion from occurring.</span></span>

> [!NOTE]
> <span data-ttu-id="e7018-192">이 기술은 DetailsView의 CommandField에서 삭제 단추에 프로그래밍 방식으로 액세스 하는 데에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-192">This technique can also be used to programmatically access the Delete button in the CommandField in a DetailsView.</span></span> <span data-ttu-id="e7018-193">그러나 DetailsView의 경우 DetailsView에 `RowDataBound` 이벤트가 없으므로 `DataBound` 이벤트에 대 한 이벤트 처리기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-193">For the DetailsView, however, you d create an event handler for the `DataBound` event, since the DetailsView does not have a `RowDataBound` event.</span></span>

<span data-ttu-id="e7018-194">[GridView s 삭제 단추를 클릭 ![사용자 지정 된 확인 대화 상자가 표시 됩니다.](adding-client-side-confirmation-when-deleting-cs/_static/image9.png)](adding-client-side-confirmation-when-deleting-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="e7018-194">[![Clicking the GridView s Delete Button Displays a Customized Confirmation Dialog Box](adding-client-side-confirmation-when-deleting-cs/_static/image9.png)](adding-client-side-confirmation-when-deleting-cs/_static/image8.png)</span></span>

<span data-ttu-id="e7018-195">**그림 4**: GridView s 삭제 단추를 클릭 하면 사용자 지정 된 확인 대화 상자가 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](adding-client-side-confirmation-when-deleting-cs/_static/image10.png)).</span><span class="sxs-lookup"><span data-stu-id="e7018-195">**Figure 4**: Clicking the GridView s Delete Button Displays a Customized Confirmation Dialog Box ([Click to view full-size image](adding-client-side-confirmation-when-deleting-cs/_static/image10.png))</span></span>

## <a name="using-templatefields"></a><span data-ttu-id="e7018-196">서식 필드 사용</span><span class="sxs-lookup"><span data-stu-id="e7018-196">Using TemplateFields</span></span>

<span data-ttu-id="e7018-197">CommandField의 단점 중 하나는 인덱싱을 통해 해당 단추에 액세스 하 고 결과 개체를 적절 한 단추 유형 (Button, LinkButton 또는 ImageButton)으로 캐스팅 해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-197">One of the disadvantages of the CommandField is that its buttons must be accessed through indexing and that the resulting object must be cast to the appropriate button type (Button, LinkButton, or ImageButton).</span></span> <span data-ttu-id="e7018-198">"매직 넘버" 및 하드 코드 된 형식을 사용 하면 런타임 시까지 검색할 수 없는 문제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-198">Using "magic numbers" and hard-coded types invites problems that cannot be discovered until runtime.</span></span> <span data-ttu-id="e7018-199">예를 들어, 또는 다른 개발자가 앞으로의 특정 시점 (예: 편집 단추)에서 CommandField에 새 단추를 추가 하거나 `ButtonType` 속성을 변경 하면 기존 코드는 오류 없이 컴파일되지만 코드 작성 방법 및 변경 된 내용에 따라 예외 또는 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-199">For example, if you, or another developer, adds new buttons to the CommandField at some point in the future (such as an Edit button) or changes the `ButtonType` property, the existing code will still compile without error, but visiting the page may cause an exception or unexpected behavior, depending on how your code was written and what changes were made.</span></span>

<span data-ttu-id="e7018-200">다른 방법은 GridView 및 DetailsView s CommandFields를 템플릿 필드로 변환 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-200">An alternative approach is to convert the GridView and DetailsView s CommandFields into TemplateFields.</span></span> <span data-ttu-id="e7018-201">이렇게 하면 CommandField의 각 단추에 대해 LinkButton (또는 단추 또는 ImageButton)가 있는 `ItemTemplate`를 사용 하 여 Templatefield로 변환 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-201">This will generate a TemplateField with an `ItemTemplate` that has a LinkButton (or Button or ImageButton) for each button in the CommandField.</span></span> <span data-ttu-id="e7018-202">이러한 단추 `OnClientClick` 속성은 FormView에서 볼 때 선언적으로 할당 되거나 다음 패턴을 사용 하 여 적절 한 `DataBound` 이벤트 처리기에서 프로그래밍 방식으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-202">These buttons `OnClientClick` properties can be assigned declaratively, as we saw with the FormView, or can be programmatically accessed in the appropriate `DataBound` event handler using the following pattern:</span></span>

[!code-csharp[Main](adding-client-side-confirmation-when-deleting-cs/samples/sample7.cs)]

<span data-ttu-id="e7018-203">여기서 *controlID* 는 단추 `ID` 속성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-203">Where *controlID* is the value of the button s `ID` property.</span></span> <span data-ttu-id="e7018-204">이 패턴에는 캐스팅을 위해 하드 코드 된 형식이 필요 하지만 인덱싱의 필요성이 제거 되어 런타임 오류가 발생 하지 않고 레이아웃이 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-204">While this pattern still requires a hard-coded type for the cast, it removes the need for indexing, allowing for the layout to change without resulting in a runtime error.</span></span>

## <a name="summary"></a><span data-ttu-id="e7018-205">요약</span><span class="sxs-lookup"><span data-stu-id="e7018-205">Summary</span></span>

<span data-ttu-id="e7018-206">JavaScript `confirm(string)` 함수는 양식 전송 워크플로를 제어 하는 데 일반적으로 사용 되는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-206">The JavaScript `confirm(string)` function is a commonly used technique for controlling form submission workflow.</span></span> <span data-ttu-id="e7018-207">이 함수는 실행 될 때 두 개의 단추 (OK 및 Cancel)를 포함 하는 모달 클라이언트 쪽 대화 상자를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-207">When executed, the function displays a modal, client-side dialog box that includes two buttons, OK and Cancel.</span></span> <span data-ttu-id="e7018-208">사용자가 확인을 클릭 하면 `confirm(string)` 함수는 `true`을 반환 합니다. 취소를 클릭 하면 `false`반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-208">If the user clicks OK, the `confirm(string)` function returns `true`; clicking Cancel returns `false`.</span></span> <span data-ttu-id="e7018-209">전송 프로세스 중에 이벤트 처리기가 `false`반환 하는 경우이 기능을 사용 하 여 양식 전송을 취소할 수 있으며, 레코드를 삭제할 때 확인 messagebox를 표시 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-209">This functionality, coupled with a browser s behavior to cancel a form submission if an event handler during the submission process returns `false`, can be used to display a confirmation messagebox when deleting a record.</span></span>

<span data-ttu-id="e7018-210">`confirm(string)` 함수는 컨트롤의 `OnClientClick` 속성을 통해 단추 웹 컨트롤의 클라이언트 쪽 `onclick` 이벤트 처리기에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-210">The `confirm(string)` function can be associated with a Button Web control s client-side `onclick` event handler through the control s `OnClientClick` property.</span></span> <span data-ttu-id="e7018-211">FormView의 템플릿 또는 DetailsView 또는 GridView의 Templatefield로 변환에서 템플릿의 삭제 단추를 사용 하 여 작업 하는 경우이 자습서에서 살펴본 것 처럼이 속성을 선언적으로 설정 하거나 프로그래밍 방식으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-211">When working with a Delete button in a template - either in one of the FormView s templates or in a TemplateField in the DetailsView or GridView - this property can be set either declaratively or programmatically, as we saw in this tutorial.</span></span>

<span data-ttu-id="e7018-212">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="e7018-212">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="e7018-213">저자 정보</span><span class="sxs-lookup"><span data-stu-id="e7018-213">About the Author</span></span>

<span data-ttu-id="e7018-214">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-214">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e7018-215">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-215">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e7018-216">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-216">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="e7018-217">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="e7018-217">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="e7018-218">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7018-218">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="e7018-219">[이전](implementing-optimistic-concurrency-cs.md)
> [다음](limiting-data-modification-functionality-based-on-the-user-cs.md)</span><span class="sxs-lookup"><span data-stu-id="e7018-219">[Previous](implementing-optimistic-concurrency-cs.md)
[Next](limiting-data-modification-functionality-based-on-the-user-cs.md)</span></span>
