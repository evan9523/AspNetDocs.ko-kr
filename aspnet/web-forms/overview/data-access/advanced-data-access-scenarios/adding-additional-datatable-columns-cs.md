---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/adding-additional-datatable-columns-cs
title: 추가 DataTable 열 추가 (C#) | Microsoft Docs
author: rick-anderson
description: TableAdapter 마법사를 사용 하 여 형식화 된 데이터 집합을 만드는 경우 해당 DataTable에는 주 데이터베이스 쿼리에서 반환 된 열이 포함 됩니다. 하지만
ms.author: riande
ms.date: 07/18/2007
ms.assetid: 615f3361-f21f-4338-8bc1-fce8ae071de9
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/adding-additional-datatable-columns-cs
msc.type: authoredcontent
ms.openlocfilehash: a96f254aa54e7077456ac1a9bd6c5e2a17619d96
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78444497"
---
# <a name="adding-additional-datatable-columns-c"></a><span data-ttu-id="fd7c4-104">추가 DataTable 열 추가(C#)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-104">Adding Additional DataTable Columns (C#)</span></span>

<span data-ttu-id="fd7c4-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="fd7c4-106">[코드 다운로드](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_70_CS.zip) 또는 [PDF 다운로드](adding-additional-datatable-columns-cs/_static/datatutorial70cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_70_CS.zip) or [Download PDF](adding-additional-datatable-columns-cs/_static/datatutorial70cs1.pdf)</span></span>

> <span data-ttu-id="fd7c4-107">TableAdapter 마법사를 사용 하 여 형식화 된 데이터 집합을 만드는 경우 해당 DataTable에는 주 데이터베이스 쿼리에서 반환 된 열이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-107">When using the TableAdapter Wizard to create a Typed DataSet, the corresponding DataTable contains the columns returned by the main database query.</span></span> <span data-ttu-id="fd7c4-108">그러나 DataTable에 추가 열을 포함 해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-108">But there are occasions when the DataTable needs to include additional columns.</span></span> <span data-ttu-id="fd7c4-109">이 자습서에서는 추가 DataTable 열이 필요할 때 저장 프로시저를 권장 하는 이유를 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-109">In this tutorial we learn why stored procedures are recommended when we need additional DataTable columns.</span></span>

## <a name="introduction"></a><span data-ttu-id="fd7c4-110">소개</span><span class="sxs-lookup"><span data-stu-id="fd7c4-110">Introduction</span></span>

<span data-ttu-id="fd7c4-111">형식화 된 데이터 집합에 TableAdapter를 추가 하는 경우 해당 DataTable의 스키마는 TableAdapter의 주 쿼리에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-111">When adding a TableAdapter to a Typed DataSet, the corresponding DataTable s schema is determined by the TableAdapter s main query.</span></span> <span data-ttu-id="fd7c4-112">예를 들어 주 쿼리가 *a*, *b*및 *c*데이터 필드를 반환 하는 경우 DataTable에 *는 A*, *b*, *c*라는 3 개의 해당 열이 포함 됩니다. TableAdapter는 주 쿼리 외에도 일부 매개 변수를 기반으로 데이터의 하위 집합을 반환 하는 추가 쿼리를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-112">For example, if the main query returns data fields *A*, *B*, and *C*, the DataTable will have three corresponding columns named *A*, *B*, and *C*. In addition to its main query, a TableAdapter can include additional queries that return, perhaps, a subset of the data based on some parameter.</span></span> <span data-ttu-id="fd7c4-113">예를 들어 모든 제품에 대 한 정보를 반환 하는 `ProductsTableAdapter` s 주 쿼리 외에도 제공 된 매개 변수에 따라 특정 제품 정보를 반환 하는 `GetProductsByCategoryID(categoryID)` 및 `GetProductByProductID(productID)`와 같은 메서드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-113">For instance, in addition to the `ProductsTableAdapter` s main query, which returns information about all products, it also contains methods like `GetProductsByCategoryID(categoryID)` and `GetProductByProductID(productID)`, which return specific product information based on a supplied parameter.</span></span>

<span data-ttu-id="fd7c4-114">DataTable의 스키마가 있는 주 쿼리를 반영 하는 모델은 TableAdapter의 모든 메서드가 주 쿼리에 지정 된 것과 같거나 작은 데이터 필드를 반환 하는 경우 제대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-114">The model of having the DataTable s schema reflect the TableAdapter s main query works well if all of the TableAdapter s methods return the same or fewer data fields than those specified in the main query.</span></span> <span data-ttu-id="fd7c4-115">TableAdapter 메서드가 추가 데이터 필드를 반환 해야 하는 경우 DataTable의 스키마를 적절 하 게 확장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-115">If a TableAdapter method needs to return additional data fields, then we should expand the DataTable s schema accordingly.</span></span> <span data-ttu-id="fd7c4-116">[세부 정보를 포함 하는 마스터 레코드의 글머리 기호 목록을 사용 하는 마스터/세부 정보 DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) 자습서에서는 기본 `NumberOfProducts`쿼리에 정의 된 `CategoryID`, `CategoryName`및 `Description` 데이터 필드를 반환 하 고 각 범주와 관련 된 제품 수를 보고 하는 추가 데이터 필드를 반환 하는 메서드를 `CategoriesTableAdapter`에 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-116">In the [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) tutorial we added a method to the `CategoriesTableAdapter` that returned the `CategoryID`, `CategoryName`, and `Description` data fields defined in the main query plus `NumberOfProducts`, an additional data field that reported the number of products associated with each category.</span></span> <span data-ttu-id="fd7c4-117">이 새 메서드에서 `NumberOfProducts` 데이터 필드 값을 캡처하기 위해 `CategoriesDataTable`에 새 열을 수동으로 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-117">We manually added a new column to the `CategoriesDataTable` in order to capture the `NumberOfProducts` data field value from this new method.</span></span>

<span data-ttu-id="fd7c4-118">[파일 업로드](../working-with-binary-files/uploading-files-cs.md) 자습서에 설명 된 것 처럼 임시 SQL 문을 사용 하 고 데이터 필드가 주 쿼리와 정확 하 게 일치 하지 않는 메서드를 사용 하는 tableadapter를 사용 하 여 많은 주의가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-118">As discussed in the [Uploading Files](../working-with-binary-files/uploading-files-cs.md) tutorial, great care must be taken with TableAdapters that use ad-hoc SQL statements and have methods whose data fields do not precisely match the main query.</span></span> <span data-ttu-id="fd7c4-119">TableAdapter 구성 마법사가 다시 실행 되는 경우 해당 데이터 필드 목록이 주 쿼리와 일치 하도록 TableAdapter의 모든 메서드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-119">If the TableAdapter Configuration wizard is re-run, it will update all of the TableAdapter s methods so that their data field list matches the main query.</span></span> <span data-ttu-id="fd7c4-120">따라서 사용자 지정 된 열 목록을 포함 하는 모든 메서드는 주 쿼리 열 목록으로 되돌아가고 필요한 데이터를 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-120">Consequently, any methods with customized column lists will revert to the main query s column list and not return the expected data.</span></span> <span data-ttu-id="fd7c4-121">저장 프로시저를 사용 하는 경우에는이 문제가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-121">This issue does not arise when using stored procedures.</span></span>

<span data-ttu-id="fd7c4-122">이 자습서에서는 추가 열을 포함 하도록 DataTable의 스키마를 확장 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-122">In this tutorial we will look at how to extend a DataTable s schema to include additional columns.</span></span> <span data-ttu-id="fd7c4-123">이 자습서에서는 임시 SQL 문을 사용할 때 TableAdapter의 brittleness 때문에 저장 프로시저를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-123">Due to the brittleness of the TableAdapter when using ad-hoc SQL statements, in this tutorial we will use stored procedures.</span></span> <span data-ttu-id="fd7c4-124">저장 프로시저를 사용 하도록 TableAdapter를 구성 하는 방법에 대 한 자세한 내용은 [형식화 된 데이터 집합의 tableadapter에 대 한 새 저장 프로시저 만들기](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) 및 [형식화 된 데이터 집합의 tableadapter 자습서에 대 한 기존 저장 프로시저 사용](https://data-access/tutorials/using-existing-stored-procedures-for-the-typed-dataset-amp-rsquo-s-tableadapters-cs) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-124">Refer to the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) and [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](https://data-access/tutorials/using-existing-stored-procedures-for-the-typed-dataset-amp-rsquo-s-tableadapters-cs) tutorials for more information on configuring a TableAdapter to use stored procedures.</span></span>

## <a name="step-1-adding-apricequartilecolumn-to-theproductsdatatable"></a><span data-ttu-id="fd7c4-125">1 단계:`ProductsDataTable`에`PriceQuartile`열 추가</span><span class="sxs-lookup"><span data-stu-id="fd7c4-125">Step 1: Adding a`PriceQuartile`Column to the`ProductsDataTable`</span></span>

<span data-ttu-id="fd7c4-126">형식화 된 *데이터 집합에 대 한 새 저장 프로시저 만들기 tableadapter* 자습서에서 `NorthwindWithSprocs`이라는 형식화 된 데이터 집합을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-126">In the *Creating New Stored Procedures for the Typed DataSet s TableAdapters* tutorial we created a Typed DataSet named `NorthwindWithSprocs`.</span></span> <span data-ttu-id="fd7c4-127">이 데이터 집합에는 현재 두 개의 `ProductsDataTable` Datatable와 `EmployeesDataTable`포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-127">This DataSet currently contains two DataTables: `ProductsDataTable` and `EmployeesDataTable`.</span></span> <span data-ttu-id="fd7c4-128">`ProductsTableAdapter`에는 다음과 같은 세 가지 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-128">The `ProductsTableAdapter` has the following three methods:</span></span>

- <span data-ttu-id="fd7c4-129">`GetProducts`-`Products` 테이블의 모든 레코드를 반환 하는 주 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-129">`GetProducts` - the main query, which returns all records from the `Products` table</span></span>
- <span data-ttu-id="fd7c4-130">`GetProductsByCategoryID(categoryID)`-지정 된 *categoryID*를 포함 하는 모든 제품을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-130">`GetProductsByCategoryID(categoryID)` - returns all products with the specified *categoryID*.</span></span>
- <span data-ttu-id="fd7c4-131">`GetProductByProductID(productID)`-지정 된 *productID*를 사용 하 여 특정 제품을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-131">`GetProductByProductID(productID)` - returns the particular product with the specified *productID*.</span></span>

<span data-ttu-id="fd7c4-132">주 쿼리와 두 개의 추가 메서드는 모두 동일한 데이터 필드 집합, 즉 `Products` 테이블의 모든 열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-132">The main query and the two additional methods all return the same set of data fields, namely all of the columns from the `Products` table.</span></span> <span data-ttu-id="fd7c4-133">상호 관련 된 하위 쿼리 또는 `Categories` 또는 `Suppliers` 테이블에서 관련 된 데이터를 가져오는 `JOIN` 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-133">There are no correlated subqueries or `JOIN` s pulling related data from the `Categories` or `Suppliers` tables.</span></span> <span data-ttu-id="fd7c4-134">따라서 `ProductsDataTable` `Products` 테이블의 각 필드에 해당 하는 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-134">Therefore, the `ProductsDataTable` has a corresponding column for each field in the `Products` table.</span></span>

<span data-ttu-id="fd7c4-135">이 자습서에서는 모든 제품을 반환 하는 `GetProductsWithPriceQuartile` 라는 `ProductsTableAdapter`에 메서드를 추가 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-135">For this tutorial, let s add a method to the `ProductsTableAdapter` named `GetProductsWithPriceQuartile` that returns all of the products.</span></span> <span data-ttu-id="fd7c4-136">표준 제품 데이터 필드 외에도 `GetProductsWithPriceQuartile`에는 제품 가격의 사분이를 나타내는 `PriceQuartile` 데이터 필드도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-136">In addition to the standard product data fields, `GetProductsWithPriceQuartile` will also include a `PriceQuartile` data field that indicates under which quartile the product s price falls.</span></span> <span data-ttu-id="fd7c4-137">예를 들어 가격이 가장 비싼 25%에 해당 하는 제품의 `PriceQuartile` 값은 1이 고 가격은 하위 25%에 속하는 제품은 값이 4입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-137">For example, those products whose prices are in the most expensive 25% will have a `PriceQuartile` value of 1, while those whose prices fall in the bottom 25% will have a value of 4.</span></span> <span data-ttu-id="fd7c4-138">그러나이 정보를 반환 하는 저장 프로시저를 만드는 방법에 대해 걱정할 때 까지는 먼저 `GetProductsWithPriceQuartile` 메서드를 사용할 때 `PriceQuartile` 결과를 저장할 열을 포함 하도록 `ProductsDataTable`를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-138">Before we worry about creating the stored procedure to return this information, however, we first need to update the `ProductsDataTable` to include a column to hold the `PriceQuartile` results when the `GetProductsWithPriceQuartile` method is used.</span></span>

<span data-ttu-id="fd7c4-139">`NorthwindWithSprocs` 데이터 집합을 열고 `ProductsDataTable`을 마우스 오른쪽 단추로 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-139">Open the `NorthwindWithSprocs` DataSet and right-click on the `ProductsDataTable`.</span></span> <span data-ttu-id="fd7c4-140">상황에 맞는 메뉴에서 추가를 선택한 다음 열을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-140">Choose Add from the context-menu and then pick Column.</span></span>

<span data-ttu-id="fd7c4-141">[ProductsDataTable에 새 열을 추가 ![](adding-additional-datatable-columns-cs/_static/image2.png)](adding-additional-datatable-columns-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-141">[![Add a New Column to the ProductsDataTable](adding-additional-datatable-columns-cs/_static/image2.png)](adding-additional-datatable-columns-cs/_static/image1.png)</span></span>

<span data-ttu-id="fd7c4-142">**그림 1**: `ProductsDataTable`에 새 열 추가 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-142">**Figure 1**: Add a New Column to the `ProductsDataTable` ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image3.png))</span></span>

<span data-ttu-id="fd7c4-143">그러면 `System.String`형식의 Column1 이라는 DataTable에 새 열이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-143">This will add a new column to the DataTable named Column1 of type `System.String`.</span></span> <span data-ttu-id="fd7c4-144">이 열 이름을 PriceQuartile로 업데이트 하 고 해당 형식을 `System.Int32`로 업데이트 하 여 1에서 4 사이의 숫자를 저장 하는 데 사용 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-144">We need to update this column s name to PriceQuartile and its type to `System.Int32` since it will be used to hold a number between 1 and 4.</span></span> <span data-ttu-id="fd7c4-145">`ProductsDataTable`에서 새로 추가 된 열을 선택 하 고 속성 창에서 `Name` 속성을 PriceQuartile로 설정 하 고 `DataType` 속성을 `System.Int32`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-145">Select the newly-added column in the `ProductsDataTable` and, from the Properties window, set the `Name` property to PriceQuartile and the `DataType` property to `System.Int32`.</span></span>

<span data-ttu-id="fd7c4-146">[새 열의 이름 및 데이터 형식 속성을 설정 ![](adding-additional-datatable-columns-cs/_static/image5.png)](adding-additional-datatable-columns-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-146">[![Set the New Column s Name and DataType Properties](adding-additional-datatable-columns-cs/_static/image5.png)](adding-additional-datatable-columns-cs/_static/image4.png)</span></span>

<span data-ttu-id="fd7c4-147">**그림 2**: 새 열 `Name` 설정 및 `DataType` 속성 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-147">**Figure 2**: Set the New Column s `Name` and `DataType` Properties ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image6.png))</span></span>

<span data-ttu-id="fd7c4-148">그림 2에 나와 있는 것 처럼 열의 값이 고유 해야 하는지 여부, 열이 자동 증분 열 이면 데이터베이스 `NULL` 값이 허용 되는지 여부 등의 추가 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-148">As Figure 2 shows, there are additional properties that can be set, such as whether the values in the column must be unique, if the column is an auto-increment column, whether or not database `NULL` values are allowed, and so on.</span></span> <span data-ttu-id="fd7c4-149">이러한 값을 기본값으로 설정 해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-149">Leave these values set to their defaults.</span></span>

## <a name="step-2-creating-thegetproductswithpricequartilemethod"></a><span data-ttu-id="fd7c4-150">2 단계:`GetProductsWithPriceQuartile`메서드 만들기</span><span class="sxs-lookup"><span data-stu-id="fd7c4-150">Step 2: Creating the`GetProductsWithPriceQuartile`Method</span></span>

<span data-ttu-id="fd7c4-151">이제 `PriceQuartile` 열을 포함 하도록 `ProductsDataTable` 업데이트 되었으므로 `GetProductsWithPriceQuartile` 메서드를 만들 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-151">Now that the `ProductsDataTable` has been updated to include the `PriceQuartile` column, we are ready to create the `GetProductsWithPriceQuartile` method.</span></span> <span data-ttu-id="fd7c4-152">TableAdapter를 마우스 오른쪽 단추로 클릭 하 고 상황에 맞는 메뉴에서 쿼리 추가를 선택 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-152">Start by right-clicking on the TableAdapter and choosing Add Query from the context-menu.</span></span> <span data-ttu-id="fd7c4-153">그러면 TableAdapter 쿼리 구성 마법사가 표시 되며,이 마법사에서 임시 SQL 문이나 기존 저장 프로시저를 사용할지 여부를 묻는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-153">This brings up the TableAdapter Query Configuration wizard, which first prompts us as to whether we want to use ad-hoc SQL statements or a new or existing stored procedure.</span></span> <span data-ttu-id="fd7c4-154">아직 가격 사분 데이터를 반환 하는 저장 프로시저가 없으므로 s 1에서이 저장 프로시저를 만들도록 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-154">Since we don t yet have a stored procedure that returns the price quartile data, let s allow the TableAdapter to create this stored procedure for us.</span></span> <span data-ttu-id="fd7c4-155">새 저장 프로시저 만들기 옵션을 선택 하 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-155">Select the Create new stored procedure option and click Next.</span></span>

<span data-ttu-id="fd7c4-156">[TableAdapter 마법사에서 저장 프로시저를 만들도록 지시 ![](adding-additional-datatable-columns-cs/_static/image8.png)](adding-additional-datatable-columns-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-156">[![Instruct the TableAdapter Wizard to Create the Stored Procedure For Us](adding-additional-datatable-columns-cs/_static/image8.png)](adding-additional-datatable-columns-cs/_static/image7.png)</span></span>

<span data-ttu-id="fd7c4-157">**그림 3**: 저장 프로시저를 만들도록 TableAdapter 마법사에 지시 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-157">**Figure 3**: Instruct the TableAdapter Wizard to Create the Stored Procedure For Us ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image9.png))</span></span>

<span data-ttu-id="fd7c4-158">그림 4에 표시 된 후속 화면에서 마법사는 추가할 쿼리 유형을 묻는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-158">In the subsequent screen, shown in Figure 4, the wizard asks us what type of query to add.</span></span> <span data-ttu-id="fd7c4-159">`GetProductsWithPriceQuartile` 메서드는 `Products` 테이블에서 모든 열과 레코드를 반환 하므로 행 반환 옵션을 선택 하 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-159">Since the `GetProductsWithPriceQuartile` method will return all columns and records from the `Products` table, select the SELECT which returns rows option and click Next.</span></span>

<span data-ttu-id="fd7c4-160">[![쿼리는 여러 행을 반환 하는 SELECT 문이 됩니다.](adding-additional-datatable-columns-cs/_static/image11.png)](adding-additional-datatable-columns-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-160">[![Our Query will be a SELECT Statement that Returns Multiple Rows](adding-additional-datatable-columns-cs/_static/image11.png)](adding-additional-datatable-columns-cs/_static/image10.png)</span></span>

<span data-ttu-id="fd7c4-161">**그림 4**: 쿼리는 여러 행을 반환 하는 `SELECT` 문이 됩니다 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image12.png)).</span><span class="sxs-lookup"><span data-stu-id="fd7c4-161">**Figure 4**: Our Query will be a `SELECT` Statement that Returns Multiple Rows ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image12.png))</span></span>

<span data-ttu-id="fd7c4-162">그런 다음 `SELECT` 쿼리를 묻는 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-162">Next we are prompted for the `SELECT` query.</span></span> <span data-ttu-id="fd7c4-163">마법사에 다음 쿼리를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-163">Enter the following query into the wizard:</span></span>

[!code-sql[Main](adding-additional-datatable-columns-cs/samples/sample1.sql)]

<span data-ttu-id="fd7c4-164">위의 쿼리는 SQL Server 2005 s new [`NTILE` 함수](https://msdn.microsoft.com/library/ms175126.aspx) 를 사용 하 여 결과를 4 개의 그룹으로 나눕니다. 여기서 그룹은 내림차순으로 정렬 된 `UnitPrice` 값에 따라 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-164">The above query uses SQL Server 2005 s new [`NTILE` function](https://msdn.microsoft.com/library/ms175126.aspx) to divide the results into four groups where the groups are determined by the `UnitPrice` values sorted in descending order.</span></span>

<span data-ttu-id="fd7c4-165">아쉽게도 쿼리 작성기는 `OVER` 키워드를 구문 분석 하는 방법을 알지 못합니다. 위의 쿼리를 구문 분석할 때 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-165">Unfortunately, the Query Builder does not know how to parse the `OVER` keyword and will display an error when parsing the above query.</span></span> <span data-ttu-id="fd7c4-166">따라서 쿼리 작성기을 사용 하지 않고 마법사의 텍스트 상자에 위의 쿼리를 직접 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-166">Therefore, enter the above query directly in the textbox in the wizard without using the Query Builder.</span></span>

> [!NOTE]
> <span data-ttu-id="fd7c4-167">NTILE 및 SQL Server 2005 s 기타 순위 지정 함수에 대 한 자세한 내용은 [SQL Server 2005 온라인 설명서](https://msdn.microsoft.com/library/ms189798.aspx)의 [Microsoft SQL Server 2005을 사용 하 여 순위 지정 결과 반환](http://www.4guysfromrolla.com/webtech/010406-1.shtml) 및 [순위 함수 섹션](https://msdn.microsoft.com/library/ms189798.aspx) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-167">For more information on NTILE and SQL Server 2005 s other ranking functions, see [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml) and the [Ranking Functions section](https://msdn.microsoft.com/library/ms189798.aspx) from the [SQL Server 2005 Books Online](https://msdn.microsoft.com/library/ms189798.aspx).</span></span>

<span data-ttu-id="fd7c4-168">`SELECT` 쿼리를 입력 하 고 다음을 클릭 하면 마법사가 만들 저장 프로시저의 이름을 입력 하 라는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-168">After entering the `SELECT` query and clicking Next, the wizard asks us to provide a name for the stored procedure it will create.</span></span> <span data-ttu-id="fd7c4-169">새 저장 프로시저의 이름을 `Products_SelectWithPriceQuartile` 하 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-169">Name the new stored procedure `Products_SelectWithPriceQuartile` and click Next.</span></span>

<span data-ttu-id="fd7c4-170">[저장 프로시저의 이름을 ![Products_SelectWithPriceQuartile](adding-additional-datatable-columns-cs/_static/image14.png)](adding-additional-datatable-columns-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-170">[![Name the Stored Procedure Products_SelectWithPriceQuartile](adding-additional-datatable-columns-cs/_static/image14.png)](adding-additional-datatable-columns-cs/_static/image13.png)</span></span>

<span data-ttu-id="fd7c4-171">**그림 5**: 저장 프로시저의 이름 `Products_SelectWithPriceQuartile` ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-171">**Figure 5**: Name the Stored Procedure `Products_SelectWithPriceQuartile` ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image15.png))</span></span>

<span data-ttu-id="fd7c4-172">마지막으로 TableAdapter 메서드의 이름을 입력 하 라는 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-172">Lastly, we are prompted to name the TableAdapter methods.</span></span> <span data-ttu-id="fd7c4-173">DataTable 채우기 및 DataTable 반환 확인란을 모두 선택 된 상태로 두고 `FillWithPriceQuartile` 메서드의 이름을 지정 하 고 `GetProductsWithPriceQuartile`합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-173">Leave both the Fill a DataTable and Return a DataTable checkboxes checked and name the methods `FillWithPriceQuartile` and `GetProductsWithPriceQuartile`.</span></span>

<span data-ttu-id="fd7c4-174">[TableAdapter의 메서드 이름을 ![하 고 마침을 클릭 합니다.](adding-additional-datatable-columns-cs/_static/image17.png)](adding-additional-datatable-columns-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-174">[![Name the TableAdapter s Methods and Click Finish](adding-additional-datatable-columns-cs/_static/image17.png)](adding-additional-datatable-columns-cs/_static/image16.png)</span></span>

<span data-ttu-id="fd7c4-175">**그림 6**: TableAdapter의 메서드 이름 및 마침 클릭 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-175">**Figure 6**: Name the TableAdapter s Methods and Click Finish ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image18.png))</span></span>

<span data-ttu-id="fd7c4-176">`SELECT` 쿼리를 지정 하 고 저장 프로시저와 TableAdapter 메서드를 지정 하 고 마침을 클릭 하 여 마법사를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-176">With the `SELECT` query specified and the stored procedure and TableAdapter methods named, click Finish to complete the wizard.</span></span> <span data-ttu-id="fd7c4-177">이 시점에서 `OVER` SQL 구문이 나 문이 지원 되지 않는다는 경고가 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-177">At this point you may get a warning or two from the wizard saying that The `OVER` SQL construct or statement is not supported.</span></span> <span data-ttu-id="fd7c4-178">이러한 경고는 무시 해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-178">These warnings can be ignored.</span></span>

<span data-ttu-id="fd7c4-179">마법사를 완료 한 후에는 TableAdapter에 `FillWithPriceQuartile` 및 `GetProductsWithPriceQuartile` 메서드가 포함 되어야 하며 데이터베이스에 `Products_SelectWithPriceQuartile`이라는 저장 프로시저가 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-179">After completing the wizard, the TableAdapter should include the `FillWithPriceQuartile` and `GetProductsWithPriceQuartile` methods and the database should include a stored procedure named `Products_SelectWithPriceQuartile`.</span></span> <span data-ttu-id="fd7c4-180">TableAdapter가이 새 메서드를 실제로 포함 하 고 저장 프로시저가 데이터베이스에 올바르게 추가 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-180">Take a moment to verify that the TableAdapter does indeed contain this new method and that the stored procedure has been correctly added to the database.</span></span> <span data-ttu-id="fd7c4-181">데이터베이스를 확인할 때 저장 프로시저가 표시 되지 않는 경우 저장 프로시저 폴더를 마우스 오른쪽 단추로 클릭 하 고 새로 고침을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-181">When checking the database, if you do not see the stored procedure try right-clicking on the Stored Procedures folder and choosing Refresh.</span></span>

![새 메서드가 TableAdapter에 추가 되었는지 확인 합니다.](adding-additional-datatable-columns-cs/_static/image19.png)

<span data-ttu-id="fd7c4-183">**그림 7**: 새 메서드가 TableAdapter에 추가 되었는지 확인</span><span class="sxs-lookup"><span data-stu-id="fd7c4-183">**Figure 7**: Verify that a New Method Has Been Added to the TableAdapter</span></span>

<span data-ttu-id="fd7c4-184">[![데이터베이스에 Products_SelectWithPriceQuartile 저장 프로시저가 포함 되어 있는지 확인 합니다.](adding-additional-datatable-columns-cs/_static/image21.png)](adding-additional-datatable-columns-cs/_static/image20.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-184">[![Ensure that the Database Contains the Products_SelectWithPriceQuartile Stored Procedure](adding-additional-datatable-columns-cs/_static/image21.png)](adding-additional-datatable-columns-cs/_static/image20.png)</span></span>

<span data-ttu-id="fd7c4-185">**그림 8**: 데이터베이스에 `Products_SelectWithPriceQuartile` 저장 프로시저 포함 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image22.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-185">**Figure 8**: Ensure that the Database Contains the `Products_SelectWithPriceQuartile` Stored Procedure ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image22.png))</span></span>

> [!NOTE]
> <span data-ttu-id="fd7c4-186">임시 SQL 문 대신 저장 프로시저를 사용 하는 경우의 이점 중 하나는 TableAdapter 구성 마법사를 다시 실행 하면 저장 프로시저 열 목록이 수정 되지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-186">One of the benefits of using stored procedures instead of ad-hoc SQL statements is that re-running the TableAdapter Configuration wizard will not modify the stored procedures column lists.</span></span> <span data-ttu-id="fd7c4-187">TableAdapter를 마우스 오른쪽 단추로 클릭 하 고 상황에 맞는 메뉴에서 구성 옵션을 선택 하 여 마법사를 시작 하 고 마침을 클릭 하 여 마법사를 완료 하 여이를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-187">Verify this by right-clicking on the TableAdapter, choosing the Configure option from the context-menu to start the wizard, and then clicking Finish to complete it.</span></span> <span data-ttu-id="fd7c4-188">그런 다음 데이터베이스로 이동 하 여 `Products_SelectWithPriceQuartile` 저장 프로시저를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-188">Next, go to the database and view the `Products_SelectWithPriceQuartile` stored procedure.</span></span> <span data-ttu-id="fd7c4-189">열 목록은 수정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-189">Note that its column list has not been modified.</span></span> <span data-ttu-id="fd7c4-190">임시 SQL 문을 사용 하는 경우 TableAdapter 구성 마법사를 다시 실행 하면이 쿼리 열 목록이 주 쿼리 열 목록과 일치 하도록 되돌려 `GetProductsWithPriceQuartile` 메서드에서 사용 하는 쿼리에서 NTILE 문을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-190">Had we been using ad-hoc SQL statements, re-running the TableAdapter Configuration wizard would have reverted this query s column list to match the main query column list, thereby removing the NTILE statement from the query used by the `GetProductsWithPriceQuartile` method.</span></span>

<span data-ttu-id="fd7c4-191">데이터 액세스 계층 s `GetProductsWithPriceQuartile` 메서드가 호출 되 면 TableAdapter는 `Products_SelectWithPriceQuartile` 저장 프로시저를 실행 하 고 반환 된 각 레코드의 `ProductsDataTable`에 행을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-191">When the Data Access Layer s `GetProductsWithPriceQuartile` method is invoked, the TableAdapter executes the `Products_SelectWithPriceQuartile` stored procedure and adds a row to the `ProductsDataTable` for each returned record.</span></span> <span data-ttu-id="fd7c4-192">저장 프로시저에서 반환 되는 데이터 필드는 `ProductsDataTable` s 열에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-192">The data fields returned by the stored procedure are mapped to the `ProductsDataTable` s columns.</span></span> <span data-ttu-id="fd7c4-193">저장 프로시저에서 반환 된 `PriceQuartile` 데이터 필드가 있으므로 해당 값은 `ProductsDataTable` s `PriceQuartile` 열에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-193">Since there is a `PriceQuartile` data field returned from the stored procedure, its value is assigned to the `ProductsDataTable` s `PriceQuartile` column.</span></span>

<span data-ttu-id="fd7c4-194">쿼리가 `PriceQuartile` 데이터 필드를 반환 하지 않는 TableAdapter 메서드의 경우 `PriceQuartile` 열 값은 `DefaultValue` 속성으로 지정 된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-194">For those TableAdapter methods whose queries do not return a `PriceQuartile` data field, the `PriceQuartile` column s value is the value specified by its `DefaultValue` property.</span></span> <span data-ttu-id="fd7c4-195">그림 2에서 볼 수 있듯이이 값은 기본값 `DBNull`로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-195">As Figure 2 shows, this value is set to `DBNull`, the default.</span></span> <span data-ttu-id="fd7c4-196">다른 기본값을 선호 하는 경우에는 `DefaultValue` 속성을 적절 하 게 설정 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-196">If you would prefer a different default value, simply set the `DefaultValue` property accordingly.</span></span> <span data-ttu-id="fd7c4-197">`DataType` 열에 지정 된 `DefaultValue` 값이 유효한 지 확인 합니다. 즉, `PriceQuartile` 열에 대해 `System.Int32` 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-197">Just make sure that the `DefaultValue` value is valid given the column s `DataType` (i.e., `System.Int32` for the `PriceQuartile` column).</span></span>

<span data-ttu-id="fd7c4-198">이 시점에서 DataTable에 열을 추가 하는 데 필요한 단계를 수행 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-198">At this point we have performed the necessary steps for adding an additional column to a DataTable.</span></span> <span data-ttu-id="fd7c4-199">이 추가 열이 예상 대로 작동 하는지 확인 하려면를 사용 하 여 각 제품의 이름, 가격 및 가격 사분을 표시 하는 ASP.NET 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-199">To verify that this additional column works as expected, let s create an ASP.NET page that displays each product s name, price, and price quartile.</span></span> <span data-ttu-id="fd7c4-200">그러나이 작업을 수행 하기 전에 먼저 비즈니스 논리 계층을 업데이트 하 여 DAL s `GetProductsWithPriceQuartile` 메서드를 호출 하는 메서드를 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-200">Before we do that, though, we first need to update the Business Logic Layer to include a method that calls down to the DAL s `GetProductsWithPriceQuartile` method.</span></span> <span data-ttu-id="fd7c4-201">3 단계에서 다음 BLL을 업데이트 한 다음 4 단계에서 ASP.NET 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-201">We will update the BLL next, in Step 3, and then create the ASP.NET page in Step 4.</span></span>

## <a name="step-3-augmenting-the-business-logic-layer"></a><span data-ttu-id="fd7c4-202">3 단계: 비즈니스 논리 계층 확대</span><span class="sxs-lookup"><span data-stu-id="fd7c4-202">Step 3: Augmenting the Business Logic Layer</span></span>

<span data-ttu-id="fd7c4-203">프레젠테이션 계층에서 새 `GetProductsWithPriceQuartile` 메서드를 사용 하기 전에 먼저 해당 메서드를 BLL에 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-203">Before we use the new `GetProductsWithPriceQuartile` method from the Presentation Layer, we should first add a corresponding method to the BLL.</span></span> <span data-ttu-id="fd7c4-204">`ProductsBLLWithSprocs` 클래스 파일을 열고 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-204">Open the `ProductsBLLWithSprocs` class file and add the following code:</span></span>

[!code-csharp[Main](adding-additional-datatable-columns-cs/samples/sample2.cs)]

<span data-ttu-id="fd7c4-205">`ProductsBLLWithSprocs`의 다른 데이터 검색 메서드와 마찬가지로 `GetProductsWithPriceQuartile` 메서드는 DAL의 해당 `GetProductsWithPriceQuartile` 메서드를 호출 하 고 해당 결과를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-205">Like the other data retrieval methods in `ProductsBLLWithSprocs`, the `GetProductsWithPriceQuartile` method simply calls the DAL s corresponding `GetProductsWithPriceQuartile` method and returns its results.</span></span>

## <a name="step-4-displaying-the-price-quartile-information-in-an-aspnet-web-page"></a><span data-ttu-id="fd7c4-206">4 단계: ASP.NET 웹 페이지에서 가격 사분 기준 정보 표시</span><span class="sxs-lookup"><span data-stu-id="fd7c4-206">Step 4: Displaying the Price Quartile Information in an ASP.NET Web Page</span></span>

<span data-ttu-id="fd7c4-207">BLL 추가가 완료 되 면 각 제품의 가격 사분을 보여 주는 ASP.NET 페이지를 만들 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-207">With the BLL addition complete we re ready to create an ASP.NET page that shows the price quartile for each product.</span></span> <span data-ttu-id="fd7c4-208">`AdvancedDAL` 폴더에서 `AddingColumns.aspx` 페이지를 열고 GridView를 도구 상자에서 디자이너로 끌어 `ID` 속성을 `Products`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-208">Open the `AddingColumns.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Products`.</span></span> <span data-ttu-id="fd7c4-209">GridView s 스마트 태그에서 `ProductsDataSource`라는 새 ObjectDataSource에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-209">From the GridView s smart tag, bind it to a new ObjectDataSource named `ProductsDataSource`.</span></span> <span data-ttu-id="fd7c4-210">`ProductsBLLWithSprocs` 클래스 s `GetProductsWithPriceQuartile` 메서드를 사용 하도록 ObjectDataSource를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-210">Configure the ObjectDataSource to use the `ProductsBLLWithSprocs` class s `GetProductsWithPriceQuartile` method.</span></span> <span data-ttu-id="fd7c4-211">이는 읽기 전용 그리드 이므로 업데이트, 삽입 및 삭제 탭의 드롭다운 목록을 (없음)으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-211">Since this will be a read-only grid, set the drop-down lists in the UPDATE, INSERT, and DELETE tabs to (None) .</span></span>

<span data-ttu-id="fd7c4-212">[ProductsBLLWithSprocs 클래스를 사용 하도록 ObjectDataSource 구성 ![](adding-additional-datatable-columns-cs/_static/image24.png)](adding-additional-datatable-columns-cs/_static/image23.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-212">[![Configure the ObjectDataSource to Use the ProductsBLLWithSprocs Class](adding-additional-datatable-columns-cs/_static/image24.png)](adding-additional-datatable-columns-cs/_static/image23.png)</span></span>

<span data-ttu-id="fd7c4-213">**그림 9**: `ProductsBLLWithSprocs` 클래스를 사용 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image25.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-213">**Figure 9**: Configure the ObjectDataSource to Use the `ProductsBLLWithSprocs` Class ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image25.png))</span></span>

<span data-ttu-id="fd7c4-214">[GetProductsWithPriceQuartile 메서드에서 제품 정보를 검색 ![](adding-additional-datatable-columns-cs/_static/image27.png)](adding-additional-datatable-columns-cs/_static/image26.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-214">[![Retrieve Product Information from the GetProductsWithPriceQuartile Method](adding-additional-datatable-columns-cs/_static/image27.png)](adding-additional-datatable-columns-cs/_static/image26.png)</span></span>

<span data-ttu-id="fd7c4-215">**그림 10**: `GetProductsWithPriceQuartile` 메서드에서 제품 정보 검색 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image28.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-215">**Figure 10**: Retrieve Product Information from the `GetProductsWithPriceQuartile` Method ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image28.png))</span></span>

<span data-ttu-id="fd7c4-216">데이터 소스 구성 마법사를 완료 한 후 Visual Studio에서 메서드가 반환 하는 각 데이터 필드에 대해 BoundField 또는 CheckBoxField를 GridView에 자동으로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-216">After completing the Configure Data Source wizard, Visual Studio will automatically add a BoundField or CheckBoxField to the GridView for each of the data fields returned by the method.</span></span> <span data-ttu-id="fd7c4-217">이러한 데이터 필드 중 하나는 `PriceQuartile`이며 1 단계에서 `ProductsDataTable` 추가 된 열입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-217">One of these data fields is `PriceQuartile`, which is the column we added to the `ProductsDataTable` in Step 1.</span></span>

<span data-ttu-id="fd7c4-218">GridView 필드를 편집 하 여 `ProductName`, `UnitPrice`및 `PriceQuartile` BoundFields를 제외한 모든 필드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-218">Edit the GridView s fields, removing all but the `ProductName`, `UnitPrice`, and `PriceQuartile` BoundFields.</span></span> <span data-ttu-id="fd7c4-219">`UnitPrice` BoundField를 구성 하 여 값의 서식을 통화로 지정 하 고 `UnitPrice` 및 `PriceQuartile` BoundFields 오른쪽 맞춤 및 가운데 맞춤을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-219">Configure the `UnitPrice` BoundField to format its value as a currency and have the `UnitPrice` and `PriceQuartile` BoundFields right- and center-aligned, respectively.</span></span> <span data-ttu-id="fd7c4-220">마지막으로 나머지 BoundFields `HeaderText` 속성을 Product, Price 및 Price 사분 각각로 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-220">Finally, update the remaining BoundFields `HeaderText` properties to Product, Price, and Price Quartile, respectively.</span></span> <span data-ttu-id="fd7c4-221">또한 GridView s 스마트 태그에서 정렬 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-221">Also, check the Enable Sorting checkbox from the GridView s smart tag.</span></span>

<span data-ttu-id="fd7c4-222">이러한 수정 후 GridView와 ObjectDataSource의 선언 태그는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-222">After these modifications, the GridView and ObjectDataSource s declarative markup should look like the following:</span></span>

[!code-aspx[Main](adding-additional-datatable-columns-cs/samples/sample3.aspx)]

<span data-ttu-id="fd7c4-223">그림 11에서는 브라우저를 통해 방문할 때이 페이지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-223">Figure 11 shows this page when visited through a browser.</span></span> <span data-ttu-id="fd7c4-224">처음에는 제품이 각 제품에 적절 한 `PriceQuartile` 값을 할당 하 여 가격을 기준으로 내림차순으로 정렬 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-224">Note that, initially, the products are ordered by their price in descending order with each product assigned an appropriate `PriceQuartile` value.</span></span> <span data-ttu-id="fd7c4-225">물론 가격과 관련 하 여 제품 순위를 반영 하는 가격 사분 열 값을 사용 하 여 다른 조건을 기준으로이 데이터를 정렬할 수 있습니다 (그림 12 참조).</span><span class="sxs-lookup"><span data-stu-id="fd7c4-225">Of course this data can be sorted by other criteria with the Price Quartile column value still reflecting the product s ranking with respect to price (see Figure 12).</span></span>

<span data-ttu-id="fd7c4-226">[제품 가격에 따라 주문 하는 ![](adding-additional-datatable-columns-cs/_static/image30.png)](adding-additional-datatable-columns-cs/_static/image29.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-226">[![The Products are Ordered by their Prices](adding-additional-datatable-columns-cs/_static/image30.png)](adding-additional-datatable-columns-cs/_static/image29.png)</span></span>

<span data-ttu-id="fd7c4-227">**그림 11**: 제품이 가격을 기준으로 정렬 됨 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image31.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-227">**Figure 11**: The Products are Ordered by their Prices ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image31.png))</span></span>

<span data-ttu-id="fd7c4-228">[제품 이름을 기준으로 정렬 된 ![](adding-additional-datatable-columns-cs/_static/image33.png)](adding-additional-datatable-columns-cs/_static/image32.png)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-228">[![The Products are Ordered by their Names](adding-additional-datatable-columns-cs/_static/image33.png)](adding-additional-datatable-columns-cs/_static/image32.png)</span></span>

<span data-ttu-id="fd7c4-229">**그림 12**: 제품 이름을 기준으로 정렬 ([전체 크기 이미지를 보려면 클릭](adding-additional-datatable-columns-cs/_static/image34.png))</span><span class="sxs-lookup"><span data-stu-id="fd7c4-229">**Figure 12**: The Products are Ordered by their Names ([Click to view full-size image](adding-additional-datatable-columns-cs/_static/image34.png))</span></span>

> [!NOTE]
> <span data-ttu-id="fd7c4-230">몇 줄의 코드를 사용 하 여 `PriceQuartile` 값을 기준으로 제품 행을 색으로 지정 하도록 GridView를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-230">With a few lines of code we could augment the GridView so that it colored the product rows based on their `PriceQuartile` value.</span></span> <span data-ttu-id="fd7c4-231">Microsoft는 첫 번째 사분 위 수, 녹색, 연한 노랑 등의 제품을 색으로 색으로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-231">We might color those products in the first quartile a light green, those in the second quartile a light yellow, and so forth.</span></span> <span data-ttu-id="fd7c4-232">잠시 후에이 기능을 추가 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-232">I encourage you to take a moment to add this functionality.</span></span> <span data-ttu-id="fd7c4-233">GridView 서식 지정에 리프레셔가 필요한 경우에는 [데이터에 따라 사용자 지정 서식 지정](../custom-formatting/custom-formatting-based-upon-data-cs.md) 자습서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-233">If you need a refresher on formatting a GridView, consult the [Custom Formatting Based Upon Data](../custom-formatting/custom-formatting-based-upon-data-cs.md) tutorial.</span></span>

## <a name="an-alternative-approach---creating-another-tableadapter"></a><span data-ttu-id="fd7c4-234">대체 방법-다른 TableAdapter 만들기</span><span class="sxs-lookup"><span data-stu-id="fd7c4-234">An Alternative Approach - Creating Another TableAdapter</span></span>

<span data-ttu-id="fd7c4-235">이 자습서에서 살펴본 것 처럼 주 쿼리에서 제공 하는 것 외의 다른 데이터 필드를 반환 하는 TableAdapter에 메서드를 추가 하는 경우 DataTable에 해당 열을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-235">As we saw in this tutorial, when adding a method to a TableAdapter that returns data fields other than those spelled out by the main query, we can add corresponding columns to the DataTable.</span></span> <span data-ttu-id="fd7c4-236">그러나 이러한 방법은 다른 데이터 필드를 반환 하는 TableAdapter의 메서드 수가 적고 해당 대체 데이터 필드가 주 쿼리와 너무 많이 다른 경우에만 제대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-236">Such an approach, however, works well only if there are a small number of methods in the TableAdapter that return different data fields and if those alternate data fields do not vary too much from the main query.</span></span>

<span data-ttu-id="fd7c4-237">DataTable에 열을 추가 하는 대신 다른 데이터 필드를 반환 하는 첫 번째 TableAdapter의 메서드를 포함 하는 데이터 집합에 다른 TableAdapter를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-237">Rather than adding columns to the DataTable, you can instead add another TableAdapter to the DataSet that contains the methods from the first TableAdapter that return different data fields.</span></span> <span data-ttu-id="fd7c4-238">이 자습서에서는 `ProductsDataTable`에 `PriceQuartile` 열을 추가 하는 대신 (`GetProductsWithPriceQuartile` 메서드에서 사용 되는 경우) `Products_SelectWithPriceQuartile` 저장 프로시저를 주 쿼리로 사용한 `ProductsWithPriceQuartileTableAdapter` 이라는 데이터 집합에 TableAdapter를 추가 했을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-238">For this tutorial, rather than add the `PriceQuartile` column to the `ProductsDataTable` (where it is only used by the `GetProductsWithPriceQuartile` method), we could have added an additional TableAdapter to the DataSet named `ProductsWithPriceQuartileTableAdapter` that used the `Products_SelectWithPriceQuartile` stored procedure as its main query.</span></span> <span data-ttu-id="fd7c4-239">ASP.NET를 사용 하 여 제품 정보를 얻는 데 필요한 페이지는 `ProductsTableAdapter`을 계속 사용할 수는 없지만 `ProductsWithPriceQuartileTableAdapter`를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-239">ASP.NET pages that needed to get product information with the price quartile would use the `ProductsWithPriceQuartileTableAdapter`, while those that did not could continue to use the `ProductsTableAdapter`.</span></span>

<span data-ttu-id="fd7c4-240">새 TableAdapter를 추가 하면 Datatable는 untarnished로 유지 되 고 해당 열은 TableAdapter의 메서드에서 반환 된 데이터 필드를 정확 하 게 미러링합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-240">By adding a new TableAdapter, the DataTables remain untarnished and their columns precisely mirror the data fields returned by their TableAdapter s methods.</span></span> <span data-ttu-id="fd7c4-241">그러나 Tableadapter를 추가 하면 반복적인 작업과 기능을 도입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-241">However, additional TableAdapters can introduce repetitive tasks and functionality.</span></span> <span data-ttu-id="fd7c4-242">예를 들어 `PriceQuartile` 열을 표시 하는 이러한 페이지에서 삽입, 업데이트 및 삭제 지원을 제공 해야 하는 경우 `ProductsWithPriceQuartileTableAdapter` `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성이 제대로 구성 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-242">For example, if those ASP.NET pages that displayed the `PriceQuartile` column also needed to provide insert, update, and delete support, the `ProductsWithPriceQuartileTableAdapter` would need to have its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties properly configured.</span></span> <span data-ttu-id="fd7c4-243">이러한 속성은 `ProductsTableAdapter`를 미러링 하지만이 구성에서는 추가 단계를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-243">While these properties would mirror the `ProductsTableAdapter` s, this configuration introduces an extra step.</span></span> <span data-ttu-id="fd7c4-244">또한 `ProductsTableAdapter` 및 `ProductsWithPriceQuartileTableAdapter` 클래스를 통해 데이터베이스에 제품을 업데이트, 삭제 또는 추가 하는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-244">Moreover, there are now two ways to update, delete, or add a product to the database - through the `ProductsTableAdapter` and `ProductsWithPriceQuartileTableAdapter` classes.</span></span>

<span data-ttu-id="fd7c4-245">이 자습서에 대 한 다운로드에는이 대체 방법을 보여 주는 `NorthwindWithSprocs` 데이터 집합의 `ProductsWithPriceQuartileTableAdapter` 클래스가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-245">The download for this tutorial includes a `ProductsWithPriceQuartileTableAdapter` class in the `NorthwindWithSprocs` DataSet that illustrates this alternative approach.</span></span>

## <a name="summary"></a><span data-ttu-id="fd7c4-246">요약</span><span class="sxs-lookup"><span data-stu-id="fd7c4-246">Summary</span></span>

<span data-ttu-id="fd7c4-247">대부분의 시나리오에서 TableAdapter의 모든 메서드는 동일한 데이터 필드 집합을 반환 하지만 특정 메서드나 두 가지에서 추가 필드를 반환 해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-247">In most scenarios, all of the methods in a TableAdapter will return the same set of data fields, but there are times when a particular method or two may need to return an additional field.</span></span> <span data-ttu-id="fd7c4-248">예를 들어 [세부 정보를 포함 하는 마스터 레코드의 글머리 기호 목록을 사용 하는 마스터/세부 정보 DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) 자습서에서는 기본 쿼리 데이터 필드 외에 각 범주와 관련 된 제품 수를 보고 하는 `NumberOfProducts` 필드를 반환 하는 메서드를 `CategoriesTableAdapter`에 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-248">For example, in the [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) tutorial we added a method to the `CategoriesTableAdapter` that, in addition to the main query s data fields, returned a `NumberOfProducts` field that reported the number of products associated with each category.</span></span> <span data-ttu-id="fd7c4-249">이 자습서에서는 주 쿼리 데이터 필드 외에 `PriceQuartile` 필드를 반환 하는 `ProductsTableAdapter`에서 메서드를 추가 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-249">In this tutorial we looked at adding a method in the `ProductsTableAdapter` that returned a `PriceQuartile` field in addition to the main query s data fields.</span></span> <span data-ttu-id="fd7c4-250">TableAdapter의 메서드에서 반환 된 추가 데이터 필드를 캡처하려면 해당 열을 DataTable에 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-250">To capture additional data fields returned by the TableAdapter s methods we need to add corresponding columns to the DataTable.</span></span>

<span data-ttu-id="fd7c4-251">DataTable에 열을 수동으로 추가 하려면 TableAdapter에서 저장 프로시저를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-251">If you plan on manually adding columns to the DataTable, it is recommended that the TableAdapter use stored procedures.</span></span> <span data-ttu-id="fd7c4-252">Tableadapter에서 임시 SQL 문을 사용 하는 경우 TableAdapter 구성 마법사가 실행 될 때마다 모든 메서드 데이터 필드 목록이 주 쿼리에서 반환한 데이터 필드로 되돌려집니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-252">If the TableAdapter uses ad-hoc SQL statements, any time the TableAdapter Configuration wizard is run all of the methods data field lists revert to the data fields returned by the main query.</span></span> <span data-ttu-id="fd7c4-253">이 문제는 저장 프로시저로 확장 되지 않으므로이 자습서에서 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-253">This problem does not extend to stored procedures, which is why they are recommended and were used in this tutorial.</span></span>

<span data-ttu-id="fd7c4-254">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="fd7c4-254">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="fd7c4-255">저자 정보</span><span class="sxs-lookup"><span data-stu-id="fd7c4-255">About the Author</span></span>

<span data-ttu-id="fd7c4-256">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-256">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="fd7c4-257">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-257">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="fd7c4-258">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-258">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="fd7c4-259">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-259">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="fd7c4-260">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-260">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="fd7c4-261">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-261">Special Thanks To</span></span>

<span data-ttu-id="fd7c4-262">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-262">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="fd7c4-263">이 자습서의 리드 검토자는 Randy Schmidt, Jacky Goor, Bernadette Leigh 및 Hilton Gid Esenow 였습니다.</span><span class="sxs-lookup"><span data-stu-id="fd7c4-263">Lead reviewers for this tutorial were Randy Schmidt, Jacky Goor, Bernadette Leigh, and Hilton Giesenow.</span></span> <span data-ttu-id="fd7c4-264">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="fd7c4-264">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="fd7c4-265">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-265">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="fd7c4-266">[이전](updating-the-tableadapter-to-use-joins-cs.md)
> [다음](working-with-computed-columns-cs.md)</span><span class="sxs-lookup"><span data-stu-id="fd7c4-266">[Previous](updating-the-tableadapter-to-use-joins-cs.md)
[Next](working-with-computed-columns-cs.md)</span></span>
