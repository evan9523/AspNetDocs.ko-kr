---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-vb
title: 조인을 사용 하도록 TableAdapter 업데이트 (VB) | Microsoft Docs
author: rick-anderson
description: 데이터베이스로 작업 하는 경우 여러 테이블에 분산 된 데이터를 요청 하는 것이 일반적입니다. 서로 다른 두 테이블에서 데이터를 검색 하려면 다음 중 하나를 사용할 수 있습니다.
ms.author: riande
ms.date: 07/18/2007
ms.assetid: e624a3e0-061b-4efc-8b0e-5877f9ff6714
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-vb
msc.type: authoredcontent
ms.openlocfilehash: 5c94baa99b126cdd24d69afc3d02bfe8b069419b
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78427529"
---
# <a name="updating-the-tableadapter-to-use-joins-vb"></a><span data-ttu-id="aa473-104">JOIN을 사용하도록 TableAdapter 업데이트(VB)</span><span class="sxs-lookup"><span data-stu-id="aa473-104">Updating the TableAdapter to Use JOINs (VB)</span></span>

<span data-ttu-id="aa473-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="aa473-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="aa473-106">[코드 다운로드](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_VB.zip) 또는 [PDF 다운로드](updating-the-tableadapter-to-use-joins-vb/_static/datatutorial69vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="aa473-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_VB.zip) or [Download PDF](updating-the-tableadapter-to-use-joins-vb/_static/datatutorial69vb1.pdf)</span></span>

> <span data-ttu-id="aa473-107">데이터베이스로 작업 하는 경우 여러 테이블에 분산 된 데이터를 요청 하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-107">When working with a database it is common to request data that is spread across multiple tables.</span></span> <span data-ttu-id="aa473-108">서로 다른 두 테이블에서 데이터를 검색 하려면 상관 하위 쿼리 또는 조인 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-108">To retrieve data from two different tables we can use either a correlated subquery or a JOIN operation.</span></span> <span data-ttu-id="aa473-109">이 자습서에서는 기본 쿼리에 조인을 포함 하는 TableAdapter를 만드는 방법을 확인 하기 전에 상호 관련 된 하위 쿼리 및 조인 구문을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-109">In this tutorial we compare correlated subqueries and the JOIN syntax before looking at how to create a TableAdapter that includes a JOIN in its main query.</span></span>

## <a name="introduction"></a><span data-ttu-id="aa473-110">소개</span><span class="sxs-lookup"><span data-stu-id="aa473-110">Introduction</span></span>

<span data-ttu-id="aa473-111">관계형 데이터베이스를 사용 하는 데 관심이 있는 데이터가 여러 테이블에 분산 되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-111">With relational databases the data we are interested in working with is often spread across multiple tables.</span></span> <span data-ttu-id="aa473-112">예를 들어 제품 정보를 표시 하는 경우 각 제품의 해당 범주와 공급 업체 이름을 나열 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-112">For example, when displaying product information we likely want to list each product s corresponding category and supplier s names.</span></span> <span data-ttu-id="aa473-113">`Products` 테이블에는 `CategoryID` 및 `SupplierID` 값이 있지만 실제 범주 및 공급자 이름은 각각 `Categories` 및 `Suppliers` 테이블에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-113">The `Products` table has `CategoryID` and `SupplierID` values, but the actual category and supplier names are in the `Categories` and `Suppliers` tables, respectively.</span></span>

<span data-ttu-id="aa473-114">관련 된 다른 테이블에서 정보를 검색 하기 위해 상호 관련 된 *하위 쿼리* 또는 `JOIN`*s*를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-114">To retrieve information from another, related table, we can either use *correlated subqueries* or `JOIN`*s*.</span></span> <span data-ttu-id="aa473-115">상관 하위 쿼리는 외부 쿼리의 열을 참조 하는 중첩 된 `SELECT` 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-115">A correlated subquery is a nested `SELECT` query that references columns in the outer query.</span></span> <span data-ttu-id="aa473-116">예를 들어 [데이터 액세스 계층 만들기](../introduction/creating-a-data-access-layer-vb.md) 자습서에서는 `ProductsTableAdapter` 주 쿼리에서 두 개의 상호 관련 된 하위 쿼리를 사용 하 여 각 제품에 대 한 범주 및 공급자 이름을 반환 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-116">For example, in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-vb.md) tutorial we used two correlated subqueries in the `ProductsTableAdapter` s main query to return the category and supplier names for each product.</span></span> <span data-ttu-id="aa473-117">`JOIN`는 서로 다른 두 테이블의 관련 행을 병합 하는 SQL 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-117">A `JOIN` is a SQL construct that merges related rows from two different tables.</span></span> <span data-ttu-id="aa473-118">[SqlDataSource 컨트롤을 사용 하 여 데이터 쿼리](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-vb.md) 자습서에서 `JOIN`를 사용 하 여 각 제품과 함께 범주 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-118">We used a `JOIN` in the [Querying Data with the SqlDataSource Control](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-vb.md) tutorial to display category information alongside each product.</span></span>

<span data-ttu-id="aa473-119">Tableadapter와 `JOIN` s를 사용 하는 것의 이유는 TableAdapter s 마법사의 제한으로 인해 해당 `INSERT`, `UPDATE`및 `DELETE` 문을 자동으로 생성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-119">The reason we have abstained from using `JOIN` s with the TableAdapters is because of limitations in the TableAdapter s wizard to auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span> <span data-ttu-id="aa473-120">구체적으로 말하면 TableAdapter s 주 쿼리에 `JOIN` s가 포함 되어 있으면 TableAdapter는 `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성에 대해 임시 SQL 문이나 저장 프로시저를 자동으로 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-120">More specifically, if the TableAdapter s main query contains any `JOIN` s, the TableAdapter cannot auto-create the ad-hoc SQL statements or stored procedures for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span>

<span data-ttu-id="aa473-121">이 자습서에서는 기본 쿼리에 `JOIN`를 포함 하는 TableAdapter를 만드는 방법을 살펴보기 전에 상호 관련 된 하위 쿼리 및 `JOIN` s를 간략하게 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-121">In this tutorial we will briefly compare and contrast correlated subqueries and `JOIN` s before exploring how to create a TableAdapter that includes `JOIN` s in its main query.</span></span>

## <a name="comparing-and-contrasting-correlated-subqueries-andjoin-s"></a><span data-ttu-id="aa473-122">상관 관계 하위 쿼리 및`JOIN` s 비교 및 대조</span><span class="sxs-lookup"><span data-stu-id="aa473-122">Comparing and Contrasting Correlated Subqueries and`JOIN` s</span></span>

<span data-ttu-id="aa473-123">`Northwind` 데이터 집합의 첫 번째 자습서에서 만든 `ProductsTableAdapter`는 상호 관련 된 하위 쿼리를 사용 하 여 각 제품의 해당 범주와 공급자 이름을 다시 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-123">Recall that the `ProductsTableAdapter` created in the first tutorial in the `Northwind` DataSet uses correlated subqueries to bring back each product s corresponding category and supplier name.</span></span> <span data-ttu-id="aa473-124">`ProductsTableAdapter` s 주 쿼리는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-124">The `ProductsTableAdapter` s main query is shown below.</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample1.sql)]

<span data-ttu-id="aa473-125">두 개의 상호 관련 된 하위 쿼리 `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)`와 `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)`는 외부 `SELECT` statement의 열 목록에 추가 열로 제품별 단일 값을 반환 하는 `SELECT` 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-125">The two correlated subqueries - `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` and `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` - are `SELECT` queries that return a single value per product as an additional column in the outer `SELECT` statement s column list.</span></span>

<span data-ttu-id="aa473-126">또는 각 제품의 공급 업체와 범주 이름을 반환 하는 데 `JOIN`를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-126">Alternatively, a `JOIN` can be used to return each product s supplier and category name.</span></span> <span data-ttu-id="aa473-127">다음 쿼리는 위와 같은 출력을 반환 하지만 하위 쿼리 대신 `JOIN` s를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-127">The following query returns the same output as the above one, but uses `JOIN` s in place of subqueries:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample2.sql)]

<span data-ttu-id="aa473-128">`JOIN`는 특정 조건에 따라 한 테이블의 레코드를 다른 테이블의 레코드와 병합 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-128">A `JOIN` merges the records from one table with records from another table based on some criteria.</span></span> <span data-ttu-id="aa473-129">예를 들어 위의 쿼리에서 `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID`은 각 제품 레코드를 `CategoryID` 값이 제품 `CategoryID` 값과 일치 하는 범주 레코드와 병합 하도록 SQL Server에 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-129">In the above query, for example, the `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` instructs SQL Server to merge each product record with the category record whose `CategoryID` value matches the product s `CategoryID` value.</span></span> <span data-ttu-id="aa473-130">병합 된 결과를 사용 하면 각 제품에 해당 하는 범주 필드를 사용할 수 있습니다 (예: `CategoryName`).</span><span class="sxs-lookup"><span data-stu-id="aa473-130">The merged result allows us to work with the corresponding category fields for each product (such as `CategoryName`).</span></span>

> [!NOTE]
> <span data-ttu-id="aa473-131">`JOIN`은 관계형 데이터베이스에서 데이터를 쿼리할 때 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-131">`JOIN` s are commonly used when querying data from relational databases.</span></span> <span data-ttu-id="aa473-132">`JOIN` 구문이 처음 이거나 해당 사용에 대해 약간의 작업을 수행 해야 하는 경우 [W3 학교](http://www.w3schools.com/)에서 [SQL 조인 자습서](http://www.w3schools.com/sql/sql_join.asp) 를 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-132">If you are new to the `JOIN` syntax or need to brush up a bit on its usage, I d recommend the [SQL Join tutorial](http://www.w3schools.com/sql/sql_join.asp) at [W3 Schools](http://www.w3schools.com/).</span></span> <span data-ttu-id="aa473-133">또한 [SQL 온라인 설명서](https://msdn.microsoft.com/library/ms130214.aspx)의 [`JOIN` 기본](https://msdn.microsoft.com/library/ms191517.aspx) 사항 및 [하위 쿼리 기본](https://msdn.microsoft.com/library/ms189575.aspx) 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="aa473-133">Also worth reading are the [`JOIN` Fundamentals](https://msdn.microsoft.com/library/ms191517.aspx) and [Subquery Fundamentals](https://msdn.microsoft.com/library/ms189575.aspx) sections of the [SQL Books Online](https://msdn.microsoft.com/library/ms130214.aspx).</span></span>

<span data-ttu-id="aa473-134">`JOIN` 및 상관 관계가 지정 된 하위 쿼리를 사용 하 여 다른 테이블에서 관련 된 데이터를 검색할 수 있으므로 많은 개발자가 해당 헤드를 사실일 사용할 방법을 궁금할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-134">Since `JOIN` s and correlated subqueries can both be used to retrieve related data from other tables, many developers are left scratching their heads and wondering which approach to use.</span></span> <span data-ttu-id="aa473-135">거의 동일한 작업을 수행 하는 모든 SQL 전문가는 거의 동일한 작업을 수행 했습니다. SQL Server는 거의 동일한 실행 계획을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-135">All of the SQL gurus I ve talked to have said roughly the same thing, that it doesn t really matter performance-wise as SQL Server will produce roughly identical execution plans.</span></span> <span data-ttu-id="aa473-136">그러면 사용자와 팀이 가장 편한 기법을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-136">Their advice, then, is to use the technique that you and your team are most comfortable with.</span></span> <span data-ttu-id="aa473-137">이는 imparting 후에 이러한 전문가가 상관 관계가 지정 된 하위 쿼리를 통해 `JOIN` s의 기본 설정을 즉시 표현 한다는 것을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-137">It merits noting that after imparting this advice these experts immediately express their preference of `JOIN` s over correlated subqueries.</span></span>

<span data-ttu-id="aa473-138">형식화 된 데이터 집합을 사용 하 여 데이터 액세스 계층을 빌드하는 경우에는 하위 쿼리를 사용할 때 도구가 더 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-138">When building a Data Access Layer using Typed DataSets, the tools work better when using subqueries.</span></span> <span data-ttu-id="aa473-139">특히 TableAdapter s 마법사는 주 쿼리에 `JOIN` s가 포함 되어 있지만 상호 관련 된 하위 쿼리가 사용 될 때 이러한 문을 자동으로 생성 하는 경우 해당 `INSERT`, `UPDATE`및 `DELETE` 문을 자동으로 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-139">In particular, the TableAdapter s wizard will not auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements if the main query contains any `JOIN` s, but will auto-generate these statements when correlated subqueries are used.</span></span>

<span data-ttu-id="aa473-140">이 단점을 탐색 하려면 `~/App_Code/DAL` 폴더에 임시 형식의 데이터 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-140">To explore this shortcoming, create a temporary Typed DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="aa473-141">TableAdapter 구성 마법사 중에 임시 SQL 문을 사용 하도록 선택 하 고 다음 `SELECT` 쿼리를 입력 합니다 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="aa473-141">During the TableAdapter Configuration wizard, choose to use ad-hoc SQL statements and enter the following `SELECT` query (see Figure 1):</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample3.sql)]

<span data-ttu-id="aa473-142">[조인을 포함 하는 주 쿼리를 입력 ![](updating-the-tableadapter-to-use-joins-vb/_static/image2.png)](updating-the-tableadapter-to-use-joins-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-142">[![Enter a Main Query that Contains JOINs](updating-the-tableadapter-to-use-joins-vb/_static/image2.png)](updating-the-tableadapter-to-use-joins-vb/_static/image1.png)</span></span>

<span data-ttu-id="aa473-143">**그림 1**: `JOIN` s를 포함 하는 기본 쿼리 입력 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-143">**Figure 1**: Enter a Main Query that Contains `JOIN` s ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image3.png))</span></span>

<span data-ttu-id="aa473-144">기본적으로 TableAdapter는 주 쿼리에 따라 `INSERT`, `UPDATE`및 `DELETE` 문을 자동으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-144">By default, the TableAdapter will automatically create `INSERT`, `UPDATE`, and `DELETE` statements based on the main query.</span></span> <span data-ttu-id="aa473-145">고급 단추를 클릭 하면이 기능을 사용할 수 있는 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-145">If you click the Advanced button you can see that this feature is enabled.</span></span> <span data-ttu-id="aa473-146">이 설정에도 불구 하 고 주 쿼리에 `JOIN`가 포함 되어 있으므로 TableAdapter가 `INSERT`, `UPDATE`및 `DELETE` 문을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-146">Despite this setting, the TableAdapter will not be able to create the `INSERT`, `UPDATE`, and `DELETE` statements because the main query contains a `JOIN`.</span></span>

![조인이 포함 된 기본 쿼리 입력](updating-the-tableadapter-to-use-joins-vb/_static/image4.png)

<span data-ttu-id="aa473-148">**그림 2**: `JOIN` s를 포함 하는 기본 쿼리 입력</span><span class="sxs-lookup"><span data-stu-id="aa473-148">**Figure 2**: Enter a Main Query that Contains `JOIN` s</span></span>

<span data-ttu-id="aa473-149">마침을 클릭하여 마법사를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-149">Click Finish to complete the wizard.</span></span> <span data-ttu-id="aa473-150">이 시점에서 데이터 집합의 디자이너에는 `SELECT` query s 열 목록에 반환 된 각 필드에 대 한 열이 있는 DataTable이 포함 된 단일 TableAdapter가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-150">At this point your DataSet s Designer will include a single TableAdapter with a DataTable with columns for each of the fields returned in the `SELECT` query s column list.</span></span> <span data-ttu-id="aa473-151">여기에는 그림 3에 나와 있는 것 처럼 `CategoryName` 및 `SupplierName`포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-151">This includes the `CategoryName` and `SupplierName`, as Figure 3 shows.</span></span>

![DataTable에는 열 목록에 반환 된 각 필드에 대 한 열이 포함 되어 있습니다.](updating-the-tableadapter-to-use-joins-vb/_static/image5.png)

<span data-ttu-id="aa473-153">**그림 3**: DataTable에는 열 목록에 반환 된 각 필드에 대 한 열이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-153">**Figure 3**: The DataTable Includes a Column for Each Field Returned in the Column List</span></span>

<span data-ttu-id="aa473-154">DataTable에 적절 한 열이 있지만 TableAdapter에는 `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성에 대 한 값이 부족 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-154">While the DataTable has the appropriate columns, the TableAdapter lacks values for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span> <span data-ttu-id="aa473-155">이를 확인 하려면 디자이너에서 TableAdapter를 클릭 한 다음 속성 창로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-155">To confirm this, click on the TableAdapter in the Designer and then go to the Properties window.</span></span> <span data-ttu-id="aa473-156">`InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성이 (없음)로 설정 된 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-156">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are set to (None) .</span></span>

<span data-ttu-id="aa473-157">[InsertCommand, UpdateCommand 및 DeleteCommand 속성을 (없음)으로 설정 ![](updating-the-tableadapter-to-use-joins-vb/_static/image7.png)](updating-the-tableadapter-to-use-joins-vb/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-157">[![The InsertCommand, UpdateCommand, and DeleteCommand Properties are Set to (None)](updating-the-tableadapter-to-use-joins-vb/_static/image7.png)](updating-the-tableadapter-to-use-joins-vb/_static/image6.png)</span></span>

<span data-ttu-id="aa473-158">**그림 4**: `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성이 (없음)로 설정 됨 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-158">**Figure 4**: The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` Properties are Set to (None) ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image8.png))</span></span>

<span data-ttu-id="aa473-159">이 단점을 해결 하기 위해 속성 창를 통해 `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성에 대 한 SQL 문과 매개 변수를 수동으로 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-159">To work around this shortcoming, we can manually provide the SQL statements and parameters for the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties via the Properties window.</span></span> <span data-ttu-id="aa473-160">또는 `JOIN` s를 포함 *하지 않도록* TableAdapter s 주 쿼리를 구성 하 여 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-160">Alternatively, we could start by configuring the TableAdapter s main query to *not* include any `JOIN` s.</span></span> <span data-ttu-id="aa473-161">이렇게 하면 `INSERT`, `UPDATE`및 `DELETE` 문을 자동으로 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-161">This will allow the `INSERT`, `UPDATE`, and `DELETE` statements to be auto-generated for us.</span></span> <span data-ttu-id="aa473-162">마법사를 완료 한 후에는 `JOIN` 구문이 포함 되도록 속성 창에서 TableAdapter s `SelectCommand`를 수동으로 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-162">After completing the wizard, we could then manually update the TableAdapter s `SelectCommand` from the Properties window so that it includes the `JOIN` syntax.</span></span>

<span data-ttu-id="aa473-163">이 방법이 작동 하는 반면, 마법사를 통해 TableAdapter 주 쿼리가 다시 구성 될 때마다 자동 생성 된 `INSERT``UPDATE`및 `DELETE` 문이 다시 만들어지기 때문에 임시 SQL 쿼리를 사용할 때 매우 불안정.</span><span class="sxs-lookup"><span data-stu-id="aa473-163">While this approach works, it is very brittle when using ad-hoc SQL queries because any time the TableAdapter s main query is re-configured through the wizard, the auto-generated `INSERT`, `UPDATE`, and `DELETE` statements are recreated.</span></span> <span data-ttu-id="aa473-164">즉, TableAdapter를 마우스 오른쪽 단추로 클릭 하 고 상황에 맞는 메뉴에서 구성을 선택한 다음 마법사를 다시 완료 하면 나중에 수행 된 모든 사용자 지정 항목이 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-164">That means all of the customizations we later made would be lost if we right-clicked on the TableAdapter, chose Configure from the context menu, and completed the wizard again.</span></span>

<span data-ttu-id="aa473-165">TableAdapter s 자동 생성 `INSERT`, `UPDATE`및 `DELETE` 문의 brittleness는 다행히도 임시 SQL 문으로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-165">The brittleness of the TableAdapter s auto-generated `INSERT`, `UPDATE`, and `DELETE` statements is, fortunately, limited to ad-hoc SQL statements.</span></span> <span data-ttu-id="aa473-166">TableAdapter에서 저장 프로시저를 사용 하는 경우 저장 프로시저를 수정 하지 않아도 `SelectCommand`, `InsertCommand`, `UpdateCommand`또는 `DeleteCommand` 저장 프로시저를 사용자 지정 하 고 TableAdapter 구성 마법사를 다시 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-166">If your TableAdapter uses stored procedures, you can customize the `SelectCommand`, `InsertCommand`, `UpdateCommand`, or `DeleteCommand` stored procedures and re-run the TableAdapter Configuration wizard without having to fear that the stored procedures will be modified.</span></span>

<span data-ttu-id="aa473-167">다음 몇 가지 단계를 수행 하는 경우 처음에는 해당 insert, update 및 delete 저장 프로시저를 자동으로 생성 하도록 `JOIN` s를 생략 하는 주 쿼리를 사용 하는 TableAdapter를 만들게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-167">Over the next several steps we will create a TableAdapter that, initially, uses a main query that omits any `JOIN` s so that the corresponding insert, update, and delete stored procedures will be auto-generated.</span></span> <span data-ttu-id="aa473-168">그런 다음 관련 테이블에서 추가 열을 반환 하는 `JOIN`을 사용 하도록 `SelectCommand`를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-168">We will then update the `SelectCommand` so that uses a `JOIN` that returns additional columns from related tables.</span></span> <span data-ttu-id="aa473-169">마지막으로, 해당 비즈니스 논리 계층 클래스를 만들고 ASP.NET 웹 페이지에서 TableAdapter를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-169">Finally, we'll create a corresponding Business Logic Layer class and demonstrate using the TableAdapter in an ASP.NET web page.</span></span>

## <a name="step-1-creating-the-tableadapter-using-a-simplified-main-query"></a><span data-ttu-id="aa473-170">1 단계: 간소화 된 기본 쿼리를 사용 하 여 TableAdapter 만들기</span><span class="sxs-lookup"><span data-stu-id="aa473-170">Step 1: Creating the TableAdapter Using a Simplified Main Query</span></span>

<span data-ttu-id="aa473-171">이 자습서에서는 `NorthwindWithSprocs` 데이터 집합의 `Employees` 테이블에 대해 TableAdapter 및 강력한 형식의 DataTable을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-171">For this tutorial we will add a TableAdapter and strongly-typed DataTable for the `Employees` table in the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="aa473-172">`Employees` 테이블에는 직원의 관리자 `EmployeeID` 지정 하는 `ReportsTo` 필드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-172">The `Employees` table contains a `ReportsTo` field that specified the `EmployeeID` of the employee s manager.</span></span> <span data-ttu-id="aa473-173">예를 들어 직원 황 수는 `ReportTo` 값이 5이 고,이는 선하라의 `EmployeeID`입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-173">For example, employee Anne Dodsworth has a `ReportTo` value of 5, which is the `EmployeeID` of Steven Buchanan.</span></span> <span data-ttu-id="aa473-174">따라서 황 병은 관리자에 게 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-174">Consequently, Anne reports to Steven, her manager.</span></span> <span data-ttu-id="aa473-175">각 직원의 `ReportsTo` 값을 보고 하는 것과 함께 해당 관리자의 이름을 검색할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-175">Along with reporting each employee s `ReportsTo` value, we might also want to retrieve the name of their manager.</span></span> <span data-ttu-id="aa473-176">`JOIN`를 사용 하 여이를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-176">This can be accomplished using a `JOIN`.</span></span> <span data-ttu-id="aa473-177">그러나 처음 TableAdapter를 만들 때 `JOIN`를 사용 하면 마법사가 해당 삽입, 업데이트 및 삭제 기능을 자동으로 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-177">But using a `JOIN` when initially creating the TableAdapter precludes the wizard from automatically generating the corresponding insert, update, and delete capabilities.</span></span> <span data-ttu-id="aa473-178">따라서 주 쿼리는 `JOIN` s를 포함 하지 않는 TableAdapter를 만들어 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-178">Therefore, we will start by creating a TableAdapter whose main query does not contain any `JOIN` s.</span></span> <span data-ttu-id="aa473-179">그런 다음 2 단계에서 주 쿼리 저장 프로시저를 업데이트 하 여 `JOIN`를 통해 관리자 이름을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-179">Then, in Step 2, we will update the main query stored procedure to retrieve the manager s name via a `JOIN`.</span></span>

<span data-ttu-id="aa473-180">먼저 `~/App_Code/DAL` 폴더에서 `NorthwindWithSprocs` 데이터 집합을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-180">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="aa473-181">디자이너를 마우스 오른쪽 단추로 클릭 하 고, 상황에 맞는 메뉴에서 추가 옵션을 선택 하 고, TableAdapter 메뉴 항목을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-181">Right-click on the Designer, select the Add option from the context menu, and pick the TableAdapter menu item.</span></span> <span data-ttu-id="aa473-182">이렇게 하면 TableAdapter 구성 마법사가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-182">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="aa473-183">그림 5와 같이 마법사에서 새 저장 프로시저를 만들고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-183">As Figure 5 depicts, have the wizard create new stored procedures and click Next.</span></span> <span data-ttu-id="aa473-184">TableAdapter s 마법사에서 새 저장 프로시저를 만드는 방법에 대 한 자세한 내용은 [형식화 된 데이터 집합의 tableadapter 자습서에 대 한 새 저장 프로시저 만들기](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="aa473-184">For a refresher on creating new stored procedures from the TableAdapter s wizard, consult the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span>

<span data-ttu-id="aa473-185">[![새 저장 프로시저 만들기 옵션을 선택 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image10.png)](updating-the-tableadapter-to-use-joins-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-185">[![Select the Create new stored procedures Option](updating-the-tableadapter-to-use-joins-vb/_static/image10.png)](updating-the-tableadapter-to-use-joins-vb/_static/image9.png)</span></span>

<span data-ttu-id="aa473-186">**그림 5**: 새 저장 프로시저 만들기 옵션 선택 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-186">**Figure 5**: Select the Create new stored procedures Option ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image11.png))</span></span>

<span data-ttu-id="aa473-187">TableAdapter 주 쿼리에 대해 다음 `SELECT` 문을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-187">Use the following `SELECT` statement for the TableAdapter s main query:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample4.sql)]

<span data-ttu-id="aa473-188">이 쿼리에는 `JOIN` s가 포함 되어 있지 않으므로 TableAdapter 마법사는 주 쿼리를 실행 하는 저장 프로시저 뿐만 아니라 해당 `INSERT`, `UPDATE`및 `DELETE` 문을 사용 하 여 저장 프로시저를 자동으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-188">Since this query does not include any `JOIN` s, the TableAdapter wizard will automatically create stored procedures with corresponding `INSERT`, `UPDATE`, and `DELETE` statements, as well as a stored procedure for executing the main query.</span></span>

<span data-ttu-id="aa473-189">다음 단계를 통해 TableAdapter의 저장 프로시저에 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-189">The following step allows us to name the TableAdapter s stored procedures.</span></span> <span data-ttu-id="aa473-190">그림 6에 표시 된 것 처럼 이름 `Employees_Select`, `Employees_Insert`, `Employees_Update`및 `Employees_Delete`를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-190">Use the names `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`, as shown in Figure 6.</span></span>

<span data-ttu-id="aa473-191">[TableAdapter 저장 프로시저의 이름을 ![합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image13.png)](updating-the-tableadapter-to-use-joins-vb/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-191">[![Name the TableAdapter s Stored Procedures](updating-the-tableadapter-to-use-joins-vb/_static/image13.png)](updating-the-tableadapter-to-use-joins-vb/_static/image12.png)</span></span>

<span data-ttu-id="aa473-192">**그림 6**: TableAdapter의 저장 프로시저 이름 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-192">**Figure 6**: Name the TableAdapter s Stored Procedures ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image14.png))</span></span>

<span data-ttu-id="aa473-193">마지막 단계에서는 TableAdapter의 메서드 이름을 입력 하 라는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-193">The final step prompts us to name the TableAdapter s methods.</span></span> <span data-ttu-id="aa473-194">`Fill` 및 `GetEmployees`를 메서드 이름으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-194">Use `Fill` and `GetEmployees` as the method names.</span></span> <span data-ttu-id="aa473-195">또한 데이터베이스에 직접 업데이트를 보내는 메서드 만들기 (GenerateDBDirectMethods) 확인란을 선택 된 상태로 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-195">Also be sure to leave the Create methods to send updates directly to the database (GenerateDBDirectMethods) checkbox checked.</span></span>

<span data-ttu-id="aa473-196">[![TableAdapter 메서드 이름 채우기 및 GetEmployees](updating-the-tableadapter-to-use-joins-vb/_static/image16.png)](updating-the-tableadapter-to-use-joins-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-196">[![Name the TableAdapter s Methods Fill and GetEmployees](updating-the-tableadapter-to-use-joins-vb/_static/image16.png)](updating-the-tableadapter-to-use-joins-vb/_static/image15.png)</span></span>

<span data-ttu-id="aa473-197">**그림 7**: TableAdapter의 메서드 이름 `Fill` 및 `GetEmployees` ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-197">**Figure 7**: Name the TableAdapter s Methods `Fill` and `GetEmployees` ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image17.png))</span></span>

<span data-ttu-id="aa473-198">마법사를 완료 한 후에는 데이터베이스의 저장 프로시저를 잠시 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-198">After completing the wizard, take a moment to examine the stored procedures in the database.</span></span> <span data-ttu-id="aa473-199">`Employees_Select`, `Employees_Insert`, `Employees_Update`및 `Employees_Delete`의 네 가지 새 항목이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-199">You should see four new ones: `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`.</span></span> <span data-ttu-id="aa473-200">그런 다음 `EmployeesDataTable`를 검사 하 고 막 만든 `EmployeesTableAdapter` 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-200">Next, inspect the `EmployeesDataTable` and `EmployeesTableAdapter` just created.</span></span> <span data-ttu-id="aa473-201">DataTable에는 주 쿼리에서 반환 하는 각 필드에 대 한 열이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-201">The DataTable contains a column for each field returned by the main query.</span></span> <span data-ttu-id="aa473-202">TableAdapter를 클릭 한 다음 속성 창로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-202">Click on the TableAdapter and then go to the Properties window.</span></span> <span data-ttu-id="aa473-203">`InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성이 해당 저장 프로시저를 호출 하도록 올바르게 구성 된 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-203">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are correctly configured to call the corresponding stored procedures.</span></span>

<span data-ttu-id="aa473-204">[![TableAdapter에 삽입, 업데이트 및 삭제 기능이 포함 되어 있습니다.](updating-the-tableadapter-to-use-joins-vb/_static/image19.png)](updating-the-tableadapter-to-use-joins-vb/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-204">[![The TableAdapter Includes Insert, Update, and Delete Capabilities](updating-the-tableadapter-to-use-joins-vb/_static/image19.png)](updating-the-tableadapter-to-use-joins-vb/_static/image18.png)</span></span>

<span data-ttu-id="aa473-205">**그림 8**: TableAdapter는 삽입, 업데이트 및 삭제 기능을 포함 합니다 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image20.png)).</span><span class="sxs-lookup"><span data-stu-id="aa473-205">**Figure 8**: The TableAdapter Includes Insert, Update, and Delete Capabilities ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image20.png))</span></span>

<span data-ttu-id="aa473-206">Insert, update 및 delete 저장 프로시저가 자동으로 생성 되 고 `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성이 올바르게 구성 되어 있으면 `SelectCommand`의 저장 프로시저를 사용자 지정 하 여 각 직원의 관리자에 대 한 추가 정보를 반환할 준비가 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-206">With the insert, update, and delete stored procedures automatically created and the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties correctly configured, we are ready to customize the `SelectCommand` s stored procedure to return additional information about each employee s manager.</span></span> <span data-ttu-id="aa473-207">특히 `JOIN`를 사용 하 여 `Employees_Select` 저장 프로시저를 업데이트 하 고 관리자 `FirstName` 및 `LastName` 값을 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-207">Specifically, we need to update the `Employees_Select` stored procedure to use a `JOIN` and return the manager s `FirstName` and `LastName` values.</span></span> <span data-ttu-id="aa473-208">저장 프로시저를 업데이트 한 후에는 이러한 추가 열을 포함 하도록 DataTable을 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-208">After the stored procedure has been updated, we will need to update the DataTable so that it includes these additional columns.</span></span> <span data-ttu-id="aa473-209">2 단계와 3 단계에서 이러한 두 가지 작업을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-209">We'll tackle these two tasks in Steps 2 and 3.</span></span>

## <a name="step-2-customizing-the-stored-procedure-to-include-ajoin"></a><span data-ttu-id="aa473-210">2 단계: 저장 프로시저를 사용자 지정 하 여`JOIN` 포함</span><span class="sxs-lookup"><span data-stu-id="aa473-210">Step 2: Customizing the Stored Procedure to Include a`JOIN`</span></span>

<span data-ttu-id="aa473-211">먼저 서버 탐색기로 이동 하 여 Northwind 데이터베이스의 저장 프로시저 폴더로 드릴 다운 하 고 `Employees_Select` 저장 프로시저를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-211">Start by going to the Server Explorer, drilling down into the Northwind database s Stored Procedures folder, and opening the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="aa473-212">이 저장 프로시저가 표시 되지 않는 경우 저장 프로시저 폴더를 마우스 오른쪽 단추로 클릭 하 고 새로 고침을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-212">If you do not see this stored procedure, right-click on the Stored Procedures folder and choose Refresh.</span></span> <span data-ttu-id="aa473-213">`LEFT JOIN`를 사용 하 여 관리자의 이름과 성을 반환 하도록 저장 프로시저를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-213">Update the stored procedure so that it uses a `LEFT JOIN` to return the manager s first and last name:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample5.sql)]

<span data-ttu-id="aa473-214">`SELECT` 문을 업데이트 한 후 파일 메뉴로 이동 하 고 `Employees_Select`저장을 선택 하 여 변경 내용을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-214">After updating the `SELECT` statement, save the changes by going to the File menu and choosing Save `Employees_Select`.</span></span> <span data-ttu-id="aa473-215">또는 도구 모음에서 저장 아이콘을 클릭 하거나 Ctrl + S를 누를 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-215">Alternatively, you can click the Save icon in the toolbar or hit Ctrl+S.</span></span> <span data-ttu-id="aa473-216">변경 내용을 저장 한 후 서버 탐색기에서 `Employees_Select` 저장 프로시저를 마우스 오른쪽 단추로 클릭 하 고 실행을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-216">After saving your changes, right-click on the `Employees_Select` stored procedure in the Server Explorer and choose Execute.</span></span> <span data-ttu-id="aa473-217">저장 프로시저를 실행 하 고 출력 창에 결과를 표시 합니다 (그림 9 참조).</span><span class="sxs-lookup"><span data-stu-id="aa473-217">This will run the stored procedure and show its results in the Output window (see Figure 9).</span></span>

<span data-ttu-id="aa473-218">[저장 프로시저 결과가 ![표시 됩니다 출력 창](updating-the-tableadapter-to-use-joins-vb/_static/image22.png)](updating-the-tableadapter-to-use-joins-vb/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-218">[![The Stored Procedures Results are Displayed in the Output Window](updating-the-tableadapter-to-use-joins-vb/_static/image22.png)](updating-the-tableadapter-to-use-joins-vb/_static/image21.png)</span></span>

<span data-ttu-id="aa473-219">**그림 9**: 저장 프로시저 결과가 출력 창 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image23.png)).</span><span class="sxs-lookup"><span data-stu-id="aa473-219">**Figure 9**: The Stored Procedures Results are Displayed in the Output Window ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image23.png))</span></span>

## <a name="step-3-updating-the-datatable-s-columns"></a><span data-ttu-id="aa473-220">3 단계: DataTable의 열 업데이트</span><span class="sxs-lookup"><span data-stu-id="aa473-220">Step 3: Updating the DataTable s Columns</span></span>

<span data-ttu-id="aa473-221">이 시점에서 `Employees_Select` 저장 프로시저는 `ManagerFirstName` 및 `ManagerLastName` 값을 반환 하지만 `EmployeesDataTable`에는 이러한 열이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-221">At this point, the `Employees_Select` stored procedure returns `ManagerFirstName` and `ManagerLastName` values, but the `EmployeesDataTable` is missing these columns.</span></span> <span data-ttu-id="aa473-222">이러한 누락 열은 다음 두 가지 방법 중 하나로 DataTable에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-222">These missing columns can be added to the DataTable in one of two ways:</span></span>

- <span data-ttu-id="aa473-223">**수동으로** -데이터 집합 디자이너에서 DataTable을 마우스 오른쪽 단추로 클릭 하 고 추가 메뉴에서 열을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-223">**Manually** - right-click on the DataTable in the DataSet Designer and, from the Add menu, choose Column.</span></span> <span data-ttu-id="aa473-224">그런 다음 열의 이름을 지정할 수 있으며 그에 따라 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-224">You can then name the column and set its properties accordingly.</span></span>
- <span data-ttu-id="aa473-225">**자동** -TableAdapter 구성 마법사는 `SelectCommand` 저장 프로시저에 의해 반환 된 필드를 반영 하도록 DataTable의 열을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-225">**Automatically** - the TableAdapter Configuration wizard will update the DataTable s columns to reflect the fields returned by the `SelectCommand` stored procedure.</span></span> <span data-ttu-id="aa473-226">임시 SQL 문을 사용 하는 경우 `SelectCommand`가 `JOIN`를 포함 하므로 마법사는 `InsertCommand`, `UpdateCommand`및 `DeleteCommand` 속성도 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-226">When using ad-hoc SQL statements, the wizard will also remove the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties since the `SelectCommand` now contains a `JOIN`.</span></span> <span data-ttu-id="aa473-227">그러나 저장 프로시저를 사용 하는 경우 이러한 명령 속성은 그대로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-227">But when using stored procedures, these command properties remain intact.</span></span>

<span data-ttu-id="aa473-228">정보 DataList 및 [파일 업로드](../working-with-binary-files/uploading-files-vb.md) [와 함께 마스터 레코드의 글머리 기호 목록을 사용 하 여 마스터/세부](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-vb.md) 정보를 포함 하 여 이전 자습서에서 DataTable 열을 수동으로 추가 하는 방법에 대해서는 다음 자습서에서이 프로세스를 다시 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-228">We have explored manually adding DataTable columns in previous tutorials, including [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-vb.md) and [Uploading Files](../working-with-binary-files/uploading-files-vb.md), and we will look at this process again in more detail in our next tutorial.</span></span> <span data-ttu-id="aa473-229">그러나이 자습서에서는 TableAdapter 구성 마법사를 통해 자동 접근 방법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-229">For this tutorial, however, let s use the automatic approach via the TableAdapter Configuration wizard.</span></span>

<span data-ttu-id="aa473-230">`EmployeesTableAdapter`를 마우스 오른쪽 단추로 클릭 하 고 상황에 맞는 메뉴에서 구성을 선택 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-230">Start by right-clicking on the `EmployeesTableAdapter` and selecting Configure from the context menu.</span></span> <span data-ttu-id="aa473-231">그러면 선택, 삽입, 업데이트 및 삭제에 사용 되는 저장 프로시저와 함께 반환 값 및 매개 변수 (있는 경우)를 나열 하는 TableAdapter 구성 마법사가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-231">This brings up the TableAdapter Configuration wizard, which lists the stored procedures used for selecting, inserting, updating, and deleting, along with their return values and parameters (if any).</span></span> <span data-ttu-id="aa473-232">그림 10에서는이 마법사를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-232">Figure 10 shows this wizard.</span></span> <span data-ttu-id="aa473-233">이제 `Employees_Select` 저장 프로시저가 `ManagerFirstName` 및 `ManagerLastName` 필드를 반환 하는 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-233">Here we can see that the `Employees_Select` stored procedure now returns the `ManagerFirstName` and `ManagerLastName` fields.</span></span>

<span data-ttu-id="aa473-234">[![Employees_Select 저장 프로시저의 업데이트 된 열 목록이 마법사에 표시 됩니다.](updating-the-tableadapter-to-use-joins-vb/_static/image25.png)](updating-the-tableadapter-to-use-joins-vb/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-234">[![The Wizard Shows the Updated Column List for the Employees_Select Stored Procedure](updating-the-tableadapter-to-use-joins-vb/_static/image25.png)](updating-the-tableadapter-to-use-joins-vb/_static/image24.png)</span></span>

<span data-ttu-id="aa473-235">**그림 10**: 마법사에 `Employees_Select` 저장 프로시저에 대 한 업데이트 된 열 목록 표시 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image26.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-235">**Figure 10**: The Wizard Shows the Updated Column List for the `Employees_Select` Stored Procedure ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image26.png))</span></span>

<span data-ttu-id="aa473-236">마침을 클릭 하 여 마법사를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-236">Complete the wizard by clicking Finish.</span></span> <span data-ttu-id="aa473-237">데이터 집합 디자이너로 반환 될 때 `EmployeesDataTable`에 `ManagerFirstName` 및 `ManagerLastName`라는 두 개의 추가 열이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-237">Upon returning to the DataSet Designer, the `EmployeesDataTable` includes two additional columns: `ManagerFirstName` and `ManagerLastName`.</span></span>

<span data-ttu-id="aa473-238">[EmployeesDataTable에 새 열이 두 개 포함 된 ![](updating-the-tableadapter-to-use-joins-vb/_static/image28.png)](updating-the-tableadapter-to-use-joins-vb/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-238">[![The EmployeesDataTable Contains Two New Columns](updating-the-tableadapter-to-use-joins-vb/_static/image28.png)](updating-the-tableadapter-to-use-joins-vb/_static/image27.png)</span></span>

<span data-ttu-id="aa473-239">**그림 11**: `EmployeesDataTable`에 새 열 두 개 포함 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image29.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-239">**Figure 11**: The `EmployeesDataTable` Contains Two New Columns ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image29.png))</span></span>

<span data-ttu-id="aa473-240">업데이트 된 `Employees_Select` 저장 프로시저가 적용 되 고 TableAdapter의 삽입, 업데이트 및 삭제 기능이 여전히 작동 하 고 있음을 보여 주기 위해 사용자가 직원을 보고 삭제할 수 있는 웹 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-240">To illustrate that the updated `Employees_Select` stored procedure is in effect and that the insert, update, and delete capabilities of the TableAdapter are still functional, let s create a web page that allows users to view and delete employees.</span></span> <span data-ttu-id="aa473-241">그러나 이러한 페이지를 만들기 전에 먼저 `NorthwindWithSprocs` 데이터 집합에서 직원을 사용 하기 위해 비즈니스 논리 계층에서 새 클래스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-241">Before we create such a page, however, we need to first create a new class in the Business Logic Layer for working with employees from the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="aa473-242">4 단계에서는 `EmployeesBLLWithSprocs` 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-242">In Step 4, we will create an `EmployeesBLLWithSprocs` class.</span></span> <span data-ttu-id="aa473-243">5 단계에서는 ASP.NET 페이지에서이 클래스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-243">In Step 5, we will use this class from an ASP.NET page.</span></span>

## <a name="step-4-implementing-the-business-logic-layer"></a><span data-ttu-id="aa473-244">4 단계: 비즈니스 논리 계층 구현</span><span class="sxs-lookup"><span data-stu-id="aa473-244">Step 4: Implementing the Business Logic Layer</span></span>

<span data-ttu-id="aa473-245">`EmployeesBLLWithSprocs.vb`이라는 `~/App_Code/BLL` 폴더에 새 클래스 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-245">Create a new class file in the `~/App_Code/BLL` folder named `EmployeesBLLWithSprocs.vb`.</span></span> <span data-ttu-id="aa473-246">이 클래스는 기존 `EmployeesBLL` 클래스의 의미 체계를 모방 합니다 .이 클래스는 새로운 메서드를 제공 하 고 `Northwind` 데이터 집합 대신 `NorthwindWithSprocs` 데이터 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-246">This class mimics the semantics of the existing `EmployeesBLL` class, only this new one provides fewer methods and uses the `NorthwindWithSprocs` DataSet (instead of the `Northwind` DataSet).</span></span> <span data-ttu-id="aa473-247">`EmployeesBLLWithSprocs` 클래스에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-247">Add the following code to the `EmployeesBLLWithSprocs` class.</span></span>

[!code-vb[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample6.vb)]

<span data-ttu-id="aa473-248">`EmployeesBLLWithSprocs` 클래스 `Adapter` 속성은 `NorthwindWithSprocs` 데이터 집합 s `EmployeesTableAdapter`의 인스턴스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-248">The `EmployeesBLLWithSprocs` class s `Adapter` property returns an instance of the `NorthwindWithSprocs` DataSet s `EmployeesTableAdapter`.</span></span> <span data-ttu-id="aa473-249">클래스 `GetEmployees` 및 `DeleteEmployee` 메서드에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-249">This is used by the class s `GetEmployees` and `DeleteEmployee` methods.</span></span> <span data-ttu-id="aa473-250">`GetEmployees` 메서드는 `EmployeesTableAdapter` s 해당 `GetEmployees` 메서드를 호출 합니다 .이 메서드는 `Employees_Select` 저장 프로시저를 호출 하 고 그 결과를 `EmployeeDataTable`에 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-250">The `GetEmployees` method calls the `EmployeesTableAdapter` s corresponding `GetEmployees` method, which invokes the `Employees_Select` stored procedure and populates its results in an `EmployeeDataTable`.</span></span> <span data-ttu-id="aa473-251">`DeleteEmployee` 메서드는 `Employees_Delete` 저장 프로시저를 호출 하는 `EmployeesTableAdapter` s `Delete` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-251">The `DeleteEmployee` method similarly calls the `EmployeesTableAdapter` s `Delete` method, which invokes the `Employees_Delete` stored procedure.</span></span>

## <a name="step-5-working-with-the-data-in-the-presentation-layer"></a><span data-ttu-id="aa473-252">5 단계: 프레젠테이션 계층에서 데이터 작업</span><span class="sxs-lookup"><span data-stu-id="aa473-252">Step 5: Working with the Data in the Presentation Layer</span></span>

<span data-ttu-id="aa473-253">`EmployeesBLLWithSprocs` 클래스가 완료 되 면 ASP.NET 페이지를 통해 직원 데이터 작업을 수행할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-253">With the `EmployeesBLLWithSprocs` class complete, we re ready to work with employee data through an ASP.NET page.</span></span> <span data-ttu-id="aa473-254">`AdvancedDAL` 폴더에서 `JOINs.aspx` 페이지를 열고 GridView를 도구 상자에서 디자이너로 끌어 `ID` 속성을 `Employees`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-254">Open the `JOINs.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Employees`.</span></span> <span data-ttu-id="aa473-255">그런 다음 GridView의 스마트 태그에서 표를 `EmployeesDataSource`이라는 새 ObjectDataSource 컨트롤에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-255">Next, from the GridView s smart tag, bind the grid to a new ObjectDataSource control named `EmployeesDataSource`.</span></span>

<span data-ttu-id="aa473-256">`EmployeesBLLWithSprocs` 클래스를 사용 하도록 ObjectDataSource를 구성 하 고, 선택 및 삭제 탭에서 `GetEmployees` 및 `DeleteEmployee` 메서드가 드롭다운 목록에서 선택 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-256">Configure the ObjectDataSource to use the `EmployeesBLLWithSprocs` class and, from the SELECT and DELETE tabs, ensure that the `GetEmployees` and `DeleteEmployee` methods are selected from the drop-down lists.</span></span> <span data-ttu-id="aa473-257">마침을 클릭 하 여 ObjectDataSource s 구성을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-257">Click Finish to complete the ObjectDataSource s configuration.</span></span>

<span data-ttu-id="aa473-258">[EmployeesBLLWithSprocs 클래스를 사용 하도록 ObjectDataSource 구성 ![](updating-the-tableadapter-to-use-joins-vb/_static/image31.png)](updating-the-tableadapter-to-use-joins-vb/_static/image30.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-258">[![Configure the ObjectDataSource to Use the EmployeesBLLWithSprocs Class](updating-the-tableadapter-to-use-joins-vb/_static/image31.png)](updating-the-tableadapter-to-use-joins-vb/_static/image30.png)</span></span>

<span data-ttu-id="aa473-259">**그림 12**: `EmployeesBLLWithSprocs` 클래스를 사용 하도록 ObjectDataSource 구성 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image32.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-259">**Figure 12**: Configure the ObjectDataSource to Use the `EmployeesBLLWithSprocs` Class ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image32.png))</span></span>

<span data-ttu-id="aa473-260">[ObjectDataSource에 GetEmployees 및 DeleteEmployee 메서드를 사용 ![](updating-the-tableadapter-to-use-joins-vb/_static/image34.png)](updating-the-tableadapter-to-use-joins-vb/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-260">[![Have the ObjectDataSource Use the GetEmployees and DeleteEmployee Methods](updating-the-tableadapter-to-use-joins-vb/_static/image34.png)](updating-the-tableadapter-to-use-joins-vb/_static/image33.png)</span></span>

<span data-ttu-id="aa473-261">**그림 13**: ObjectDataSource에서 `GetEmployees` 및 `DeleteEmployee` 메서드를 사용 하도록 합니다 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image35.png)).</span><span class="sxs-lookup"><span data-stu-id="aa473-261">**Figure 13**: Have the ObjectDataSource Use the `GetEmployees` and `DeleteEmployee` Methods ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image35.png))</span></span>

<span data-ttu-id="aa473-262">Visual Studio는 각 `EmployeesDataTable`의 열에 대해 GridView에 BoundField를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-262">Visual Studio will add a BoundField to the GridView for each of the `EmployeesDataTable` s columns.</span></span> <span data-ttu-id="aa473-263">`Title`, `LastName`, `FirstName`, `ManagerFirstName`및 `ManagerLastName`를 제외 하 고 이러한 모든 BoundFields를 제거 하 고 마지막 4 개의 BoundFields에 대 한 `HeaderText` 속성의 이름을 Last name, First Name, Manager s First Name 및 Manager s Last Name으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-263">Remove all of these BoundFields except for `Title`, `LastName`, `FirstName`, `ManagerFirstName`, and `ManagerLastName` and rename the `HeaderText` properties for the last four BoundFields to Last Name, First Name, Manager s First Name, and Manager s Last Name, respectively.</span></span>

<span data-ttu-id="aa473-264">사용자가이 페이지에서 직원을 삭제할 수 있게 하려면 두 가지를 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-264">To allow users to delete employees from this page we need to do two things.</span></span> <span data-ttu-id="aa473-265">먼저 스마트 태그에서 삭제 사용 옵션을 선택 하 여 삭제 기능을 제공 하도록 GridView에 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-265">First, instruct the GridView to provide deleting capabilities by checking the Enable Deleting option from its smart tag.</span></span> <span data-ttu-id="aa473-266">그런 다음 objectdatasource 마법사 (`original_{0}`)에서 설정 된 값을 기본값 (`{0}`)로 설정 하 여 ObjectDataSource s `OldValuesParameterFormatString` 속성을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-266">Second, change the ObjectDataSource s `OldValuesParameterFormatString` property from the value set by the ObjectDataSource wizard (`original_{0}`) to its default value (`{0}`).</span></span> <span data-ttu-id="aa473-267">이러한 변경을 수행한 후 GridView와 ObjectDataSource의 선언 태그는 다음과 유사 하 게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-267">After making these changes, your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample7.aspx)]

<span data-ttu-id="aa473-268">브라우저를 통해 방문 하 여 페이지를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-268">Test out the page by visiting it through a browser.</span></span> <span data-ttu-id="aa473-269">그림 14와 같이이 페이지에는 각 직원과 자신의 관리자 이름이 표시 됩니다 (있는 경우).</span><span class="sxs-lookup"><span data-stu-id="aa473-269">As Figure 14 shows, the page will list each employee and his or her manager s name (assuming they have one).</span></span>

<span data-ttu-id="aa473-270">[Employees_Select 저장 프로시저의 조인 ![관리자의 이름을 반환 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image37.png)](updating-the-tableadapter-to-use-joins-vb/_static/image36.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-270">[![The JOIN in the Employees_Select Stored Procedure Returns the Manager s Name](updating-the-tableadapter-to-use-joins-vb/_static/image37.png)](updating-the-tableadapter-to-use-joins-vb/_static/image36.png)</span></span>

<span data-ttu-id="aa473-271">**그림 14**: `Employees_Select` 저장 프로시저의 `JOIN`에서 관리자 이름 반환 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image38.png))</span><span class="sxs-lookup"><span data-stu-id="aa473-271">**Figure 14**: The `JOIN` in the `Employees_Select` Stored Procedure Returns the Manager s Name ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image38.png))</span></span>

<span data-ttu-id="aa473-272">삭제 단추를 클릭 하면 `Employees_Delete` 저장 프로시저의 실행으로 완료 되는 삭제 워크플로가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-272">Clicking the Delete button starts the deleting workflow, which culminates in the execution of the `Employees_Delete` stored procedure.</span></span> <span data-ttu-id="aa473-273">그러나 저장 프로시저에서 시도 된 `DELETE` 문은 foreign key 제약 조건 위반으로 인해 실패 합니다 (그림 15 참조).</span><span class="sxs-lookup"><span data-stu-id="aa473-273">However, the attempted `DELETE` statement in the stored procedure fails because of a foreign key constraint violation (see Figure 15).</span></span> <span data-ttu-id="aa473-274">특히 각 직원은 `Orders` 테이블에 하나 이상의 레코드를 포함 하므로 삭제가 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-274">Specifically, each employee has one or more records in the `Orders` table, causing the delete to fail.</span></span>

<span data-ttu-id="aa473-275">[해당 주문이 있는 직원을 삭제 ![Foreign Key 제약 조건 위반이 발생 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image40.png)](updating-the-tableadapter-to-use-joins-vb/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="aa473-275">[![Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation](updating-the-tableadapter-to-use-joins-vb/_static/image40.png)](updating-the-tableadapter-to-use-joins-vb/_static/image39.png)</span></span>

<span data-ttu-id="aa473-276">**그림 15**: 해당 주문이 있는 직원을 삭제 하면 Foreign Key 제약 조건 위반이 발생 합니다 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image41.png)).</span><span class="sxs-lookup"><span data-stu-id="aa473-276">**Figure 15**: Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image41.png))</span></span>

<span data-ttu-id="aa473-277">직원을 삭제할 수 있게 하려면 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-277">To allow an employee to be deleted you could:</span></span>

- <span data-ttu-id="aa473-278">Foreign key 제약 조건을 계단식 삭제로 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-278">Update the foreign key constraint to cascade deletes,</span></span>
- <span data-ttu-id="aa473-279">삭제할 직원의 `Orders` 테이블에서 레코드를 수동으로 삭제 하거나</span><span class="sxs-lookup"><span data-stu-id="aa473-279">Manually delete the records from the `Orders` table for the employee(s) you want to delete, or</span></span>
- <span data-ttu-id="aa473-280">`Employees_Delete` 저장 프로시저를 업데이트 하 여 먼저 `Employees` 레코드를 삭제 하기 전에 `Orders` 테이블에서 관련 레코드를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-280">Update the `Employees_Delete` stored procedure to first delete the related records from the `Orders` table before deleting the `Employees` record.</span></span> <span data-ttu-id="aa473-281">[형식화 된 데이터 집합의 tableadapter 자습서에서 기존 저장 프로시저를 사용 하](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) 는 방법에 대해 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-281">We discussed this technique in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span>

<span data-ttu-id="aa473-282">독자를 위한 연습으로 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-282">I leave this as an exercise for the reader.</span></span>

## <a name="summary"></a><span data-ttu-id="aa473-283">요약</span><span class="sxs-lookup"><span data-stu-id="aa473-283">Summary</span></span>

<span data-ttu-id="aa473-284">관계형 데이터베이스를 사용 하는 경우 쿼리는 여러 관련 테이블에서 데이터를 가져오는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-284">When working with relational databases, it is common for queries to pull their data from multiple, related tables.</span></span> <span data-ttu-id="aa473-285">상관 하위 쿼리 및 `JOIN` s는 쿼리에서 관련 테이블의 데이터에 액세스 하는 두 가지 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-285">Correlated subqueries and `JOIN` s provide two different techniques for accessing data from related tables in a query.</span></span> <span data-ttu-id="aa473-286">이전 자습서에서는 TableAdapter가 `JOIN` s와 관련 된 쿼리에 대해 `INSERT`, `UPDATE`및 `DELETE` 문을 자동으로 생성할 수 없기 때문에 일반적으로 상관 하위 쿼리를 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-286">In previous tutorials we most commonly made use of correlated subqueries because the TableAdapter cannot auto-generate `INSERT`, `UPDATE`, and `DELETE` statements for queries involving `JOIN` s.</span></span> <span data-ttu-id="aa473-287">이러한 값은 수동으로 제공할 수 있지만 임시 SQL 문을 사용 하는 경우 TableAdapter 구성 마법사가 완료 되 면 사용자 지정 항목을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-287">While these values can be provided manually, when using ad-hoc SQL statements any customizations will be overwritten when the TableAdapter Configuration wizard is completed.</span></span>

<span data-ttu-id="aa473-288">다행히 저장 프로시저를 사용 하 여 만든 Tableadapter는 임시 SQL 문을 사용 하 여 만든 것과 동일한 brittleness를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-288">Fortunately, TableAdapters created using stored procedures do not suffer from the same brittleness as those created using ad-hoc SQL statements.</span></span> <span data-ttu-id="aa473-289">따라서 주 쿼리에서 저장 프로시저를 사용할 때 `JOIN`를 사용 하는 TableAdapter를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-289">Therefore, it is feasible to create a TableAdapter whose main query uses a `JOIN` when using stored procedures.</span></span> <span data-ttu-id="aa473-290">이 자습서에서는 이러한 TableAdapter를 만드는 방법에 대해 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-290">In this tutorial we saw how to create such a TableAdapter.</span></span> <span data-ttu-id="aa473-291">해당 insert, update 및 delete 저장 프로시저가 자동으로 생성 되도록 TableAdapter의 주 쿼리에 대해 `JOIN`없는 `SELECT` 쿼리를 사용 하 여 시작 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-291">We started by using a `JOIN`-less `SELECT` query for the TableAdapter s main query so that the corresponding insert, update, and delete stored procedures would be auto-created.</span></span> <span data-ttu-id="aa473-292">TableAdapter의 초기 구성이 완료 되 면 `SelectCommand` 저장 프로시저를 확장 하 여 `JOIN`를 사용 하 고 TableAdapter 구성 마법사를 다시 실행 하 여 `EmployeesDataTable`의 열을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-292">With the TableAdapter s initial configuration complete, we augmented the `SelectCommand` stored procedure to use a `JOIN` and re-ran the TableAdapter Configuration wizard to update the `EmployeesDataTable` s columns.</span></span>

<span data-ttu-id="aa473-293">TableAdapter 구성 마법사를 다시 실행 하면 `Employees_Select` 저장 프로시저에서 반환 된 데이터 필드가 반영 되도록 `EmployeesDataTable` 열이 자동으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-293">Re-running the TableAdapter Configuration wizard automatically updated the `EmployeesDataTable` columns to reflect the data fields returned by the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="aa473-294">또는 이러한 열을 DataTable에 수동으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-294">Alternatively, we could have added these columns manually to the DataTable.</span></span> <span data-ttu-id="aa473-295">다음 자습서에서 DataTable에 열을 수동으로 추가 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-295">We will explore manually adding columns to the DataTable in the next tutorial.</span></span>

<span data-ttu-id="aa473-296">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="aa473-296">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="aa473-297">저자 정보</span><span class="sxs-lookup"><span data-stu-id="aa473-297">About the Author</span></span>

<span data-ttu-id="aa473-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="aa473-299">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-299">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="aa473-300">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-300">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="aa473-301">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="aa473-301">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="aa473-302">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-302">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="aa473-303">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-303">Special Thanks To</span></span>

<span data-ttu-id="aa473-304">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-304">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="aa473-305">이 자습서의 리드 검토자는 Hilton Geisenow, David Suru 및 Teresa Murphy입니다.</span><span class="sxs-lookup"><span data-stu-id="aa473-305">Lead reviewers for this tutorial were Hilton Geisenow, David Suru, and Teresa Murphy.</span></span> <span data-ttu-id="aa473-306">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="aa473-306">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="aa473-307">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="aa473-307">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="aa473-308">[이전](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)
> [다음](adding-additional-datatable-columns-vb.md)</span><span class="sxs-lookup"><span data-stu-id="aa473-308">[Previous](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)
[Next](adding-additional-datatable-columns-vb.md)</span></span>
