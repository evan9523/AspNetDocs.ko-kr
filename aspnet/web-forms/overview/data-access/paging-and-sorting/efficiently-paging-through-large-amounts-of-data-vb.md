---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 많은 양의 데이터를 효율적으로 페이징 (VB) | Microsoft Docs
author: rick-anderson
description: 데이터 프레젠테이션 컨트롤의 기본 페이징 옵션은 기본 데이터 소스 제어 retriev으로 많은 양의 데이터를 사용할 경우 적합 하지 않습니다.
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 0c788c4109d0d2839de969c628399290376a1ccd
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78476963"
---
# <a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="3d4d3-103">대량의 데이터를 효율적으로 페이징(VB)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>

<span data-ttu-id="3d4d3-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="3d4d3-105">[샘플 앱 다운로드](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) 또는 [PDF 다운로드](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="3d4d3-106">데이터의 하위 집합만 표시 되더라도 기본 데이터 원본 컨트롤이 모든 레코드를 검색 하므로 데이터 프레젠테이션 컨트롤의 기본 페이징 옵션은 많은 양의 데이터로 작업할 때 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="3d4d3-107">이러한 경우에는 사용자 지정 페이징로 전환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="3d4d3-108">소개</span><span class="sxs-lookup"><span data-stu-id="3d4d3-108">Introduction</span></span>

<span data-ttu-id="3d4d3-109">위의 자습서에서 설명한 대로 다음 두 가지 방법 중 하나로 페이징을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="3d4d3-110">**기본 페이징은** 데이터 웹 컨트롤의 스마트 태그에서 페이징 사용 옵션을 선택 하 여 구현할 수 있습니다. 그러나 데이터 페이지를 볼 때마다 ObjectDataSource의 하위 집합만 페이지에 표시 되는 경우에도 ObjectDataSource는 *모든* 레코드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="3d4d3-111">사용자 **지정 페이징은** 사용자가 요청한 특정 데이터 페이지에 대해 표시 해야 하는 데이터베이스의 레코드만 검색 하 여 기본 페이징의 성능을 향상 시킵니다. 그러나 사용자 지정 페이징은 기본 페이징 보다 구현 하는 데 약간의 노력이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="3d4d3-112">구현 용이성으로 인해 확인란을 선택 하 고 다시 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="3d4d3-113">기본 페이징은 매력적인 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-113">default paging is an attractive option.</span></span> <span data-ttu-id="3d4d3-114">그러나 모든 레코드를 검색 하는 데 사용 되는 na의 방식은 매우 많은 양의 데이터를 페이징할 때 또는 많은 동시 사용자가 있는 사이트에 대해 집합 선택 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="3d4d3-115">이러한 경우에는 응답성이 뛰어난 시스템을 제공 하기 위해 사용자 지정 페이징 기능을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="3d4d3-116">사용자 지정 페이징의 챌린지는 특정 데이터 페이지에 필요한 정확한 레코드 집합을 반환 하는 쿼리를 작성할 수 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="3d4d3-117">다행히 Microsoft SQL Server 2005는 결과의 순위를 지정 하는 새 키워드를 제공 하 여 레코드의 적절 한 하위 집합을 효율적으로 검색할 수 있는 쿼리를 작성할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="3d4d3-118">이 자습서에서는이 새로운 SQL Server 2005 키워드를 사용 하 여 GridView 컨트롤에서 사용자 지정 페이징을 구현 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="3d4d3-119">사용자 지정 페이징에 대 한 사용자 인터페이스는 기본 페이징의 사용자 인터페이스와 동일 하지만, 사용자 지정 페이징을 사용 하 여 한 페이지에서 다음 페이지로의 단계별 실행은 기본 페이징 보다 더 빠른 몇 가지 주문이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="3d4d3-120">사용자 지정 페이징에 의해 표시 되는 정확한 성능 향상은 페이지를 통해 페이징 되는 레코드의 총 수와 데이터베이스 서버에 로드를 배치 하는 위치에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="3d4d3-121">이 자습서의 끝 부분에서는 사용자 지정 페이징을 통해 얻은 성능 혜택을 보여 주는 몇 가지 대략적인 메트릭을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="3d4d3-122">1 단계: 사용자 지정 페이징 프로세스 이해</span><span class="sxs-lookup"><span data-stu-id="3d4d3-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="3d4d3-123">데이터를 페이징할 때 페이지에 표시 되는 정확한 레코드는 요청 되는 데이터 페이지 및 페이지당 표시 되는 레코드 수에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="3d4d3-124">예를 들어, 페이지 당 10 개 제품을 표시 하는 81 제품을 페이지로 이동 하고자 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="3d4d3-125">첫 번째 페이지를 볼 때 제품 1 ~ 10 개를 사용할 예정입니다. 두 번째 페이지를 볼 때 제품 11 ~ 20에 관심이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="3d4d3-126">검색 해야 하는 레코드와 페이징 인터페이스를 렌더링 하는 방법을 지정 하는 세 가지 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="3d4d3-127">**시작 행 인덱스** 표시할 데이터 페이지에 있는 첫 번째 행의 인덱스입니다. 이 인덱스는 페이지 당 표시 되는 레코드와 페이지 인덱스를 곱하여 하나씩 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="3d4d3-128">예를 들어, 한 번에 10 개의 레코드를 페이징할 때 첫 번째 페이지 (페이지 인덱스가 0 인 경우)에 대해 시작 행 인덱스는 0 \* 10 + 1 또는 1입니다. 페이지 인덱스가 1 인 두 번째 페이지의 경우 시작 행 인덱스는 1 \* 10 + 1 또는 11입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="3d4d3-129">**최대 행** 페이지당 표시할 최대 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="3d4d3-130">이 변수는 마지막 페이지에서 페이지 크기 보다 반환 되는 레코드 수를 줄일 수 있으므로 최대 행 수 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="3d4d3-131">예를 들어, 페이지당 81 제품 10 레코드를 페이징할 때 아홉 번째 및 마지막 페이지에는 하나의 레코드만 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="3d4d3-132">그러나 페이지 없음은 최대 행 수 값 보다 많은 레코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="3d4d3-133">**총 레코드 수** -페이징 되는 전체 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="3d4d3-134">이 변수는 지정 된 페이지에 대해 검색할 레코드를 결정 하는 데 필요 하지 않지만 페이징 인터페이스를 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="3d4d3-135">예를 들어, 페이지를 통해 81 개의 제품이 있는 경우 페이징 인터페이스는 페이징 UI에서 9 개의 페이지 번호를 표시 한다는 것을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="3d4d3-136">기본 페이징을 사용 하면 시작 행 인덱스는 페이지 인덱스의 곱으로 계산 되 고 페이지 크기는 1로 계산 되 고, 최대 행은 단지 페이지 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="3d4d3-137">기본 페이징이 데이터 페이지를 렌더링할 때 데이터베이스에서 모든 레코드를 검색 하기 때문에 각 행에 대 한 인덱스를 알 수 있으므로 시작 행 인덱스 행을 간단한 작업으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="3d4d3-138">또한 전체 레코드 수는 DataTable의 레코드 수 (또는 데이터베이스 결과를 저장 하는 데 사용 되는 개체)에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="3d4d3-139">시작 행 인덱스 및 최대 행 수 변수가 지정 된 경우 사용자 지정 페이징 구현은 시작 행 인덱스에서 시작 하 여 레코드의 정확한 하위 집합만 반환 하 고 그 후에는 최대 행 수를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="3d4d3-140">사용자 지정 페이징은 다음과 같은 두 가지 문제를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="3d4d3-141">지정 된 시작 행 인덱스에서 레코드를 반환 하기 시작할 수 있도록 페이지를 통해 전체 데이터의 각 행에 행 인덱스를 효율적으로 연결할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="3d4d3-142">페이징할 전체 레코드 수를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="3d4d3-143">다음 두 단계에서는 이러한 두 가지 문제에 대응 하는 데 필요한 SQL 스크립트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="3d4d3-144">SQL 스크립트 외에도 DAL 및 BLL에서 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="3d4d3-145">2 단계: 페이징할 수 있는 레코드의 총 수 반환</span><span class="sxs-lookup"><span data-stu-id="3d4d3-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="3d4d3-146">표시 되는 페이지에 대 한 레코드의 정확한 하위 집합을 검색 하는 방법을 살펴보기 전에에서 먼저 페이지를 통해 전체 레코드 수를 반환 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="3d4d3-147">이 정보는 페이징 사용자 인터페이스를 올바르게 구성 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="3d4d3-148">[`COUNT` 집계 함수](https://msdn.microsoft.com/library/ms175997.aspx)를 사용 하 여 특정 SQL 쿼리에서 반환 된 총 레코드 수를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="3d4d3-149">예를 들어 `Products` 테이블의 총 레코드 수를 확인 하기 위해 다음 쿼리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="3d4d3-150">에서이 정보를 반환 하는 메서드를 DAL에 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="3d4d3-151">특히, 위에 표시 된 `SELECT` 문을 실행 하는 `TotalNumberOfProducts()` 이라는 DAL 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="3d4d3-152">먼저 `App_Code/DAL` 폴더에서 형식화 된 데이터 집합 파일 `Northwind.xsd`를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="3d4d3-153">그런 다음 디자이너에서 `ProductsTableAdapter`를 마우스 오른쪽 단추로 클릭 하 고 쿼리 추가를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="3d4d3-154">이전 자습서에서 살펴본 것 처럼이 작업을 수행 하면 DAL에 새 메서드를 추가할 수 있습니다 .이 메서드를 호출 하면 특정 SQL 문 또는 저장 프로시저를 실행 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="3d4d3-155">이전 자습서의 TableAdapter 메서드와 마찬가지로이 경우 임시 SQL 문을 사용 하는 것이 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![임시 SQL 문 사용](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="3d4d3-157">**그림 1**: 임시 SQL 문 사용</span><span class="sxs-lookup"><span data-stu-id="3d4d3-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="3d4d3-158">다음 화면에서 만들 쿼리 유형을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="3d4d3-159">이 쿼리는 단일 스칼라 값을 반환 하므로 `Products` 테이블의 총 레코드 수는 단일 값 옵션을 반환 하는 `SELECT`를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![단일 값을 반환 하는 SELECT 문을 사용 하도록 쿼리를 구성 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="3d4d3-161">**그림 2**: 단일 값을 반환 하는 SELECT 문을 사용 하 여 쿼리 구성</span><span class="sxs-lookup"><span data-stu-id="3d4d3-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="3d4d3-162">사용할 쿼리 유형을 표시 한 후에는 다음 쿼리를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-162">After indicating the type of query to use, we must next specify the query.</span></span>

![Products의 SELECT COUNT (\*) 쿼리 사용](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="3d4d3-164">**그림 3**: PRODUCTS의 SELECT COUNT (\*) 쿼리 사용</span><span class="sxs-lookup"><span data-stu-id="3d4d3-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="3d4d3-165">마지막으로 메서드의 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="3d4d3-166">앞서 언급 했 듯이 s를 사용 하 여 `TotalNumberOfProducts`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![DAL 방법의 이름을 TotalNumberOfProducts로 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="3d4d3-168">**그림 4**: DAL 방법의 이름 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="3d4d3-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="3d4d3-169">마침을 클릭 하면 마법사가 DAL에 `TotalNumberOfProducts` 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="3d4d3-170">SQL 쿼리의 결과가 `NULL`되는 경우 DAL의 스칼라 반환 메서드는 nullable 형식을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="3d4d3-171">그러나 `COUNT` 쿼리는 항상`NULL` 아닌 값을 반환 합니다. 에 관계 없이 DAL 메서드는 nullable 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="3d4d3-172">DAL 메서드 외에도 BLL에 메서드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="3d4d3-173">`ProductsBLL` 클래스 파일을 열고, DAL s `TotalNumberOfProducts` 메서드를 단순히 호출 하는 `TotalNumberOfProducts` 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="3d4d3-174">DAL s `TotalNumberOfProducts` 메서드는 nullable 정수를 반환 합니다. 그러나 `ProductsBLL` 클래스 s `TotalNumberOfProducts` 메서드를 만들어 표준 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="3d4d3-175">따라서 `ProductsBLL` 클래스 s `TotalNumberOfProducts` 메서드가 DAL s `TotalNumberOfProducts` 메서드에서 반환 되는 nullable 정수의 값 부분을 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="3d4d3-176">`GetValueOrDefault()`에 대 한 호출은 null 허용 정수의 값 (있는 경우)을 반환 합니다. 그러나 null을 허용 하는 정수는 `null`경우 기본 정수 값인 0이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="3d4d3-177">3 단계: 정확한 레코드 하위 집합 반환</span><span class="sxs-lookup"><span data-stu-id="3d4d3-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="3d4d3-178">다음 태스크는 앞서 설명한 시작 행 인덱스 및 최대 행 변수를 허용 하 고 적절 한 레코드를 반환 하는 DAL 및 BLL에서 메서드를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="3d4d3-179">이 작업을 수행 하기 전에 먼저 필요한 SQL 스크립트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="3d4d3-180">이에 대 한 문제는 시작 행 인덱스에서 시작 하는 레코드 (및 최대 레코드 수까지)를 반환할 수 있도록 페이징에서 전체 결과의 각 행에 인덱스를 효율적으로 할당할 수 있어야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="3d4d3-181">데이터베이스 테이블에 행 인덱스 역할을 하는 열이 이미 있는 경우에는이 작업이 쉽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="3d4d3-182">처음에는 첫 번째 제품에는 1, 2, 2 등의 `ProductID` 있기 때문에 `Products` 테이블 s `ProductID` 필드가 충분 하다 고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="3d4d3-183">그러나 제품을 삭제 하면 순서 대로 간격이 되돌리고이 접근 방식이 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="3d4d3-184">행 인덱스를 페이지의 데이터와 효율적으로 연결 하 여 레코드의 정확한 하위 집합을 검색할 수 있도록 하는 두 가지 일반적인 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="3d4d3-185">**SQL Server 2005 s `ROW_NUMBER()` 키워드인 New 키워드를 사용 하 여** SQL Server 2005에서 `ROW_NUMBER()` 키워드는 순서에 따라 반환 된 각 레코드에 순위를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="3d4d3-186">이 순위는 각 행에 대 한 행 인덱스로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="3d4d3-187">**테이블 변수 및 `SET ROWCOUNT`사용** SQL Server s [`SET ROWCOUNT` 문을](https://msdn.microsoft.com/library/ms188774.aspx) 사용 하 여 쿼리를 종료 하기 전에 처리할 총 레코드 수를 지정할 수 있습니다. [테이블 변수](http://www.sqlteam.com/item.asp?ItemID=9454) 는 테이블 형식 데이터를 보유할 수 있는 로컬 t-sql 변수 이며 [임시 테이블과](http://www.sqlteam.com/item.asp?ItemID=2029)유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="3d4d3-188">이 방법은 Microsoft SQL Server 2005 및 SQL Server 2000에서 동일 하 게 작동 합니다. 반면 `ROW_NUMBER()` 방법은 SQL Server 2005 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="3d4d3-189">여기서의 개념은 데이터를 페이징할 테이블의 기본 키에 대 한 `IDENTITY` 열과 열이 있는 테이블 변수를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="3d4d3-190">그런 다음 데이터가 페이징 되는 테이블의 내용이 테이블 변수에 덤프 되어 테이블의 각 레코드에 대 한 순차적 행 인덱스 (`IDENTITY` 열을 통해)를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="3d4d3-191">테이블 변수가 채워지면 기본 테이블과 조인 된 테이블 변수에 대 한 `SELECT` 문을 실행 하 여 특정 레코드를 끌어올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="3d4d3-192">`SET ROWCOUNT` 문은 덤프 해야 하는 레코드 수를 테이블 변수로 지능적으로 제한 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="3d4d3-193">이 방법의 효율성은 요청 되는 페이지 번호를 기준으로 합니다 .이는 `SET ROWCOUNT` 값에 시작 행 인덱스와 최대 행의 값이 할당 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="3d4d3-194">데이터의 처음 몇 페이지와 같이 번호가 낮은 페이지를 페이징할 때이 접근 방식은 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="3d4d3-195">그러나 끝에 가까운 페이지를 검색 하는 경우 기본 페이징 모양의 성능을 보여 주는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="3d4d3-196">이 자습서에서는 `ROW_NUMBER()` 키워드를 사용 하 여 사용자 지정 페이징을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="3d4d3-197">테이블 변수 및 `SET ROWCOUNT` 기법을 사용 하는 방법에 대 한 자세한 내용은 [많은 결과 집합을 페이징 하는 보다 효율적인 메서드](http://www.4guysfromrolla.com/webtech/042606-1.shtml)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="3d4d3-198">다음 구문을 사용 하 여 특정 순서에 따라 반환 되는 각 레코드의 순위와 연결 된 `ROW_NUMBER()` 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="3d4d3-199">`ROW_NUMBER()`는 표시 된 순서와 관련 하 여 각 레코드의 순위를 지정 하는 숫자 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="3d4d3-200">예를 들어 각 제품에 대 한 순위를 가장 비싼 것부터 최소 순으로 표시 하려면 다음 쿼리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="3d4d3-201">그림 5에서는 Visual Studio에서 쿼리 창을 통해 실행 하는 경우의 쿼리 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="3d4d3-202">제품은 각 행에 대 한 가격 순위와 함께 가격을 기준으로 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![반환 된 각 레코드에 대해 가격 순위가 포함 됩니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="3d4d3-204">**그림 5**: 반환 되는 각 레코드에 대 한 가격 순위 포함</span><span class="sxs-lookup"><span data-stu-id="3d4d3-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="3d4d3-205">`ROW_NUMBER()`는 SQL Server 2005에서 사용할 수 있는 여러 가지 새로운 순위 함수 중 하나일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="3d4d3-206">다른 순위 함수를 사용 하 여 `ROW_NUMBER()`에 대 한 자세한 내용은 [Microsoft SQL Server 2005를 사용 하 여 순위 결과 반환](http://www.4guysfromrolla.com/webtech/010406-1.shtml)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="3d4d3-207">`OVER` 절에서 지정 된 `ORDER BY` 열을 기준으로 결과를 순위를 지정 하는 경우 (위 예제에서`UnitPrice`) SQL Server 결과를 정렬 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="3d4d3-208">이는 결과가 정렬 되는 열에 대해 클러스터형 인덱스가 있는 경우 또는 포함 하는 인덱스가 있는 경우에는 빠른 작업이 며 그렇지 않은 경우 비용이 더 많이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="3d4d3-209">충분 한 크기의 쿼리에 대 한 성능 향상을 위해에서 결과의 순서를 지정 하는 열에 대해 비클러스터형 인덱스를 추가 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="3d4d3-210">성능 고려 사항을 자세히 확인 하려면 [SQL Server 2005의 순위 함수 및 성능](http://www.sql-server-performance.com/ak_ranking_functions.asp) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="3d4d3-211">`ROW_NUMBER()`에서 반환 하는 순위 정보는 `WHERE` 절에서 직접 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="3d4d3-212">그러나 파생 테이블을 사용 하 여 `ROW_NUMBER()` 결과를 반환할 수 있으며이 결과는 `WHERE` 절에 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="3d4d3-213">예를 들어 다음 쿼리는 파생 테이블을 사용 하 여 ProductName 및 UnitPrice 열을 `ROW_NUMBER()` 결과와 함께 반환한 다음, `WHERE` 절을 사용 하 여 가격 등급이 11에서 20 사이인 제품만 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="3d4d3-214">이 개념을 조금 더 확장 하면이 방법을 사용 하 여 원하는 시작 행 인덱스 및 최대 행 값이 지정 된 특정 데이터 페이지를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="3d4d3-215">이 자습서의 뒷부분에서 볼 수 있듯이 ObjectDataSource에서 제공 하는 *`StartRowIndex`* 인덱스는 0부터 시작 하는 반면 SQL Server 2005에서 반환 된 `ROW_NUMBER()` 값은 1부터 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="3d4d3-216">따라서 `WHERE` 절은 `PriceRank` *`StartRowIndex`* 보다 엄격 하 게 크고 *`StartRowIndex`*  +  *`MaximumRows`* 보다 작거나 같은 레코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="3d4d3-217">이제 시작 행 인덱스 및 최대 행 값이 지정 된 데이터의 특정 페이지를 검색 하는 데 `ROW_NUMBER()`를 사용 하는 방법을 설명 했으므로 이제 DAL 및 BLL의 메서드로이 논리를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="3d4d3-218">이 쿼리를 만들 때 결과가 순위를 지정 하는 순서를 결정 해야 합니다. 이름을 기준으로 제품을 사전순으로 정렬 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="3d4d3-219">즉,이 자습서의 사용자 지정 페이징 구현을 사용 하면 정렬할 수 있는 것 보다 사용자 지정 페이지가 지정 된 보고서를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="3d4d3-220">그러나 다음 자습서에서는 이러한 기능을 제공 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="3d4d3-221">이전 섹션에서는 DAL 메서드를 임시 SQL 문으로 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="3d4d3-222">불행 하 게도 TableAdapter 마법사에서 사용 하는 Visual Studio의 T-sql 파서는 `ROW_NUMBER()` 함수에서 사용 하는 `OVER` 구문과 동일 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="3d4d3-223">따라서이 DAL 메서드를 저장 프로시저로 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="3d4d3-224">보기 메뉴에서 서버 탐색기를 선택 하거나 Ctrl + Alt + S를 눌러 `NORTHWND.MDF` 노드를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="3d4d3-225">새 저장 프로시저를 추가 하려면 저장 프로시저 노드를 마우스 오른쪽 단추로 클릭 하 고 새 저장 프로시저 추가를 선택 합니다 (그림 6 참조).</span><span class="sxs-lookup"><span data-stu-id="3d4d3-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![제품을 페이징 하기 위한 새 저장 프로시저 추가](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="3d4d3-227">**그림 6**: 제품을 페이징 하기 위한 새 저장 프로시저 추가</span><span class="sxs-lookup"><span data-stu-id="3d4d3-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="3d4d3-228">이 저장 프로시저는 두 개의 정수 입력 매개 변수 (`@startRowIndex` 및 `@maximumRows`를 수락 하 고 `ProductName` 필드를 기준으로 정렬 된 `ROW_NUMBER()` 함수를 사용 하 여 지정 된 `@startRowIndex` 보다 큰 행만 반환 하 고 `@startRowIndex` + `@maximumRow` 보다 작거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="3d4d3-229">새 저장 프로시저에 다음 스크립트를 입력 한 다음 저장 아이콘을 클릭 하 여 데이터베이스에 저장 프로시저를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="3d4d3-230">저장 프로시저를 만든 후 잠시 후에 테스트를 수행 합니다. 서버 탐색기에서 `GetProductsPaged` 저장 프로시저 이름을 마우스 오른쪽 단추로 클릭 하 고 실행 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="3d4d3-231">그러면 Visual Studio에서 입력 매개 변수, `@startRowIndex` 및 `@maximumRow`를 묻는 메시지를 표시 합니다 (그림 7 참조).</span><span class="sxs-lookup"><span data-stu-id="3d4d3-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="3d4d3-232">다른 값을 시도 하 고 결과를 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-232">Try different values and examine the results.</span></span>

![@startRowIndex 및 @maximumRows 매개 변수의 값을 입력 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="3d4d3-234"><strong>그림 7</strong>: @startRowIndex 및 @maximumRows 매개 변수의 값을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="3d4d3-235">이러한 입력 매개 변수 값을 선택 하면 출력 창에 결과가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="3d4d3-236">그림 8에서는 `@startRowIndex` 및 `@maximumRows` 매개 변수 모두에 대해 10을 전달할 때의 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="3d4d3-237">[데이터의 두 번째 페이지에 표시 되는 레코드를 반환 ![](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="3d4d3-238">**그림 8**: 데이터의 두 번째 페이지에 표시 되는 레코드 반환 ([전체 크기 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="3d4d3-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>

<span data-ttu-id="3d4d3-239">이 저장 프로시저를 만든 후에 `ProductsTableAdapter` 메서드를 만들 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="3d4d3-240">`Northwind.xsd` 형식화 된 데이터 집합을 열고 `ProductsTableAdapter`을 마우스 오른쪽 단추로 클릭 한 다음 쿼리 추가 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="3d4d3-241">임시 SQL 문을 사용 하 여 쿼리를 만드는 대신 기존 저장 프로시저를 사용 하 여 쿼리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![기존 저장 프로시저를 사용 하 여 DAL 메서드 만들기](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="3d4d3-243">**그림 9**: 기존 저장 프로시저를 사용 하 여 DAL 메서드 만들기</span><span class="sxs-lookup"><span data-stu-id="3d4d3-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="3d4d3-244">그런 다음 호출할 저장 프로시저를 선택 하 라는 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="3d4d3-245">드롭다운 목록에서 `GetProductsPaged` 저장 프로시저를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![드롭다운 목록에서 Get제품 Sp오래 된 저장 프로시저를 선택 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="3d4d3-247">**그림 10**: 드롭다운 목록에서 Get제품 Sp오래 된 저장 프로시저 선택</span><span class="sxs-lookup"><span data-stu-id="3d4d3-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="3d4d3-248">그런 다음, 다음 화면에서는 저장 프로시저에서 반환 되는 데이터 종류 (표 형식 데이터, 단일 값 또는 값 없음)를 묻는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="3d4d3-249">`GetProductsPaged` 저장 프로시저는 여러 레코드를 반환할 수 있으므로 테이블 형식 데이터를 반환 하도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![저장 프로시저에서 테이블 형식 데이터를 반환 함을 나타냄](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="3d4d3-251">**그림 11**: 저장 프로시저에서 테이블 형식 데이터를 반환 함을 나타냄</span><span class="sxs-lookup"><span data-stu-id="3d4d3-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="3d4d3-252">마지막으로 만들려는 메서드의 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="3d4d3-253">이전 자습서와 마찬가지로 계속 해 서 DataTable 채우기 및 DataTable 반환을 모두 사용 하 여 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="3d4d3-254">첫 번째 메서드의 이름을 `FillPaged` 하 고 두 번째를 `GetProductsPaged`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![메서드 이름 채우기 및 Get제품 Sp에이징됩니다](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="3d4d3-256">**그림 12**: 메서드 이름 채우기-페이징 및 Get제품 sp오래 된 이름</span><span class="sxs-lookup"><span data-stu-id="3d4d3-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="3d4d3-257">특정 제품 페이지를 반환 하기 위해 DAL 메서드를 만들 뿐 아니라 BLL 에서도 이러한 기능을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="3d4d3-258">DAL 메서드와 마찬가지로, BLL의 Get제품 Sp오래 된 메서드는 시작 행 인덱스 및 최대 행을 지정 하는 데 두 개의 정수 입력을 허용 해야 하며 지정 된 범위에 속하는 레코드만 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="3d4d3-259">다음과 같이 ProductsBLL 클래스에 이러한 BLL 메서드를 만들어 DAL s Get제품 Sp오래 된 메서드만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="3d4d3-260">BLL 메서드의 입력 매개 변수에는 임의의 이름을 사용할 수 있습니다. 그러나이 메서드를 사용 하도록 ObjectDataSource를 구성 하는 경우 `startRowIndex`를 사용 하도록 선택 하 고 `maximumRows` 추가 작업에서이를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="3d4d3-261">4 단계: 사용자 지정 페이징을 사용 하도록 ObjectDataSource 구성</span><span class="sxs-lookup"><span data-stu-id="3d4d3-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="3d4d3-262">레코드의 특정 하위 집합에 액세스 하기 위한 BLL 및 DAL 메서드를 사용 하 여 사용자 지정 페이징을 사용 하는 기본 레코드를 통해 페이지를 지정 하는 GridView 컨트롤을 만들 준비가 완료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="3d4d3-263">먼저 `PagingAndSorting` 폴더에서 `EfficientPaging.aspx` 페이지를 열고 페이지에 GridView를 추가 하 고 새 ObjectDataSource 컨트롤을 사용 하도록 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="3d4d3-264">이전 자습서에서는 `ProductsBLL` 클래스 s `GetProducts` 메서드를 사용 하도록 ObjectDataSource를 구성 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="3d4d3-265">그러나 이번에는 `GetProducts` 메서드가 데이터베이스의 *모든* 제품을 반환 하는 반면 `GetProductsPaged`는 특정 레코드 하위 집합만 반환 하기 때문에 `GetProductsPaged` 메서드를 대신 사용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![ProductsBLL 클래스 s Get제품 Sp오래 된 메서드를 사용 하도록 ObjectDataSource 구성](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="3d4d3-267">**그림 13**: ProductsBLL 클래스 s를 사용 하도록 ObjectDataSource 구성 Get제품 sp오래 된 메서드</span><span class="sxs-lookup"><span data-stu-id="3d4d3-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="3d4d3-268">읽기 전용 GridView를 다시 만들기 때문에 삽입, 업데이트 및 삭제 탭에서 메서드 드롭다운 목록을 (없음)으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="3d4d3-269">그런 다음, ObjectDataSource 마법사는 `GetProductsPaged` 메서드 `startRowIndex` 및 `maximumRows` 입력 매개 변수 값의 출처를 묻는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="3d4d3-270">이러한 입력 매개 변수는 실제로 GridView에서 자동으로 설정 되므로 소스를 None으로 설정 하 고 마침을 클릭 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![입력 매개 변수 원본을 None으로 유지](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="3d4d3-272">**그림 14**: 입력 매개 변수 원본을 None으로 유지</span><span class="sxs-lookup"><span data-stu-id="3d4d3-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="3d4d3-273">ObjectDataSource 마법사를 완료 한 후 GridView에는 각 제품 데이터 필드에 대 한 BoundField 또는 CheckBoxField가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="3d4d3-274">적합 하다 고 생각 하는 대로 GridView의 모양을 자유롭게 조정 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="3d4d3-275">`ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`및 `UnitPrice` BoundFields 표시 하도록 옵트인 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="3d4d3-276">또한 해당 스마트 태그에서 페이징 사용 확인란을 선택 하 여 페이징을 지원 하도록 GridView를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="3d4d3-277">이러한 변경 후에는 GridView 및 ObjectDataSource 선언적 태그가 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="3d4d3-278">그러나 브라우저를 통해 페이지를 방문 하는 경우에는 GridView를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![GridView가 표시 되지 않습니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="3d4d3-280">**그림 15**: GridView가 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="3d4d3-281">ObjectDataSource가 현재 `GetProductsPaged` `startRowIndex` 및 `maximumRows` 입력 매개 변수 모두에 대 한 값으로 0을 사용 하 고 있으므로 GridView가 누락 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="3d4d3-282">따라서 결과 SQL 쿼리는 레코드를 반환 하지 않으므로 GridView가 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="3d4d3-283">이를 해결 하려면 사용자 지정 페이징을 사용 하도록 ObjectDataSource를 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="3d4d3-284">이 작업은 다음 단계에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="3d4d3-285">**Objectdatasource s `EnablePaging` 속성을 `true`로 설정** 합니다 .이 매개 변수는 두 개의 추가 매개 변수 `SelectMethod`에 전달 해야 하는 objectdatasource를 나타냅니다. 즉, 시작 행 인덱스 ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))를 지정 하 고 하나는 최대 행 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))을 지정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="3d4d3-286">이에 **따라 ObjectDataSource s `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 속성을 설정** 합니다 .이에 따라 `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 속성은 사용자 지정 페이징 목적으로 `SelectMethod`에 전달 되는 입력 매개 변수의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="3d4d3-287">기본적으로 이러한 매개 변수 이름은 `startIndexRow` 되 고 `maximumRows`. 즉, BLL에서 `GetProductsPaged` 메서드를 만들 때 입력 매개 변수에 대해 이러한 값을 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="3d4d3-288">예를 들어 `startIndex` 및 `maxRows`와 같은 BLL `GetProductsPaged` 메서드에 대해 다른 매개 변수 이름을 사용 하도록 선택한 경우에는 ObjectDataSource s `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 속성을 적절 하 게 설정 해야 합니다 (예: `StartRowIndexParameterName`의 경우 startIndex, `MaximumRowsParameterName`의 경우 maxRows).</span><span class="sxs-lookup"><span data-stu-id="3d4d3-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="3d4d3-289">**ObjectDataSource s [`SelectCountMethod` 속성](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) 을 페이징된 전체 레코드 수를 반환 하는 메서드의 이름으로 설정 합니다. (`TotalNumberOfProducts`)** `ProductsBLL` 클래스의 `TotalNumberOfProducts` 메서드는 `SELECT COUNT(*) FROM Products` 쿼리를 실행 하는 DAL 메서드를 사용 하 여 페이징할 수 있는 레코드의 총 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="3d4d3-290">이 정보는 페이징 인터페이스를 올바르게 렌더링 하기 위해 ObjectDataSource에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="3d4d3-291">마법사를 통해 ObjectDataSource를 구성 하는 경우 **objectdatasource s 선언적 태그에서 `startRowIndex` 및 `maximumRows` `<asp:Parameter>` 요소를 제거 하 고** Visual Studio에서 `GetProductsPaged` 메서드 입력 매개 변수에 대 한 두 개의 `<asp:Parameter>` 요소를 자동으로 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="3d4d3-292">`EnablePaging`을 `true`로 설정 하면 이러한 매개 변수가 자동으로 전달 됩니다. 선언 구문에도 표시 되는 경우 ObjectDataSource는 `GetProductsPaged` 메서드에 *4 개의* 매개 변수를 전달 하 고 `TotalNumberOfProducts` 메서드에 두 개의 매개 변수를 전달 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="3d4d3-293">이러한 `<asp:Parameter>` 요소를 제거 하지 않은 경우 브라우저를 통해 페이지를 방문 하면 다음과 같은 오류 메시지가 표시 됩니다. *ObjectDataSource ' ObjectDataSource1 ' 매개 변수를 포함 하는 비 제네릭 메서드 ' TotalNumberOfProducts '를 찾을 수 없습니다 (startRowIndex, maximumRows*).</span><span class="sxs-lookup"><span data-stu-id="3d4d3-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="3d4d3-294">이러한 변경을 수행한 후 ObjectDataSource의 선언적 구문은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="3d4d3-295">`EnablePaging` 및 `SelectCountMethod` 속성이 설정 되었고 `<asp:Parameter>` 요소가 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="3d4d3-296">그림 16에는 이러한 변경 내용이 적용 된 후 속성 창의 스크린샷이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![사용자 지정 페이징을 사용 하려면 ObjectDataSource 컨트롤을 구성 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="3d4d3-298">**그림 16**: 사용자 지정 페이징을 사용 하려면 ObjectDataSource 컨트롤 구성</span><span class="sxs-lookup"><span data-stu-id="3d4d3-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="3d4d3-299">이러한 변경을 수행한 후 브라우저를 통해이 페이지를 방문 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="3d4d3-300">사전순으로 정렬 된 10 개의 제품이 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="3d4d3-301">잠시 후에 한 페이지씩 데이터를 단계별로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="3d4d3-302">기본 페이징 및 사용자 지정 페이징 간에 최종 사용자의 관점과 시각적 차이가 없지만, 지정 된 페이지에 대해 표시 되어야 하는 레코드를 검색 하기만 하므로 많은 양의 데이터를 사용 하 여 페이지를 더 효율적으로 페이징할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="3d4d3-303">[제품 이름을 기준으로 정렬 된 데이터 ![사용자 지정 페이징을 사용 하 여 페이징 됩니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="3d4d3-304">**그림 17**: 제품 이름을 기준으로 정렬 된 데이터는 사용자 지정 페이징 ([전체 크기 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))을 사용 하 여 페이징 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="3d4d3-305">사용자 지정 페이징을 사용 하 여 ObjectDataSource s `SelectCountMethod`에서 반환 된 페이지 수 값은 GridView의 뷰 상태에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="3d4d3-306">기타 GridView 변수 `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` 컬렉션 등은 *컨트롤 상태*에 저장 되며,이는 gridview s `EnableViewState` 속성의 값에 관계 없이 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="3d4d3-307">`PageCount` 값은 뷰 상태를 사용 하 여 포스트백 간에 지속 되므로 마지막 페이지로 이동 하는 링크를 포함 하는 페이징 인터페이스를 사용 하는 경우 GridView의 뷰 상태를 사용 하도록 설정 하는 것이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="3d4d3-308">(페이징 인터페이스가 마지막 페이지에 대 한 직접 링크를 포함 하지 않는 경우 보기 상태를 사용 하지 않도록 설정할 수 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="3d4d3-309">마지막 페이지 링크를 클릭 하면 포스트백이 발생 하 고 GridView에 `PageIndex` 속성을 업데이트 하도록 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="3d4d3-310">마지막 페이지 링크를 클릭 한 경우 GridView는 해당 `PageIndex` 속성을 `PageCount` 속성 보다 작은 값으로 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="3d4d3-311">뷰 상태를 사용 하지 않도록 설정 하면 다시 게시 간에 `PageCount` 값이 손실 되 고 `PageIndex`에 최대 정수 값이 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="3d4d3-312">그런 다음 GridView는 `PageSize` 및 `PageCount` 속성을 곱하여 시작 행 인덱스를 확인 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="3d4d3-313">이로 인해 제품이 허용 되는 최대 정수 크기를 초과 하므로 `OverflowException` 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="3d4d3-314">사용자 지정 페이징 및 정렬 구현</span><span class="sxs-lookup"><span data-stu-id="3d4d3-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="3d4d3-315">현재 사용자 지정 페이징 구현을 사용 하려면 `GetProductsPaged` 저장 프로시저를 만들 때 데이터를 페이징 하는 순서가 정적으로 지정 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="3d4d3-316">그러나 GridView s 스마트 태그에는 페이징 사용 옵션 외에도 정렬 사용 확인란이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="3d4d3-317">아쉽게도 현재 사용자 지정 페이징 구현을 사용 하 여 GridView에 정렬 지원을 추가 하면 현재 표시 된 데이터 페이지의 레코드만 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="3d4d3-318">예를 들어, GridView가 페이징을 지원 하도록 구성 하는 경우 데이터의 첫 페이지를 볼 때 product name을 기준으로 내림차순으로 정렬 하 여 1 페이지에서 제품의 순서를 반대로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="3d4d3-319">그림 18에 나와 있는 것 처럼 Carnarvon Tigers는 역순으로 정렬할 때 첫 번째 제품으로 표시 되며,이는 Carnarvon Tigers가 사전순으로 표시 되는 71 다른 제품을 무시 합니다. 첫 번째 페이지의 레코드만 정렬에서 고려 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="3d4d3-320">[![현재 페이지에 표시 된 데이터만 정렬 됩니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="3d4d3-321">**그림 18**: 현재 페이지에 표시 된 데이터만 정렬 ([전체 크기 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="3d4d3-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>

<span data-ttu-id="3d4d3-322">정렬은 BLL `GetProductsPaged` 메서드에서 데이터를 검색 한 후에 정렬 되기 때문에 현재 데이터 페이지에만 적용 되며,이 메서드는 특정 페이지에 대 한 레코드만 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="3d4d3-323">정렬을 올바르게 구현 하려면 특정 데이터 페이지를 반환 하기 전에 데이터를 적절 하 게 순위를 지정할 수 있도록 정렬 식을 `GetProductsPaged` 메서드에 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="3d4d3-324">다음 자습서에서이를 수행 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="3d4d3-325">사용자 지정 페이징 및 삭제 구현</span><span class="sxs-lookup"><span data-stu-id="3d4d3-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="3d4d3-326">사용자 지정 페이징 기술을 사용 하 여 데이터를 페이징 하는 GridView에서 기능을 삭제 하도록 설정 하는 경우 마지막 페이지에서 마지막 레코드를 삭제할 때 gridview가 `PageIndex`GridView가 적절 하 게 감소 하는 것이 아니라 gridview가 사라집니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="3d4d3-327">이 버그를 재현 하려면 방금 만든 자습서에 대 한 삭제를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="3d4d3-328">마지막 페이지 (9 페이지)로 이동 합니다 .이 페이지에는 81 제품을 페이징 하 고 한 번에 10 개의 제품을 페이징 하므로 단일 제품이 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="3d4d3-329">이 제품을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-329">Delete this product.</span></span>

<span data-ttu-id="3d4d3-330">마지막 제품을 삭제 하는 경우 GridView는 여덟 번째 페이지로 *자동으로 이동* 하 고 이러한 기능에는 기본 페이징이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="3d4d3-331">그러나 사용자 지정 페이징을 사용 하면 마지막 페이지에서 마지막 제품을 삭제 한 후 GridView가 화면에서 완전히 사라집니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="3d4d3-332">이 문제가 발생 *하는 정확한 이유는* 이 자습서의 범위를 벗어나는 것입니다. 이 문제의 소스에 대 한 하위 수준 세부 정보에 대 한 [사용자 지정 페이징이 있는 GridView에서 마지막 페이지의 마지막 레코드 삭제](http://scottonwriting.net/sowblog/posts/7326.aspx) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="3d4d3-333">요약 하자면, 삭제 단추를 클릭할 때 GridView에서 수행 하는 일련의 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="3d4d3-334">레코드 삭제</span><span class="sxs-lookup"><span data-stu-id="3d4d3-334">Delete the record</span></span>
2. <span data-ttu-id="3d4d3-335">지정 된 `PageIndex`에 대해 표시할 적절 한 레코드를 가져오고 `PageSize`</span><span class="sxs-lookup"><span data-stu-id="3d4d3-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="3d4d3-336">`PageIndex` 데이터 원본에 있는 데이터 페이지 수를 초과 하지 않는지 확인 하십시오. 이 경우 자동으로 GridView s `PageIndex` 속성을 감소 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="3d4d3-337">2 단계에서 얻은 레코드를 사용 하 여 적절 한 데이터 페이지를 GridView에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="3d4d3-338">이 문제는 2 단계에서 표시할 레코드를 검색할 때 사용 되는 `PageIndex`는 아직 유일한 레코드를 삭제 한 마지막 페이지의 `PageIndex`는 사실에서 기인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="3d4d3-339">따라서 2 단계에서는 데이터의 마지막 페이지에 더 이상 레코드가 포함 되지 않기 때문 *에 레코드가 반환 되지 않습니다.*</span><span class="sxs-lookup"><span data-stu-id="3d4d3-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="3d4d3-340">그런 다음 3 단계에서 GridView는 마지막 페이지의 마지막 레코드를 삭제 하 여 해당 `PageIndex` 속성이 데이터 원본에 있는 페이지의 총 수보다 큰지 인식 하므로 `PageIndex` 속성을 감소 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="3d4d3-341">4 단계에서 GridView는 2 단계에서 검색 된 데이터에 바인딩을 시도 합니다. 그러나 2 단계에서 레코드가 반환 되지 않았기 때문에 빈 GridView가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="3d4d3-342">2 단계에서는 *모든* 레코드가 데이터 원본에서 검색 되므로 기본 페이징을 사용 하면이 문제는 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="3d4d3-343">이 문제를 해결 하기 위해 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-343">To fix this we have two options.</span></span> <span data-ttu-id="3d4d3-344">첫 번째는 방금 삭제 된 페이지에 표시 된 레코드 수를 결정 하는 GridView s `RowDeleted` 이벤트 처리기에 대 한 이벤트 처리기를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="3d4d3-345">레코드가 하나만 있는 경우 방금 삭제 한 레코드는 마지막 레코드이 고 GridView s `PageIndex`를 감소 시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="3d4d3-346">물론 삭제 작업이 실제로 성공한 경우에만 `PageIndex`을 업데이트 하려고 합니다 .이는 `e.Exception` 속성이 `null`되었는지 확인 하 여 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="3d4d3-347">이 방법은 1 단계 후 2 단계 이전에 `PageIndex`를 업데이트 하기 때문에 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="3d4d3-348">따라서 2 단계에서는 적절 한 레코드 집합이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="3d4d3-349">이를 수행 하려면 다음과 같은 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-349">To accomplish this, use code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="3d4d3-350">다른 해결 방법은 ObjectDataSource s `RowDeleted` 이벤트에 대 한 이벤트 처리기를 만들고 `AffectedRows` 속성을 값 1로 설정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="3d4d3-351">1 단계에서 레코드를 삭제 한 후 (2 단계에서 데이터를 다시 검색 하기 전) GridView는 하나 이상의 행이 작업의 영향을 받은 경우 해당 `PageIndex` 속성을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="3d4d3-352">그러나 `AffectedRows` 속성은 ObjectDataSource에 의해 설정 되지 않으므로이 단계는 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="3d4d3-353">이 단계를 실행 하는 한 가지 방법은 삭제 작업이 성공적으로 완료 되는 경우 `AffectedRows` 속성을 수동으로 설정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="3d4d3-354">다음과 같은 코드를 사용 하 여이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-354">This can be accomplished using code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="3d4d3-355">이러한 이벤트 처리기에 대 한 코드는 `EfficientPaging.aspx` 예제의 코드 지향 클래스에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="3d4d3-356">기본 페이징 및 사용자 지정 페이징의 성능 비교</span><span class="sxs-lookup"><span data-stu-id="3d4d3-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="3d4d3-357">사용자 지정 페이징은 필요한 레코드만 검색 하는 반면 기본 페이징은 표시 되는 각 페이지에 대 한 *모든* 레코드를 반환 하는 반면, 사용자 지정 페이징은 기본 페이징 보다 더 효율적 이라는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="3d4d3-358">그러나 사용자 지정 페이징의 효율성은 얼마 인가요?</span><span class="sxs-lookup"><span data-stu-id="3d4d3-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="3d4d3-359">기본 페이징을 사용자 지정 페이징으로 이동 하 여 어떤 종류의 성능 향상을 볼 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="3d4d3-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="3d4d3-360">아쉽게도 모든 답에 맞는 한 가지 크기는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="3d4d3-361">성능 향상은 많은 요인에 따라 달라 지 며, 가장 두드러진 두 가지는 페이징할 수 있는 레코드 수와 데이터베이스 서버에 배치 되는 부하 및 웹 서버와 데이터베이스 서버 간의 통신 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="3d4d3-362">수십 개의 레코드가 포함 된 작은 테이블의 경우 성능 차이는 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="3d4d3-363">수천 개에서 수백 개의 행을 포함 하는 큰 테이블의 경우 성능 차이는 음입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="3d4d3-364">[SQL Server 2005를 사용 하는 ASP.NET 2.0의 사용자 지정 페이징이](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)포함 된 문서에는 5만 레코드를 사용 하 여 데이터베이스 테이블을 페이징할 때 이러한 두 페이징 기술 간의 성능 차이를 보이는 몇 가지 성능 테스트가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="3d4d3-365">이러한 테스트에서는 [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)를 사용 하 여 SQL Server 수준에서 쿼리를 실행 하 고 [ASP.NET s 추적 기능](https://msdn.microsoft.com/library/y13fw6we.aspx)을 사용 하는 ASP.NET 페이지에서 쿼리를 실행 하는 시간을 모두 검사 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="3d4d3-366">이러한 테스트는 단일 활성 사용자로 개발 상자에서 실행 되었으며 일반적인 웹 사이트 로드 패턴을 모방 하지 unscientific.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="3d4d3-367">상관 없이 결과는 충분 한 양의 데이터로 작업할 때의 기본 및 사용자 지정 페이징에 대 한 실행 시간의 상대적 차이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="3d4d3-368">**평균 기간 (초)**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="3d4d3-369">**Reads**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3d4d3-370">**기본 페이징 SQL 프로파일러**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="3d4d3-371">1.411</span><span class="sxs-lookup"><span data-stu-id="3d4d3-371">1.411</span></span> | <span data-ttu-id="3d4d3-372">383</span><span class="sxs-lookup"><span data-stu-id="3d4d3-372">383</span></span> |
| <span data-ttu-id="3d4d3-373">**사용자 지정 페이징 SQL 프로파일러**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="3d4d3-374">0.002</span><span class="sxs-lookup"><span data-stu-id="3d4d3-374">0.002</span></span> | <span data-ttu-id="3d4d3-375">29</span><span class="sxs-lookup"><span data-stu-id="3d4d3-375">29</span></span> |
| <span data-ttu-id="3d4d3-376">**기본 페이징 ASP.NET 추적**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="3d4d3-377">2.379</span><span class="sxs-lookup"><span data-stu-id="3d4d3-377">2.379</span></span> | <span data-ttu-id="3d4d3-378">*해당 사항 없음*</span><span class="sxs-lookup"><span data-stu-id="3d4d3-378">*N/A*</span></span> |
| <span data-ttu-id="3d4d3-379">**사용자 지정 페이징 ASP.NET 추적**</span><span class="sxs-lookup"><span data-stu-id="3d4d3-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="3d4d3-380">0.029</span><span class="sxs-lookup"><span data-stu-id="3d4d3-380">0.029</span></span> | <span data-ttu-id="3d4d3-381">*해당 사항 없음*</span><span class="sxs-lookup"><span data-stu-id="3d4d3-381">*N/A*</span></span> |

<span data-ttu-id="3d4d3-382">여기에서 볼 수 있듯이 데이터의 특정 페이지를 검색 하는 데는 평균적으로 평균을 354 하 고 시간을 단축 하 여 완료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="3d4d3-383">ASP.NET 페이지에서 사용자 지정 페이지는 기본 페이징을 사용 하는 경우 발생 하는 시간<sup>을 1/100 이상으로 렌더링할</sup> 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="3d4d3-384">사용자 환경에서 이러한 테스트를 재현 하기 위해 다운로드할 수 있는 코드 및 데이터베이스와 함께 이러한 결과에 대 한 자세한 내용은 [my 문서](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="3d4d3-385">요약</span><span class="sxs-lookup"><span data-stu-id="3d4d3-385">Summary</span></span>

<span data-ttu-id="3d4d3-386">기본 페이징은 데이터 웹 컨트롤의 스마트 태그에서 페이징 사용 확인란을 선택 하는 것만을 구현 하는 cinch, 이러한 단순성은 성능 비용으로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="3d4d3-387">기본 페이징을 사용 하는 경우 사용자가 데이터 페이지를 요청 하면 그 중 일부만 표시 될 수 있지만 *모든* 레코드가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="3d4d3-388">이 성능 오버 헤드를 줄이기 위해 ObjectDataSource는 대체 페이징 옵션인 사용자 지정 페이징을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="3d4d3-389">사용자 지정 페이징이 표시 되어야 하는 레코드만 검색 하 여 기본 페이징의 성능 문제를 개선 하는 반면, 사용자 지정 페이징을 구현 하는 데 더 많은 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="3d4d3-390">먼저 요청 된 레코드의 특정 하위 집합에 올바르게 액세스 하는 쿼리를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="3d4d3-391">여러 가지 방법으로이를 수행할 수 있습니다. 이 자습서에서 검토 한 내용은 SQL Server 2005 s new `ROW_NUMBER()` 함수를 사용 하 여 결과의 순위를 지정한 다음 순위가 지정 된 범위 내에 속하는 결과만 반환 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="3d4d3-392">또한 페이지를 통해 전체 레코드 수를 확인 하는 수단을 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="3d4d3-393">이러한 DAL 및 BLL 메서드를 만든 후에는 ObjectDataSource를 구성 하 여 총 레코드 수를 페이징 하는 방법을 결정 하 고 시작 행 인덱스 및 최대 행 값을 BLL에 올바르게 전달할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="3d4d3-394">사용자 지정 페이징을 구현 하는 경우에는 몇 가지 단계가 필요 하며 기본 페이징 만큼 간단 하지는 않지만, 사용자 지정 페이징은 충분히 많은 양의 데이터를 페이징할 때 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="3d4d3-395">결과를 검사 한 결과, 사용자 지정 페이징은 ASP.NET 페이지 렌더링 시간에서 초를 10 배까지 사용할 수 있으며 데이터베이스 서버에 대 한 부하를 한 번 더 더 크게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="3d4d3-396">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="3d4d3-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="3d4d3-397">저자 정보</span><span class="sxs-lookup"><span data-stu-id="3d4d3-397">About the Author</span></span>

<span data-ttu-id="3d4d3-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="3d4d3-399">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="3d4d3-400">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="3d4d3-401">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="3d4d3-402">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d4d3-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="3d4d3-403">[이전](paging-and-sorting-report-data-vb.md)
> [다음](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="3d4d3-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
