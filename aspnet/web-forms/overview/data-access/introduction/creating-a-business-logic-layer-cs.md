---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
title: 비즈니스 논리 레이어 (C#) 만들기 | Microsoft Docs
author: rick-anderson
description: 이 자습서에는 계층 BLL (비즈니스 논리) t 간의 데이터 교환 위한 중간자로 사용 되는 비즈니스 규칙에 중앙 집중화 하는 방법을 살펴보겠습니다...
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 85554606-47cb-4e4f-9848-eed9da579056
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
msc.type: authoredcontent
ms.openlocfilehash: c0278841b7b0701f09b2de5115e06da87aed49cf
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/06/2019
ms.locfileid: "65109031"
---
# <a name="creating-a-business-logic-layer-c"></a><span data-ttu-id="acd21-103">비즈니스 논리 레이어 만들기(C#)</span><span class="sxs-lookup"><span data-stu-id="acd21-103">Creating a Business Logic Layer (C#)</span></span>

<span data-ttu-id="acd21-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="acd21-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="acd21-105">[샘플 앱을 다운로드](http://download.microsoft.com/download/4/6/3/463cf87c-4724-4cbc-b7b5-3f866f43ba50/ASPNET_Data_Tutorial_2_CS.exe) 또는 [PDF 다운로드](creating-a-business-logic-layer-cs/_static/datatutorial02cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="acd21-105">[Download Sample App](http://download.microsoft.com/download/4/6/3/463cf87c-4724-4cbc-b7b5-3f866f43ba50/ASPNET_Data_Tutorial_2_CS.exe) or [Download PDF](creating-a-business-logic-layer-cs/_static/datatutorial02cs1.pdf)</span></span>

> <span data-ttu-id="acd21-106">이 자습서에는 계층 BLL (비즈니스 논리) 프레젠테이션 계층과 DAL 간의 데이터 교환 위한 중간자로 사용 되는 비즈니스 규칙에 중앙 집중화 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-106">In this tutorial we'll see how to centralize your business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span>

## <a name="introduction"></a><span data-ttu-id="acd21-107">소개</span><span class="sxs-lookup"><span data-stu-id="acd21-107">Introduction</span></span>

<span data-ttu-id="acd21-108">(DAL (데이터 액세스 계층)에서 만든 합니다 [첫 번째 자습서](creating-a-data-access-layer-cs.md) 프레젠테이션 논리에서 논리를 액세스 하는 데이터를 명확 하 게 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-108">The Data Access Layer (DAL) created in the [first tutorial](creating-a-data-access-layer-cs.md) cleanly separates the data access logic from the presentation logic.</span></span> <span data-ttu-id="acd21-109">그러나 DAL 프레젠테이션 계층에서 데이터 액세스 세부 정보를 명확 하 게 구분을 하는 동안 적용 될 수 있는 모든 비즈니스 규칙 적용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-109">However, while the DAL cleanly separates the data access details from the presentation layer, it does not enforce any business rules that may apply.</span></span> <span data-ttu-id="acd21-110">예를 들어, 응용 프로그램에서는 허용 하지 않을 수는 `CategoryID` 또는 `SupplierID` 필드를 `Products` 수정할 때 테이블은 `Discontinued` 필드를 1로 설정 하거나 하고자 할 수 있습니다 이라는 규칙을 적용 하는 경우를 금지는 직원 하 고용 된 사람에 의해 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-110">For example, for our application we may want to disallow the `CategoryID` or `SupplierID` fields of the `Products` table to be modified when the `Discontinued` field is set to 1, or we might want to enforce seniority rules, prohibiting situations in which an employee is managed by someone who was hired after them.</span></span> <span data-ttu-id="acd21-111">또 다른 일반적인 시나리오는 특정 역할에 사용자를 가장만 권한 부여 제품 삭제 하거나 변경할 수는 `UnitPrice` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-111">Another common scenario is authorization perhaps only users in a particular role can delete products or can change the `UnitPrice` value.</span></span>

<span data-ttu-id="acd21-112">이 자습서에는 계층 BLL (비즈니스 논리) 프레젠테이션 계층과 DAL 간의 데이터 교환 위한 중간자로 사용 되는 이러한 비즈니스 규칙에 중앙 집중화 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-112">In this tutorial we'll see how to centralize these business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span> <span data-ttu-id="acd21-113">실제 응용 프로그램에서는 별도 클래스 라이브러리 프로젝트로; BLL은 구현 그러나이 자습서에 대 한 구현 하겠습니다 BLL 일련의 클래스는 `App_Code` 프로젝트 구조를 단순화 하기 위해 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-113">In a real-world application, the BLL should be implemented as a separate Class Library project; however, for these tutorials we'll implement the BLL as a series of classes in our `App_Code` folder in order to simplify the project structure.</span></span> <span data-ttu-id="acd21-114">그림 1에서는 프레젠테이션 계층, BLL 및 DAL 간의 아키텍처 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-114">Figure 1 illustrates the architectural relationships among the presentation layer, BLL, and DAL.</span></span>

![BLL은 데이터 액세스 계층에서 프레젠테이션 계층을 분리 하 고 비즈니스 규칙 적용](creating-a-business-logic-layer-cs/_static/image1.png)

<span data-ttu-id="acd21-116">**그림 1**: BLL은 데이터 액세스 계층에서 프레젠테이션 계층을 분리 하 고 비즈니스 규칙 적용</span><span class="sxs-lookup"><span data-stu-id="acd21-116">**Figure 1**: The BLL Separates the Presentation Layer from the Data Access Layer and Imposes Business Rules</span></span>

## <a name="step-1-creating-the-bll-classes"></a><span data-ttu-id="acd21-117">1단계: BLL 클래스 만들기</span><span class="sxs-lookup"><span data-stu-id="acd21-117">Step 1: Creating the BLL Classes</span></span>

<span data-ttu-id="acd21-118">이 BLL은 DAL;에서 각 TableAdapter에 대해 하나씩 네 개의 클래스 구성 각 클래스 BLL는 메서드를 검색, 삽입, 업데이트 및 적절 한 비즈니스 규칙을 적용 하는 DAL에서 해당 TableAdapter에서 삭제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-118">Our BLL will be composed of four classes, one for each TableAdapter in the DAL; each of these BLL classes will have methods for retrieving, inserting, updating, and deleting from the respective TableAdapter in the DAL, applying the appropriate business rules.</span></span>

<span data-ttu-id="acd21-119">두 개의 하위 폴더를 만들어 보겠습니다을 보다 명확 하 게 DAL 및 BLL에 관련 된 클래스를 구분 합니다 `App_Code` 폴더를 `DAL` 및 `BLL`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-119">To more cleanly separate the DAL- and BLL-related classes, let's create two subfolders in the `App_Code` folder, `DAL` and `BLL`.</span></span> <span data-ttu-id="acd21-120">오른쪽 단추로 클릭 하면는 `App_Code` 솔루션 탐색기에서 폴더 및 새 폴더를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-120">Simply right-click on the `App_Code` folder in the Solution Explorer and choose New Folder.</span></span> <span data-ttu-id="acd21-121">이러한 두 개의 폴더를 만든 후에 첫 번째 자습서에서 만든 형식화 된 데이터 집합을 이동 합니다 `DAL` 하위 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-121">After creating these two folders, move the Typed DataSet created in the first tutorial into the `DAL` subfolder.</span></span>

<span data-ttu-id="acd21-122">다음으로, 네 개의 BLL 클래스 파일을 만듭니다는 `BLL` 하위 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-122">Next, create the four BLL class files in the `BLL` subfolder.</span></span> <span data-ttu-id="acd21-123">이렇게 하려면 마우스 오른쪽 단추로 클릭는 `BLL` 하위 폴더에 새 항목 추가 선택 하 고 클래스 템플릿을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-123">To accomplish this, right-click on the `BLL` subfolder, choose Add a New Item, and choose the Class template.</span></span> <span data-ttu-id="acd21-124">4 개 클래스의 이름을 `ProductsBLL`, `CategoriesBLL`를 `SuppliersBLL`, 및 `EmployeesBLL`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-124">Name the four classes `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`, and `EmployeesBLL`.</span></span>

![App_Code 폴더에 4 개의 새 클래스 추가](creating-a-business-logic-layer-cs/_static/image2.png)

<span data-ttu-id="acd21-126">**그림 2**: 4 개의 새 클래스를 추가 합니다 `App_Code` 폴더</span><span class="sxs-lookup"><span data-stu-id="acd21-126">**Figure 2**: Add Four New Classes to the `App_Code` Folder</span></span>

<span data-ttu-id="acd21-127">다음으로, 첫 번째 자습서에서 Tableadapter에 대 한 정의 된 메서드를 래핑하는 클래스의 각 메서드를 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-127">Next, let's add methods to each of the classes to simply wrap the methods defined for the TableAdapters from the first tutorial.</span></span> <span data-ttu-id="acd21-128">이제 이러한 메서드를 호출 하면 직접 DAL; 나중에 필요한 비즈니스 논리 추가 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-128">For now, these methods will just call directly into the DAL; we'll return later to add any needed business logic.</span></span>

> [!NOTE]
> <span data-ttu-id="acd21-129">Visual Studio Standard Edition을 사용 하는 경우 또는 위의 (즉, 여러분이 *하지* Visual Web Developer를 사용 하 여), 필요에 따라 시각적으로 사용 하 여 클래스를 디자인할 수 있습니다를 [클래스 디자이너](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-129">If you are using Visual Studio Standard Edition or above (that is, you're *not* using Visual Web Developer), you can optionally design your classes visually using the [Class Designer](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp).</span></span> <span data-ttu-id="acd21-130">참조 된 [클래스 디자이너 블로그](https://blogs.msdn.com/classdesigner/default.aspx) Visual Studio에서이 새로운 기능에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-130">Refer to the [Class Designer Blog](https://blogs.msdn.com/classdesigner/default.aspx) for more information on this new feature in Visual Studio.</span></span>

<span data-ttu-id="acd21-131">에 대 한는 `ProductsBLL` 클래스는 총 7 개의 메서드를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-131">For the `ProductsBLL` class we need to add a total of seven methods:</span></span>

- <span data-ttu-id="acd21-132">`GetProducts()` 모든 제품을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-132">`GetProducts()` returns all products</span></span>
- <span data-ttu-id="acd21-133">`GetProductByProductID(productID)` 지정 된 제품 ID 사용 하 여 곱을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-133">`GetProductByProductID(productID)` returns the product with the specified product ID</span></span>
- <span data-ttu-id="acd21-134">`GetProductsByCategoryID(categoryID)` 지정 된 범주의 모든 제품을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-134">`GetProductsByCategoryID(categoryID)` returns all products from the specified category</span></span>
- <span data-ttu-id="acd21-135">`GetProductsBySupplier(supplierID)` 지정 된 공급자 로부터 모든 제품을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-135">`GetProductsBySupplier(supplierID)` returns all products from the specified supplier</span></span>
- <span data-ttu-id="acd21-136">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` 값을 사용 하 여 데이터베이스에 새 제품을 삽입 전달 인; 반환 된 `ProductID` 새로 삽입된 된 레코드의 값</span><span class="sxs-lookup"><span data-stu-id="acd21-136">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` inserts a new product into the database using the values passed-in; returns the `ProductID` value of the newly inserted record</span></span>
- <span data-ttu-id="acd21-137">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` 전달 된 값을 사용 하 여 데이터베이스에서 기존 제품 업데이트 반환 `true` 행씩 정확 하 게 업데이트 된 경우 `false` 그렇지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="acd21-137">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` updates an existing product in the database using the passed-in values; returns `true` if precisely one row was updated, `false` otherwise</span></span>
- <span data-ttu-id="acd21-138">`DeleteProduct(productID)` 데이터베이스에서 지정된 된 제품 삭제</span><span class="sxs-lookup"><span data-stu-id="acd21-138">`DeleteProduct(productID)` deletes the specified product from the database</span></span>

<span data-ttu-id="acd21-139">ProductsBLL.cs</span><span class="sxs-lookup"><span data-stu-id="acd21-139">ProductsBLL.cs</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample1.cs)]

<span data-ttu-id="acd21-140">단순히 데이터를 반환 하는 메서드가 `GetProducts`, `GetProductByProductID`를 `GetProductsByCategoryID`, 및 `GetProductBySuppliersID` 단순히를 호출 하므로 DAL에는 매우 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-140">The methods that simply return data `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`, and `GetProductBySuppliersID` are fairly straightforward as they simply call down into the DAL.</span></span> <span data-ttu-id="acd21-141">일부 시나리오에서는 있을 구현 해야 하는 비즈니스 규칙 (예: 현재 로그온된 한 사용자 또는 사용자가 속해 있는 역할 기반 권한 부여 규칙)이 수준에서 단순히 보면 이러한 메서드-됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-141">While in some scenarios there may be business rules that need to be implemented at this level (such as authorization rules based on the currently logged on user or the role to which the user belongs), we'll simply leave these methods as-is.</span></span> <span data-ttu-id="acd21-142">이러한 메서드의 그런 다음 BLL 단순히 프록시의 역할을 하는 프레젠테이션 계층 데이터 액세스 계층에서 기본 데이터에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-142">For these methods, then, the BLL serves merely as a proxy through which the presentation layer accesses the underlying data from the Data Access Layer.</span></span>

<span data-ttu-id="acd21-143">합니다 `AddProduct` 고 `UpdateProduct` 메서드 모두 매개 변수로 제품의 다양 한 필드의 값 및 새 제품을 추가 하거나 기존 각각 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-143">The `AddProduct` and `UpdateProduct` methods both take in as parameters the values for the various product fields and add a new product or update an existing one, respectively.</span></span> <span data-ttu-id="acd21-144">다양 한 이후 합니다 `Product` 테이블의 열을 사용할 수 있습니다 `NULL` 값 (`CategoryID`를 `SupplierID`, 및 `UnitPrice`, 등), 해당 입력에 대 한 매개 변수 `AddProduct` 및 `UpdateProduct` 사용할열에매핑되는[nullable 형식](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-144">Since many of the `Product` table's columns can accept `NULL` values (`CategoryID`, `SupplierID`, and `UnitPrice`, to name a few), those input parameters for `AddProduct` and `UpdateProduct` that map to such columns use [nullable types](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx).</span></span> <span data-ttu-id="acd21-145">Nullable 형식에.NET 2.0 및 여부를 나타내는 여부를 값 형식, 대신에 기술을 제공 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-145">Nullable types are new to .NET 2.0 and provide a technique for indicating whether a value type should, instead, be `null`.</span></span> <span data-ttu-id="acd21-146">C#에서 플래그를 수 값 형식을 nullable 형식으로 추가 하 여 `?` 는 형식 (같은 `int? x;`).</span><span class="sxs-lookup"><span data-stu-id="acd21-146">In C# you can flag a value type as a nullable type by adding `?` after the type (like `int? x;`).</span></span> <span data-ttu-id="acd21-147">참조를 [Nullable 형식](https://msdn.microsoft.com/library/1t3y8s4s.aspx) 섹션을 [C# 프로그래밍 가이드](https://msdn.microsoft.com/library/67ef8sbd%28VS.80%29.aspx) 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-147">Refer to the [Nullable Types](https://msdn.microsoft.com/library/1t3y8s4s.aspx) section in the [C# Programming Guide](https://msdn.microsoft.com/library/67ef8sbd%28VS.80%29.aspx) for more information.</span></span>

<span data-ttu-id="acd21-148">세 가지 방법을 모두 행 된 삽입, 업데이트 또는 삭제 작업이 영향을 받는 행을 얻을 수 없습니다 때문에 있는지 여부를 나타내는 부울 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-148">All three methods return a Boolean value indicating whether a row was inserted, updated, or deleted since the operation may not result in an affected row.</span></span> <span data-ttu-id="acd21-149">예를 들어, 페이지 개발자 호출 하는 경우 `DeleteProduct` 전달를 `ProductID` 존재 하지 않는 제품에 대 한 합니다 `DELETE` 데이터베이스에 실행 된 문이 아무 영향도 주지 것입니다 있어를 `DeleteProduct` 메서드는 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-149">For example, if the page developer calls `DeleteProduct` passing in a `ProductID` for a non-existent product, the `DELETE` statement issued to the database will have no affect and therefore the `DeleteProduct` method will return `false`.</span></span>

<span data-ttu-id="acd21-150">새 제품을 추가할 때 또는 기존 업데이트에서는 변수로 새롭거나 수정 된 제품의 필드 값의 목록을 수락 하는 대신 스칼라를 `ProductsRow` 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="acd21-150">Note that when adding a new product or updating an existing one we take in the new or modified product's field values as a list of scalars as opposed to accepting a `ProductsRow` instance.</span></span> <span data-ttu-id="acd21-151">때문에이 접근 방식을 선택 했습니다 합니다 `ProductsRow` ADO.NET에서 파생 되는 클래스 `DataRow` 클래스를 기본 매개 변수가 없는 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-151">This approach was chosen because the `ProductsRow` class derives from the ADO.NET `DataRow` class, which doesn't have a default parameterless constructor.</span></span> <span data-ttu-id="acd21-152">새 만들려면 `ProductsRow` 인스턴스를 먼저 만들어야 합니다를 `ProductsDataTable` 인스턴스 및 기능을 호출 해당 `NewProductRow()` 메서드 (에서 수행 하는 `AddProduct`).</span><span class="sxs-lookup"><span data-stu-id="acd21-152">In order to create a new `ProductsRow` instance, we must first create a `ProductsDataTable` instance and then invoke its `NewProductRow()` method (which we do in `AddProduct`).</span></span> <span data-ttu-id="acd21-153">이러한 단점 삽입 및 ObjectDataSource를 사용 하 여 제품 업데이트를 설정 하는 경우 견과류를 rears 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-153">This shortcoming rears its head when we turn to inserting and updating products using the ObjectDataSource.</span></span> <span data-ttu-id="acd21-154">즉, ObjectDataSource 입력된 매개 변수의 인스턴스를 만들 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-154">In short, the ObjectDataSource will try to create an instance of the input parameters.</span></span> <span data-ttu-id="acd21-155">BLL 메서드를 필요로 하는 경우는 `ProductsRow` 들어 ObjectDataSource 하려고 만든 하지만 기본 매개 변수가 없는 생성자의 부족으로 인해 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-155">If the BLL method expects a `ProductsRow` instance, the ObjectDataSource will try to create one, but fail due to the lack of a default parameterless constructor.</span></span> <span data-ttu-id="acd21-156">이 문제에 대 한 자세한 내용은 다음 두 ASP.NET 포럼 게시물을 참조 합니다. [업데이트 된 경우, ObjectDataSources 강력한 형식의 데이터 집합](https://forums.asp.net/1098630/ShowPost.aspx), 및 [ObjectDataSource와 강력한 형식의 DataSet 문제](https://forums.asp.net/1048212/ShowPost.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-156">For more information on this problem, refer to the following two ASP.NET Forums posts: [Updating ObjectDataSources with Strongly-Typed DataSets](https://forums.asp.net/1098630/ShowPost.aspx), and [Problem With ObjectDataSource and Strongly-Typed DataSet](https://forums.asp.net/1048212/ShowPost.aspx).</span></span>

<span data-ttu-id="acd21-157">둘 다에서 다음 `AddProduct` 하 고 `UpdateProduct`, 코드를 만듭니다를 `ProductsRow` 인스턴스 하 고 바로 전달 되는 값으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-157">Next, in both `AddProduct` and `UpdateProduct`, the code creates a `ProductsRow` instance and populates it with the values just passed in.</span></span> <span data-ttu-id="acd21-158">Datacolumns DataRow의 값을 할당할 때 다양 한 필드 수준 유효성 검사가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-158">When assigning values to DataColumns of a DataRow various field-level validation checks can occur.</span></span> <span data-ttu-id="acd21-159">따라서 수동으로 DataRow에 전달 된 값을 다시 설치 하면 BLL 메서드에 전달 되는 데이터의 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-159">Therefore, manually putting the passed in values back into a DataRow helps ensure the validity of the data being passed to the BLL method.</span></span> <span data-ttu-id="acd21-160">그러나 Visual Studio에서 생성 된 강력한 형식의 DataRow 클래스는 nullable 형식 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="acd21-160">Unfortunately the strongly-typed DataRow classes generated by Visual Studio do not use nullable types.</span></span> <span data-ttu-id="acd21-161">대신 나타내는 DataRow의 특정 DataColumn 일치 해야 하는 `NULL` 데이터베이스 값을 사용 해야 합니다는 `SetColumnNameNull()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="acd21-161">Rather, to indicate that a particular DataColumn in a DataRow should correspond to a `NULL` database value we must use the `SetColumnNameNull()` method.</span></span>

<span data-ttu-id="acd21-162">`UpdateProduct` 제품에 사용 하 여 업데이트를 먼저 로드 `GetProductByProductID(productID)`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-162">In `UpdateProduct` we first load in the product to update using `GetProductByProductID(productID)`.</span></span> <span data-ttu-id="acd21-163">이 데이터베이스에는 불필요 한 여정 처럼 보일 수 있지만,이 추가로 이동은 낙관적 동시성을 탐색 하는 이후 자습서에서 유용한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-163">While this may seem like an unnecessary trip to the database, this extra trip will prove worthwhile in future tutorials that explore optimistic concurrency.</span></span> <span data-ttu-id="acd21-164">낙관적 동시성은 작업 하는 동시에 동일한 데이터에서 두 명의 사용자가 서로의 변경을 실수로 덮어쓰지는 확인 하는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-164">Optimistic concurrency is a technique to ensure that two users who are simultaneously working on the same data don't accidentally overwrite one another's changes.</span></span> <span data-ttu-id="acd21-165">전체 레코드를 클릭 한 다음도 쉽게만 DataRow의 열 하위 집합을 수정 하는 BLL에 업데이트 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-165">Grabbing the entire record also makes it easier to create update methods in the BLL that only modify a subset of the DataRow's columns.</span></span> <span data-ttu-id="acd21-166">탐색 하는 것은 `SuppliersBLL` 클래스는 예를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-166">When we explore the `SuppliersBLL` class we'll see such an example.</span></span>

<span data-ttu-id="acd21-167">마지막으로, 이때를 `ProductsBLL` 클래스에는 [DataObject 특성](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) 적용 (는 `[System.ComponentModel.DataObject]` 구문 파일의 위쪽 class 문 바로 앞) 메서드가 있고 [ DataObjectMethodAttribute 특성](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-167">Finally, note that the `ProductsBLL` class has the [DataObject attribute](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) applied to it (the `[System.ComponentModel.DataObject]` syntax right before the class statement near the top of the file) and the methods have [DataObjectMethodAttribute attributes](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx).</span></span> <span data-ttu-id="acd21-168">합니다 `DataObject` 특성 클래스는 개체에 대 한 바인딩에 적합 한 것으로 표시를 [ObjectDataSource 컨트롤](https://msdn.microsoft.com/library/9a4kyhcx.aspx)반면는 `DataObjectMethodAttribute` 메서드의 용도 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-168">The `DataObject` attribute marks the class as being an object suitable for binding to an [ObjectDataSource control](https://msdn.microsoft.com/library/9a4kyhcx.aspx), whereas the `DataObjectMethodAttribute` indicates the purpose of the method.</span></span> <span data-ttu-id="acd21-169">앞으로 살펴보겠지만 나중에 자습서에서 ASP.NET 2.0 ObjectDataSource 쉽게 클래스에서 데이터를 선언적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-169">As we'll see in future tutorials, ASP.NET 2.0's ObjectDataSource makes it easy to declaratively access data from a class.</span></span> <span data-ttu-id="acd21-170">ObjectDataSource의 마법사에서 바인딩할 가능한 클래스 목록 필터링을 위해 기본적으로 표시 하는 클래스에만 `DataObjects` 마법사의 드롭다운 목록에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-170">To help filter the list of possible classes to bind to in the ObjectDataSource's wizard, by default only those classes marked as `DataObjects` are shown in the wizard's drop-down list.</span></span> <span data-ttu-id="acd21-171">`ProductsBLL` 클래스는 이러한 특성이 없는 경우와 마찬가지로 작동 하지만 ObjectDataSource의 마법사에서 작업을 쉽게 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-171">The `ProductsBLL` class will work just as well without these attributes, but adding them makes it easier to work with in the ObjectDataSource's wizard.</span></span>

## <a name="adding-the-other-classes"></a><span data-ttu-id="acd21-172">다른 클래스를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-172">Adding the Other Classes</span></span>

<span data-ttu-id="acd21-173">사용 하 여는 `ProductsBLL` 클래스 완료 해야 작업 범주, 공급 업체 및 직원을 위한 클래스를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-173">With the `ProductsBLL` class complete, we still need to add the classes for working with categories, suppliers, and employees.</span></span> <span data-ttu-id="acd21-174">시간을 내어 다음 클래스와 위의 예제에서 개념을 사용 하 여 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-174">Take a moment to create the following classes and methods using the concepts from the example above:</span></span>

- <span data-ttu-id="acd21-175">**CategoriesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="acd21-175">**CategoriesBLL.cs**</span></span>

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- <span data-ttu-id="acd21-176">**SuppliersBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="acd21-176">**SuppliersBLL.cs**</span></span>

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- <span data-ttu-id="acd21-177">**EmployeesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="acd21-177">**EmployeesBLL.cs**</span></span>

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

<span data-ttu-id="acd21-178">주목할 만한 한 가지 방법은 합니다 `SuppliersBLL` 클래스의 `UpdateSupplierAddress` 메서드.</span><span class="sxs-lookup"><span data-stu-id="acd21-178">The one method worth noting is the `SuppliersBLL` class's `UpdateSupplierAddress` method.</span></span> <span data-ttu-id="acd21-179">이 메서드는 방금 공급자의 주소 정보를 업데이트 하는 것에 대 한 인터페이스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-179">This method provides an interface for updating just the supplier's address information.</span></span> <span data-ttu-id="acd21-180">이 메서드는 내부적으로 읽습니다 합니다 `SupplierDataRow` 지정 된 개체 `supplierID` (사용 하 여 `GetSupplierBySupplierID`), 주소 관련 속성을 설정 하 고 다음에 호출 합니다 `SupplierDataTable`의 `Update` 메서드.</span><span class="sxs-lookup"><span data-stu-id="acd21-180">Internally, this method reads in the `SupplierDataRow` object for the specified `supplierID` (using `GetSupplierBySupplierID`), sets its address-related properties, and then calls down into the `SupplierDataTable`'s `Update` method.</span></span> <span data-ttu-id="acd21-181">`UpdateSupplierAddress` 메서드 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-181">The `UpdateSupplierAddress` method follows:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample2.cs)]

<span data-ttu-id="acd21-182">전체 구현은 클래스 BLL에 대 한이 기사의 다운로드를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="acd21-182">Refer to this article's download for my complete implementation of the BLL classes.</span></span>

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a><span data-ttu-id="acd21-183">2단계: BLL 클래스를 통해 형식화 된 데이터 집합에 액세스</span><span class="sxs-lookup"><span data-stu-id="acd21-183">Step 2: Accessing the Typed DataSets Through the BLL Classes</span></span>

<span data-ttu-id="acd21-184">첫 번째 자습서에 대 한 예제를 직접 입력 데이터 집합을 사용 하 여 프로그래밍 방식으로 살펴보았습니다 있지만 클래스 BLL 추가 하 여 프레젠테이션 계층을 사용할 BLL에 대해 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-184">In the first tutorial we saw examples of working directly with the Typed DataSet programmatically, but with the addition of our BLL classes, the presentation tier should work against the BLL instead.</span></span> <span data-ttu-id="acd21-185">에 `AllProducts.aspx` 첫 번째 자습서의 예제는 `ProductsTableAdapter` 다음 코드에 표시 된 대로 제품 목록의 GridView에 바인딩하는 데 사용 되었습니다:</span><span class="sxs-lookup"><span data-stu-id="acd21-185">In the `AllProducts.aspx` example from the first tutorial, the `ProductsTableAdapter` was used to bind the list of products to a GridView, as shown in the following code:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample3.cs)]

<span data-ttu-id="acd21-186">새 BLL을 사용 하도록 변경 해야 하는 모든 클래스는 코드의 첫 번째 줄 바꾸기만 합니다 `ProductsTableAdapter` 개체를 `ProductBLL` 개체:</span><span class="sxs-lookup"><span data-stu-id="acd21-186">To use the new BLL classes, all that needs to be changed is the first line of code simply replace the `ProductsTableAdapter` object with a `ProductBLL` object:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample4.cs)]

<span data-ttu-id="acd21-187">ObjectDataSource를 사용 하 여 클래스 BLL를 선언적 (입력 데이터 집합 수)으로 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-187">The BLL classes can also be accessed declaratively (as can the Typed DataSet) by using the ObjectDataSource.</span></span> <span data-ttu-id="acd21-188">살펴보겠습니다. 자세히 ObjectDataSource를 다음 자습서에서입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-188">We'll be discussing the ObjectDataSource in greater detail in the following tutorials.</span></span>

<span data-ttu-id="acd21-189">[![제품 목록 GridView에 표시 됩니다.](creating-a-business-logic-layer-cs/_static/image4.png)](creating-a-business-logic-layer-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="acd21-189">[![The List of Products is Displayed in a GridView](creating-a-business-logic-layer-cs/_static/image4.png)](creating-a-business-logic-layer-cs/_static/image3.png)</span></span>

<span data-ttu-id="acd21-190">**그림 3**: 제품 목록 GridView에 표시 됩니다 ([클릭 하 여 큰 이미지 보기](creating-a-business-logic-layer-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="acd21-190">**Figure 3**: The List of Products is Displayed in a GridView ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image5.png))</span></span>

## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a><span data-ttu-id="acd21-191">3단계: DataRow 클래스에 필드 수준 유효성 검사 추가</span><span class="sxs-lookup"><span data-stu-id="acd21-191">Step 3: Adding Field-Level Validation to the DataRow Classes</span></span>

<span data-ttu-id="acd21-192">필드 수준 유효성 검사를 삽입 하거나 업데이트할 때 비즈니스 개체의 속성 값에 관련 된 검사</span><span class="sxs-lookup"><span data-stu-id="acd21-192">Field-level validation are checks that pertains to the property values of the business objects when inserting or updating.</span></span> <span data-ttu-id="acd21-193">제품에 대 한 몇 가지 필드 수준 유효성 검사 규칙은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-193">Some field-level validation rules for products include:</span></span>

- <span data-ttu-id="acd21-194">`ProductName` 필드는 40 자 이하의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-194">The `ProductName` field must be 40 characters or less in length</span></span>
- <span data-ttu-id="acd21-195">`QuantityPerUnit` 20 자 또는 길이가 필드 여야 합니다</span><span class="sxs-lookup"><span data-stu-id="acd21-195">The `QuantityPerUnit` field must be 20 characters or less in length</span></span>
- <span data-ttu-id="acd21-196">합니다 `ProductID`하십시오 `ProductName`, 및 `Discontinued` 필드는 필요 하지만 다른 모든 필드는 선택 사항</span><span class="sxs-lookup"><span data-stu-id="acd21-196">The `ProductID`, `ProductName`, and `Discontinued` fields are required, but all other fields are optional</span></span>
- <span data-ttu-id="acd21-197">합니다 `UnitPrice`, `UnitsInStock`를 `UnitsOnOrder`, 및 `ReorderLevel` 필드는 0 보다 크거나 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-197">The `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` fields must be greater than or equal to zero</span></span>

<span data-ttu-id="acd21-198">이러한 규칙을 데이터베이스 수준에서 표현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-198">These rules can and should be expressed at the database level.</span></span> <span data-ttu-id="acd21-199">문자 제한에는 `ProductName` 하 고 `QuantityPerUnit` 필드에 있는 해당 열의 데이터 형식에 의해 캡처되는 `Products` 테이블 (`nvarchar(40)` 및 `nvarchar(20)`각각).</span><span class="sxs-lookup"><span data-stu-id="acd21-199">The character limit on the `ProductName` and `QuantityPerUnit` fields are captured by the data types of those columns in the `Products` table (`nvarchar(40)` and `nvarchar(20)`, respectively).</span></span> <span data-ttu-id="acd21-200">데이터베이스 테이블 열에서 허용 하는 경우 여 표현 됩니다 필수 및 선택적 필드 되는지 `NULL` s입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-200">Whether fields are required and optional are expressed by if the database table column allows `NULL` s.</span></span> <span data-ttu-id="acd21-201">네 [check 제약 조건](https://msdn.microsoft.com/library/ms188258.aspx) 존재만 값 0 보다 크거나 같은 경우에 수행할 수 있는지를 확인 하는 합니다 `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, 또는 `ReorderLevel` 열입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-201">Four [check constraints](https://msdn.microsoft.com/library/ms188258.aspx) exist that ensure that only values greater than or equal to zero can make it into the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, or `ReorderLevel` columns.</span></span>

<span data-ttu-id="acd21-202">데이터베이스에서 이러한 규칙을 적용 하는 것 외에도 이러한도 적용할 데이터 집합 수준에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-202">In addition to enforcing these rules at the database they should also be enforced at the DataSet level.</span></span> <span data-ttu-id="acd21-203">사실, 필드 길이 및 값이 필수 또는 선택적인 이미 각 데이터 테이블의 DataColumns 집합에 대 한 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-203">In fact, the field length and whether a value is required or optional are already captured for each DataTable's set of DataColumns.</span></span> <span data-ttu-id="acd21-204">자동으로 제공 하는 기존 필드 수준 유효성 검사를 확인 하려면 디자이너로 이동 하 여 데이터 집합, 하나는 Datatable에서 필드를 선택 하 고 속성 창에 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-204">To see the existing field-level validation automatically provided, go to the DataSet Designer, select a field from one of the DataTables and then go to the Properties window.</span></span> <span data-ttu-id="acd21-205">그림 4에서 알 수 있듯이, 합니다 `QuantityPerUnit` DataColumn의 합니다 `ProductsDataTable` 최대 길이가 20 자가 고 허용 않는 `NULL` 값.</span><span class="sxs-lookup"><span data-stu-id="acd21-205">As Figure 4 shows, the `QuantityPerUnit` DataColumn in the `ProductsDataTable` has a maximum length of 20 characters and does allow `NULL` values.</span></span> <span data-ttu-id="acd21-206">설정 하려고 하는 경우는 `ProductsDataRow`의 `QuantityPerUnit` 20 자 보다 긴 문자열 값으로 속성을 `ArgumentException` throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-206">If we attempt to set the `ProductsDataRow`'s `QuantityPerUnit` property to a string value longer than 20 characters an `ArgumentException` will be thrown.</span></span>

<span data-ttu-id="acd21-207">[![DataColumn 기본 필드 수준 유효성 검사를 제공합니다.](creating-a-business-logic-layer-cs/_static/image7.png)](creating-a-business-logic-layer-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="acd21-207">[![The DataColumn Provides Basic Field-Level Validation](creating-a-business-logic-layer-cs/_static/image7.png)](creating-a-business-logic-layer-cs/_static/image6.png)</span></span>

<span data-ttu-id="acd21-208">**그림 4**: DataColumn 제공 기본 필드 수준 유효성 검사 ([클릭 하 여 큰 이미지 보기](creating-a-business-logic-layer-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="acd21-208">**Figure 4**: The DataColumn Provides Basic Field-Level Validation ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image8.png))</span></span>

<span data-ttu-id="acd21-209">안타깝게도 없습니다 지정 범위 검사와 같은 `UnitPrice` 속성 창을 통해 0 보다 크거나 값 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-209">Unfortunately, we can't specify bounds checks, such as the `UnitPrice` value must be greater than or equal to zero, through the Properties window.</span></span> <span data-ttu-id="acd21-210">이 형식의 필드 수준 유효성 검사를 제공 하기 위해 DataTable의에 대 한 이벤트 처리기를 생성 해야 [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-210">In order to provide this type of field-level validation we need to create an event handler for the DataTable's [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) event.</span></span> <span data-ttu-id="acd21-211">에 설명 된 대로 합니다 [이전 자습서](creating-a-data-access-layer-cs.md), partial 클래스를 사용 하 여 입력 데이터 집합에서 만든 데이터 집합, Datatable 및 DataRow 개체를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-211">As mentioned in the [preceding tutorial](creating-a-data-access-layer-cs.md), the DataSet, DataTables, and DataRow objects created by the Typed DataSet can be extended through the use of partial classes.</span></span> <span data-ttu-id="acd21-212">만들 수 있습니다이 기술을 사용 하는 `ColumnChanging` 에 대 한 이벤트 처리기는 `ProductsDataTable` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-212">Using this technique we can create a `ColumnChanging` event handler for the `ProductsDataTable` class.</span></span> <span data-ttu-id="acd21-213">클래스를 만들어 시작 합니다 `App_Code` 라는 폴더 `ProductsDataTable.ColumnChanging.cs`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-213">Start by creating a class in the `App_Code` folder named `ProductsDataTable.ColumnChanging.cs`.</span></span>

<span data-ttu-id="acd21-214">[![App_Code 폴더에 새 클래스를 추가 합니다.](creating-a-business-logic-layer-cs/_static/image10.png)](creating-a-business-logic-layer-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="acd21-214">[![Add a New Class to the App_Code Folder](creating-a-business-logic-layer-cs/_static/image10.png)](creating-a-business-logic-layer-cs/_static/image9.png)</span></span>

<span data-ttu-id="acd21-215">**그림 5**: 새 클래스를 추가 합니다 `App_Code` 폴더 ([큰 이미지를 보려면 클릭](creating-a-business-logic-layer-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="acd21-215">**Figure 5**: Add a New Class to the `App_Code` Folder ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image11.png))</span></span>

<span data-ttu-id="acd21-216">다음에 대 한 이벤트 처리기를 만듭니다는 `ColumnChanging` 되도록 하는 이벤트를 `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, 및 `ReorderLevel` 열 값 (그렇지 않은 경우 `NULL`)는 0 보다 크거나 같은 경우.</span><span class="sxs-lookup"><span data-stu-id="acd21-216">Next, create an event handler for the `ColumnChanging` event that ensures that the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` column values (if not `NULL`) are greater than or equal to zero.</span></span> <span data-ttu-id="acd21-217">이러한 열이 범위를 벗어나는 경우 throw는 `ArgumentException`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-217">If any such column is out of range, throw an `ArgumentException`.</span></span>

<span data-ttu-id="acd21-218">ProductsDataTable.ColumnChanging.cs</span><span class="sxs-lookup"><span data-stu-id="acd21-218">ProductsDataTable.ColumnChanging.cs</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample5.cs)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a><span data-ttu-id="acd21-219">4단계: 클래스 BLL의 사용자 지정 비즈니스 규칙 추가</span><span class="sxs-lookup"><span data-stu-id="acd21-219">Step 4: Adding Custom Business Rules to the BLL's Classes</span></span>

<span data-ttu-id="acd21-220">필드 수준 유효성 검사 외에도 같은 다른 엔터티 또는 단일 열 수준에서 개념을 표현할 수 없습니다를 포함 하는 높은 수준의 사용자 지정 비즈니스 규칙이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-220">In addition to field-level validation, there may be high-level custom business rules that involve different entities or concepts not expressible at the single column level, such as:</span></span>

- <span data-ttu-id="acd21-221">제품이 단종 된 경우 해당 `UnitPrice` 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-221">If a product is discontinued, its `UnitPrice` cannot be updated</span></span>
- <span data-ttu-id="acd21-222">직원의 거주 국가를 해당 관리자의 거주 국가와 동일 해야</span><span class="sxs-lookup"><span data-stu-id="acd21-222">An employee's country of residence must be the same as their manager's country of residence</span></span>
- <span data-ttu-id="acd21-223">제품은 제품만 공급자가 제공 하는 경우 중단 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-223">A product cannot be discontinued if it is the only product provided by the supplier</span></span>

<span data-ttu-id="acd21-224">클래스 BLL 하 여 응용 프로그램의 비즈니스 규칙을 준수 검사를 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-224">The BLL classes should contain checks to ensure adherence to the application's business rules.</span></span> <span data-ttu-id="acd21-225">이러한 검사를 적용 하는 메서드를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-225">These checks can be added directly to the methods to which they apply.</span></span>

<span data-ttu-id="acd21-226">비즈니스 규칙에는 제품을 표시할 수 없습니다 지원 되지 않는 지정 된 공급자 로부터 제품만 되었으면 받아쓰기는 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-226">Imagine that our business rules dictate that a product could not be marked discontinued if it was the only product from a given supplier.</span></span> <span data-ttu-id="acd21-227">그러나 즉, 경우 제품 *X* 공급 업체에서 구매한 것만 제품 이었습니다 *Y*, 표시할 수 없습니다 것 *X* 지원 되지 않는; 경우 처럼 공급자 *Y*세 가지 제품과 함께 제공 하는 미국 *A*, *B*, 및 *C*, 그런 다음 모든 표시 수 및 중단으로 이러한 모든 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-227">That is, if product *X* was the only product we purchased from supplier *Y*, we could not mark *X* as discontinued; if, however, supplier *Y* supplied us with three products, *A*, *B*, and *C*, then we could mark any and all of these as discontinued.</span></span> <span data-ttu-id="acd21-228">항상 홀수 비즈니스 규칙을 있지만 비즈니스 규칙 및 상식적인 정렬 되지 않습니다!</span><span class="sxs-lookup"><span data-stu-id="acd21-228">An odd business rule, but business rules and common sense aren't always aligned!</span></span>

<span data-ttu-id="acd21-229">이 비즈니스 규칙을 적용 하는 `UpdateProducts` 메서드를 확인 하 여 시작 했습니다 `Discontinued` 로 설정 된 `true` 따라서 호출 하는 경우 `GetProductsBySupplierID` 에서는이 제품의 공급이 업체에서 구매한 제품 수를 결정 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-229">To enforce this business rule in the `UpdateProducts` method we'd start by checking if `Discontinued` was set to `true` and, if so, we'd call `GetProductsBySupplierID` to determine how many products we purchased from this product's supplier.</span></span> <span data-ttu-id="acd21-230">경우에이 공급 업체에서 구매한 제품 하나를 두어는 `ApplicationException`합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-230">If only one product is purchased from this supplier, we throw an `ApplicationException`.</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample6.cs)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a><span data-ttu-id="acd21-231">프레젠테이션 계층에서 유효성 검사 오류에 응답</span><span class="sxs-lookup"><span data-stu-id="acd21-231">Responding to Validation Errors in the Presentation Tier</span></span>

<span data-ttu-id="acd21-232">프레젠테이션 계층에서 BLL을 호출할 때 발생할 수 있습니다 또는 ASP.NET 버블링 수 있도록 하는 모든 예외를 처리할 것인지를 결정할 수 있습니다 (발생 시키고 합니다 `HttpApplication`의 `Error` 이벤트).</span><span class="sxs-lookup"><span data-stu-id="acd21-232">When calling the BLL from the presentation tier we can decide whether to attempt to handle any exceptions that might be raised or let them bubble up to ASP.NET (which will raise the `HttpApplication`'s `Error` event).</span></span> <span data-ttu-id="acd21-233">BLL을 사용 하 여 프로그래밍 방식으로 작업 하는 경우 예외를 처리를 사용할 수 있습니다는 [try... catch](https://msdn.microsoft.com/library/0yd65esw.aspx) 다음 예와 같이 블록:</span><span class="sxs-lookup"><span data-stu-id="acd21-233">To handle an exception when working with the BLL programmatically, we can use a [try...catch](https://msdn.microsoft.com/library/0yd65esw.aspx) block, as the following example shows:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample7.cs)]

<span data-ttu-id="acd21-234">나중에 자습서 살펴보겠습니다, 데이터를 사용 하는 경우 BLL에서 버블 업 예외 처리 웹 컨트롤 삽입, 업데이트 또는 코드에서 줄 바꿈 하는 대신 이벤트 처리기에서 직접 데이터 삭제를 처리할 수 있습니다 `try...catch` 블록.</span><span class="sxs-lookup"><span data-stu-id="acd21-234">As we'll see in future tutorials, handling exceptions that bubble up from the BLL when using a data Web control for inserting, updating, or deleting data can be handled directly in an event handler as opposed to having to wrap code in `try...catch` blocks.</span></span>

## <a name="summary"></a><span data-ttu-id="acd21-235">요약</span><span class="sxs-lookup"><span data-stu-id="acd21-235">Summary</span></span>

<span data-ttu-id="acd21-236">잘 설계 된 응용 프로그램을 특정 역할을 캡슐화 하는 각 고유 레이어로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-236">A well architected application is crafted into distinct layers, each of which encapsulates a particular role.</span></span> <span data-ttu-id="acd21-237">이 문서 시리즈의 첫 번째 자습서에서 형식화 된 데이터 집합;를 사용 하 여 데이터 액세스 계층을 만들었습니다. 이 자습서에서는 기본 제공 비즈니스 논리 레이어 일련의 클래스 응용 프로그램의 `App_Code` 는 DAL을 호출 하는 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-237">In the first tutorial of this article series we created a Data Access Layer using Typed DataSets; in this tutorial we built a Business Logic Layer as a series of classes in our application's `App_Code` folder that call down into our DAL.</span></span> <span data-ttu-id="acd21-238">BLL에 응용 프로그램에 대 한 필드 수준과 비즈니스 수준의 논리를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-238">The BLL implements the field-level and business-level logic for our application.</span></span> <span data-ttu-id="acd21-239">별도 BLL을 만드는 것 외에이 자습서에서 수행한 것 처럼 다른 옵션으로 partial 클래스를 사용 하 여 Tableadapter의 메서드를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-239">In addition to creating a separate BLL, as we did in this tutorial, another option is to extend the TableAdapters' methods through the use of partial classes.</span></span> <span data-ttu-id="acd21-240">그러나이 방법을 사용할 수 없도록 기존 메서드를 재정의 하 되 지도 않습니다 하는 DAL 및 분리는 BLL이 문서의 살펴보았으며 접근 방식으로 완전히.</span><span class="sxs-lookup"><span data-stu-id="acd21-240">However, using this technique does not allow us to override existing methods nor does it separate our DAL and our BLL as cleanly as the approach we've taken in this article.</span></span>

<span data-ttu-id="acd21-241">DAL 및 완료 하는 BLL을 사용 하 여 준비가 프레젠테이션 계층에서 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-241">With the DAL and BLL complete, we're ready to start on our presentation layer.</span></span> <span data-ttu-id="acd21-242">에 [다음 자습서](master-pages-and-site-navigation-cs.md) 에서는 데이터 액세스 항목에서 간단한 우회를 수행 하 고이 자습서 전체에서 사용에 대 한 일관 된 페이지 레이아웃을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-242">In the [next tutorial](master-pages-and-site-navigation-cs.md) we'll take a brief detour from data access topics and define a consistent page layout for use throughout the tutorials.</span></span>

<span data-ttu-id="acd21-243">즐거운 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="acd21-243">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="acd21-244">저자 소개</span><span class="sxs-lookup"><span data-stu-id="acd21-244">About the Author</span></span>

<span data-ttu-id="acd21-245">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적의 저자 이자 설립자입니다 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 Microsoft 웹 기술을 사용 하 여 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-245">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="acd21-246">Scott는 독립 컨설턴트, 강사, 그리고 기록기로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-246">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="acd21-247">최근 저서는 [ *Sams 설명 직접 ASP.NET 2.0 24 시간 동안의*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-247">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="acd21-248">그에 도달할 수 있습니다 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="acd21-248">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="acd21-249">찾을 수 있는 저자의 블로그를 통해 또는 [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-249">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="acd21-250">특별히 감사</span><span class="sxs-lookup"><span data-stu-id="acd21-250">Special Thanks To</span></span>

<span data-ttu-id="acd21-251">이 자습서 시리즈는 많은 유용한 검토자가 검토 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-251">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="acd21-252">이 자습서에 대 한 선행 검토자 Liz Shulok, Dennis Patterson, Carlos Santos 및 Hilton giesenow가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="acd21-252">Lead reviewers for this tutorial were Liz Shulok, Dennis Patterson, Carlos Santos, and Hilton Giesenow.</span></span> <span data-ttu-id="acd21-253">내 향후 MSDN 문서를 검토에 관심이 있으십니까?</span><span class="sxs-lookup"><span data-stu-id="acd21-253">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="acd21-254">그렇다면 삭제 나에서 선 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="acd21-254">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="acd21-255">[이전](creating-a-data-access-layer-cs.md)
> [다음](master-pages-and-site-navigation-cs.md)</span><span class="sxs-lookup"><span data-stu-id="acd21-255">[Previous](creating-a-data-access-layer-cs.md)
[Next](master-pages-and-site-navigation-cs.md)</span></span>
