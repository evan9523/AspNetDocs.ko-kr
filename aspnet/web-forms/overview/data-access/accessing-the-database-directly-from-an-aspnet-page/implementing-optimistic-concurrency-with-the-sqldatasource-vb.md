---
uid: web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
title: SqlDataSource (VB)를 사용 하 여 낙관적 동시성 구현 | Microsoft Docs
author: rick-anderson
description: 이 자습서에서는 낙관적 동시성 제어의 주요 정보를 검토 하 고 SqlDataSource 컨트롤을 사용 하 여 구현 하는 방법을 탐색 합니다.
ms.author: riande
ms.date: 02/20/2007
ms.assetid: a8fa72ee-8328-4854-a419-c1b271772303
msc.legacyurl: /web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
msc.type: authoredcontent
ms.openlocfilehash: da0df163d7c3b68246a84ff490471e64c142a8f0
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59416521"
---
# <a name="implementing-optimistic-concurrency-with-the-sqldatasource-vb"></a><span data-ttu-id="1d0cf-103">SqlDataSource를 사용하여 낙관적 동시성 구현(VB)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-103">Implementing Optimistic Concurrency with the SqlDataSource (VB)</span></span>

<span data-ttu-id="1d0cf-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="1d0cf-105">[샘플 앱을 다운로드](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe) 또는 [PDF 다운로드](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-105">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe) or [Download PDF](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span></span>

> <span data-ttu-id="1d0cf-106">이 자습서에서는 낙관적 동시성 제어의 주요 정보를 검토 하 고 SqlDataSource 컨트롤을 사용 하 여 구현 하는 방법을 탐색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-106">In this tutorial we review the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource control.</span></span>


## <a name="introduction"></a><span data-ttu-id="1d0cf-107">소개</span><span class="sxs-lookup"><span data-stu-id="1d0cf-107">Introduction</span></span>

<span data-ttu-id="1d0cf-108">이전 자습서에서 삽입, 업데이트 및 삭제 기능 SqlDataSource 컨트롤을 추가 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-108">In the preceding tutorial we examined how to add inserting, updating, and deleting capabilities to the SqlDataSource control.</span></span> <span data-ttu-id="1d0cf-109">즉, 이러한 기능을 제공 해야 해당 지정 `INSERT`, `UPDATE`, 또는 `DELETE` s control에서 SQL 문을 `InsertCommand`합니다 `UpdateCommand`, 또는 `DeleteCommand` 함께 적절 한 속성 매개 변수를 `InsertParameters`, `UpdateParameters`, 및 `DeleteParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-109">In short, to provide these features we needed to specify the corresponding `INSERT`, `UPDATE`, or `DELETE` SQL statement in the control s `InsertCommand`, `UpdateCommand`, or `DeleteCommand` properties, along with the appropriate parameters in the `InsertParameters`, `UpdateParameters`, and `DeleteParameters` collections.</span></span> <span data-ttu-id="1d0cf-110">이러한 속성 및 컬렉션을 수동으로 지정할 수 있습니다, 데이터 소스 구성 마법사가 고급 단추는 생성을 제공 `INSERT`, `UPDATE`, 및 `DELETE` 문을 확인란을 통해 생성 되는 자동-이러한 문을 기반으로 `SELECT` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-110">While these properties and collections can be specified manually, the Configure Data Source wizard s Advanced button offers a Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox that will auto-create these statements based on the `SELECT` statement.</span></span>

<span data-ttu-id="1d0cf-111">생성 함께 `INSERT`, `UPDATE`, 및 `DELETE` 문을 확인란을 고급 SQL 생성 옵션 대화 상자를 사용 하 여 낙관적 동시성 옵션 포함 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="1d0cf-111">Along with the Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox, the Advanced SQL Generation Options dialog box includes a Use optimistic concurrency option (see Figure 1).</span></span> <span data-ttu-id="1d0cf-112">이 옵션을 선택 하는 경우는 `WHERE` 자동으로 생성 된 절 `UPDATE` 및 `DELETE` 문은 업데이트를 수행 하 여 사용자 모눈에 데이터를 마지막으로 로드 한 후에 기본 데이터베이스 데이터를 수정 되지 않았는지 경우 삭제 하거나 하도록 수정 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-112">When checked, the `WHERE` clauses in the autogenerated `UPDATE` and `DELETE` statements are modified to only perform the update or delete if the underlying database data hasn't been modified since the user last loaded the data into the grid.</span></span>


![고급에서 낙관적 동시성 지원을 추가할 수 있습니다 SQL 생성 옵션 대화 상자](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.gif)

<span data-ttu-id="1d0cf-114">**그림 1**: 고급에서 낙관적 동시성 지원을 추가할 수 있습니다 SQL 생성 옵션 대화 상자</span><span class="sxs-lookup"><span data-stu-id="1d0cf-114">**Figure 1**: You Can Add Optimistic Concurrency Support from the Advanced SQL Generation Options Dialog Box</span></span>


<span data-ttu-id="1d0cf-115">다시 합니다 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 자습서 ObjectDataSource에 추가 하는 방법과 낙관적 동시성 제어의 기본 개념을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-115">Back in the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial we examined the fundamentals of optimistic concurrency control and how to add it to the ObjectDataSource.</span></span> <span data-ttu-id="1d0cf-116">이 자습서에서는 낙관적 동시성 제어의 essentials 재손질 하 고 SqlDataSource를 사용 하 여 구현 하는 방법을 탐색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-116">In this tutorial we'll retouch on the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource.</span></span>

## <a name="a-recap-of-optimistic-concurrency"></a><span data-ttu-id="1d0cf-117">낙관적 동시성의 요약</span><span class="sxs-lookup"><span data-stu-id="1d0cf-117">A Recap of Optimistic Concurrency</span></span>

<span data-ttu-id="1d0cf-118">여러 허용 하는 웹 응용 프로그램에 대 한 동시 사용자가 편집 하거나 동일한 데이터를 삭제할 수 있을 가능성이 한 명의 사용자가 변경 내용을 다른를 실수로 덮어쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-118">For web applications that allow multiple, simultaneous users to edit or delete the same data, there exists a possibility that one user may accidentally overwrite another s changes.</span></span> <span data-ttu-id="1d0cf-119">에 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 자습서는 다음 예제를 제공 했습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-119">In the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial I provided the following example:</span></span>

<span data-ttu-id="1d0cf-120">두 사용자 Jisun과 Sam, 된 모두 페이지를 방문 하는 업데이트 및 GridView 컨트롤을 통해 제품을 삭제 하는 방문자를 허용 하는 응용 프로그램에서 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-120">Imagine that two users, Jisun and Sam, were both visiting a page in an application that allowed visitors to update and delete products through a GridView control.</span></span> <span data-ttu-id="1d0cf-121">같은 시간대에 Chai에 대 한 편집 단추를 클릭 둘 다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-121">Both click the Edit button for Chai around the same time.</span></span> <span data-ttu-id="1d0cf-122">Jisun은 Chai Tea 제품 이름을 변경 하 고 [업데이트] 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-122">Jisun changes the product name to Chai Tea and clicks the Update button.</span></span> <span data-ttu-id="1d0cf-123">최종적인 결론은는 `UPDATE` 를 설정 하는 데이터베이스에 전송 되는 문 *모든* 제품 s 업데이트할 수 있는 필드 (Jisun 단일 필드를 업데이트 하는 경우에 `ProductName`).</span><span class="sxs-lookup"><span data-stu-id="1d0cf-123">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product s updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="1d0cf-124">이 시점에서, 데이터베이스에 Chai 차 음료, 범주 등이 특정 제품에 대 한 공급 업체 특이 한 액체 값.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-124">At this point in time, the database has the values Chai Tea, the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="1d0cf-125">그러나 Sam s 화면의 GridView 여전히 표시 제품 이름을 편집할 수 있는 GridView 행에서 Chai로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-125">However, the GridView on Sam s screen still shows the product name in the editable GridView row as Chai.</span></span> <span data-ttu-id="1d0cf-126">몇 초 후 Jisun의 변경 사항이 커밋되기 Sam 입력 하면 조미료에 범주를 업데이트 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-126">A few seconds after Jisun s changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="1d0cf-127">이 인해를 `UPDATE` Chai에 제품 이름을 설정 하는 데이터베이스에 전송 하는 문을 `CategoryID` 해당 입력 하면 조미료 범주 ID 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-127">This results in an `UPDATE` statement sent to the database that sets the product name to Chai, the `CategoryID` to the corresponding Condiments category ID, and so on.</span></span> <span data-ttu-id="1d0cf-128">제품 이름 Jisun의 변경 덮어썼습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-128">Jisun s changes to the product name have been overwritten.</span></span>

<span data-ttu-id="1d0cf-129">그림 2에서는이 상호 작용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-129">Figure 2 illustrates this interaction.</span></span>


<span data-ttu-id="1d0cf-130">[![두 명의 사용자가 동시에 레코드를 업데이트 하는 경우 있습니다 s 잠재적인 사용자 s에 대 한 변경을 다른를 덮어쓰려면](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-130">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span></span>

<span data-ttu-id="1d0cf-131">**그림 2**: 두 명의 사용자가 동시에 업데이트할 시기는 레코드가 있는 s 잠재적인 한 명의 사용자가 다른가 Overwrite로 변경 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-131">**Figure 2**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span></span>


<span data-ttu-id="1d0cf-132">이 시나리오의 형태를 펼치기 하지 못하도록 [동시성 제어](http://en.wikipedia.org/wiki/Concurrency_control) 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-132">To prevent this scenario from unfolding, a form of [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) must be implemented.</span></span> <span data-ttu-id="1d0cf-133">[낙관적 동시성](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) 가정 합니다, 동시성 충돌이 발생할 수 있습니다 위치 하는 동안 하에 작동이 자습서의 초점 대부분의 경우 이러한 충돌이 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-133">[Optimistic concurrency](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) the focus of this tutorial works on the assumption that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise.</span></span> <span data-ttu-id="1d0cf-134">따라서는 충돌이 발생 하는 경우 낙관적 동시성 제어 하기만 하면 사용자에 게 알려을 다른 사용자가 동일한 데이터를 수정 하기 때문에 해당 변경 내용 수 t 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-134">Therefore, if a conflict does arise, optimistic concurrency control simply informs the user that their changes can t be saved because another user has modified the same data.</span></span>

> [!NOTE]
> <span data-ttu-id="1d0cf-135">응용 프로그램의 많은 동시성 충돌 되도록 하거나 이러한 충돌은 허용 가능할 경우 가정 있는 경우 다음 비관적 동시성 제어 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-135">For applications where it is assumed that there will be many concurrency conflicts or if such conflicts are not tolerable, then pessimistic concurrency control can be used instead.</span></span> <span data-ttu-id="1d0cf-136">다시 참조를 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 자습서 비관적 동시성 제어에 대 한 더 상세히 논의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-136">Refer back to the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial for a more thorough discussion on pessimistic concurrency control.</span></span>


<span data-ttu-id="1d0cf-137">낙관적 동시성 제어 업데이트나 삭제 프로세스를 시작 하는 경우와 마찬가지로 업데이트 되거나 삭제 된 레코드에 동일한 값 함으로써 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-137">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="1d0cf-138">예를 들어, 편집할 수는 GridView의 편집 단추를 클릭 하면 s 레코드 값을 데이터베이스에서 읽고 텍스트 상자 및 기타 웹 컨트롤에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-138">For example, when clicking the Edit button in an editable GridView, the record s values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="1d0cf-139">GridView에서 원래 값이 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-139">These original values are saved by the GridView.</span></span> <span data-ttu-id="1d0cf-140">사용자가 변경 하 고, [업데이트] 단추를 클릭 한 후에 이후를 `UPDATE` 문에 사용 되는 원래 값 및 새 값을 고려 하며 원래 값을 사용자가 편집을 시작 하는 경우 기본 데이터베이스 레코드에만 업데이트 데이터베이스에서 값으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-140">Later, after the user makes her changes and clicks the Update button, the `UPDATE` statement used must take into account the original values plus the new values and only update the underlying database record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="1d0cf-141">그림 3에서는이 이벤트 시퀀스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-141">Figure 3 depicts this sequence of events.</span></span>


<span data-ttu-id="1d0cf-142">[![성공 하려면 업데이트 또는 삭제, 원래 값을 현재 데이터베이스 값 이어야 합니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-142">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span></span>

<span data-ttu-id="1d0cf-143">**그림 3**: Update 또는 Delete 성공에는 원래 값 해야 수 값과 같은 현재 데이터베이스에 대 한 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-143">**Figure 3**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span></span>


<span data-ttu-id="1d0cf-144">낙관적 동시성을 구현 하는 방법은 여러 가지가 있습니다 (참조 [Peter A. Bromberg](http://peterbromberg.net/)의 [낙관적 동시성 업데이트 논리](http://www.eggheadcafe.com/articles/20050719.asp) 간략히 다양 한 옵션에 대 한).</span><span class="sxs-lookup"><span data-stu-id="1d0cf-144">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="1d0cf-145">SqlDataSource에서 (뿐만 아니라 ADO.NET 입력 데이터 집합 데이터 액세스 계층에 사용 되는) 사용 방법을 보완 합니다 `WHERE` 모든 원래 값의 비교를 포함 하는 절.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-145">The technique used by the SqlDataSource (as well as by the ADO.NET Typed DataSets used in our Data Access Layer) augments the `WHERE` clause to include a comparison of all of the original values.</span></span> <span data-ttu-id="1d0cf-146">다음 `UPDATE` 문을 현재 데이터베이스 값 GridView에서 레코드를 업데이트 하는 경우 원래 검색 된 값과 같은 경우에 해당 이름 및 제품의 가격을 예를 들어 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-146">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="1d0cf-147">`@ProductName` 및 `@UnitPrice` 반면 매개 변수는 사용자가 입력 한 새 값이 포함 `@original_ProductName` 및 `@original_UnitPrice` 편집 단추를 클릭할 때 GridView에 원래 로드 된 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-147">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample1.sql)]

<span data-ttu-id="1d0cf-148">이 자습서에서 살펴보겠지만 SqlDataSource 사용 하 여 낙관적 동시성 제어를 사용 하도록 설정 하면 간단 하 게는 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-148">As we'll see in this tutorial, enabling optimistic concurrency control with the SqlDataSource is as simple as checking a checkbox.</span></span>

## <a name="step-1-creating-a-sqldatasource-that-supports-optimistic-concurrency"></a><span data-ttu-id="1d0cf-149">1단계: 낙관적 동시성을 지 원하는 SqlDataSource 만들기</span><span class="sxs-lookup"><span data-stu-id="1d0cf-149">Step 1: Creating a SqlDataSource that Supports Optimistic Concurrency</span></span>

<span data-ttu-id="1d0cf-150">열어서 시작 합니다 `OptimisticConcurrency.aspx` 에서 페이지를 `SqlDataSource` 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-150">Start by opening the `OptimisticConcurrency.aspx` page from the `SqlDataSource` folder.</span></span> <span data-ttu-id="1d0cf-151">설정 디자이너 도구 상자에서 SqlDataSource 컨트롤을 끌어 해당 `ID` 속성을 `ProductsDataSourceWithOptimisticConcurrency`입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-151">Drag a SqlDataSource control from the Toolbox onto the Designer, settings its `ID` property to `ProductsDataSourceWithOptimisticConcurrency`.</span></span> <span data-ttu-id="1d0cf-152">다음으로, 컨트롤 s 스마트 태그의 데이터 소스 구성 링크를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-152">Next, click on the Configure Data Source link from the control s smart tag.</span></span> <span data-ttu-id="1d0cf-153">마법사의 첫 번째 화면에서 사용 하 여 작업을 선택 합니다 `NORTHWINDConnectionString` 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-153">From the first screen in the wizard, choose to work with the `NORTHWINDConnectionString` and click Next.</span></span>


<span data-ttu-id="1d0cf-154">[![위해 사용 하 여 작업을 선택 합니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-154">[![Choose to Work with the NORTHWINDConnectionString](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span></span>

<span data-ttu-id="1d0cf-155">**그림 4**: 작업을 선택 합니다 `NORTHWINDConnectionString` ([큰 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-155">**Figure 4**: Choose to Work with the `NORTHWINDConnectionString` ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span></span>


<span data-ttu-id="1d0cf-156">사용자가 편집할 수 있도록 하는 GridView를 추가할 예정이 예는 `Products` 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-156">For this example we'll be adding a GridView that enables users to edit the `Products` table.</span></span> <span data-ttu-id="1d0cf-157">따라서 Select 문 화면 구성에서 선택는 `Products` 드롭 다운 목록에서 테이블을 선택 합니다 `ProductID`, `ProductName`, `UnitPrice`, 및 `Discontinued` 그림 5에 표시 된 대로 열.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-157">Therefore, from the Configure the Select Statement screen, choose the `Products` table from the drop-down list and select the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` columns, as shown in Figure 5.</span></span>


<span data-ttu-id="1d0cf-158">[![Products 테이블에서 ProductID, ProductName, UnitPrice, 및 지원 되지 않는 열 반환](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-158">[![From the Products Table, Return the ProductID, ProductName, UnitPrice, and Discontinued Columns](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span></span>

<span data-ttu-id="1d0cf-159">**그림 5**: `Products` 테이블을 반환 합니다 `ProductID`, `ProductName`, `UnitPrice`, 및 `Discontinued` 열 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-159">**Figure 5**: From the `Products` Table, Return the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` Columns ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span></span>


<span data-ttu-id="1d0cf-160">열을 선택한 후 고급 SQL 생성 옵션 대화 상자를 표시 하려면 고급 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-160">After picking the columns, click the Advanced button to bring up the Advanced SQL Generation Options dialog box.</span></span> <span data-ttu-id="1d0cf-161">생성을 확인 `INSERT`, `UPDATE`, 및 `DELETE` 문을 낙관적 동시성 확인란을 사용 하 고 확인을 클릭 (다시 그림 1 참조 스크린 샷에 대 한).</span><span class="sxs-lookup"><span data-stu-id="1d0cf-161">Check the Generate `INSERT`, `UPDATE`, and `DELETE` statements and Use optimistic concurrency checkboxes and click OK (refer back to Figure 1 for a screenshot).</span></span> <span data-ttu-id="1d0cf-162">다음을 클릭 하 여 마법사를 완료 한 다음 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-162">Complete the wizard by clicking Next, then Finish.</span></span>

<span data-ttu-id="1d0cf-163">데이터 소스 구성 마법사를 완료 한 후 결과 검사 하려면 잠시 시간이 소요 `DeleteCommand` 하 고 `UpdateCommand` 속성 및 `DeleteParameters` 및 `UpdateParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-163">After completing the Configure Data Source wizard, take a moment to examine the resulting `DeleteCommand` and `UpdateCommand` properties and the `DeleteParameters` and `UpdateParameters` collections.</span></span> <span data-ttu-id="1d0cf-164">이 작업을 수행 하는 가장 쉬운 방법은 소스 탭 페이지 s 선언적 구문을 보려면 왼쪽된 아래 모퉁이에서 클릭 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-164">The easiest way to do this is to click on the Source tab in the lower left corner to see the page s declarative syntax.</span></span> <span data-ttu-id="1d0cf-165">여기서 찾을 수 있습니다는 `UpdateCommand` 값:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-165">There you will find an `UpdateCommand` value of:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample2.sql)]

<span data-ttu-id="1d0cf-166">7 개의 매개 변수를 사용 하 여는 `UpdateParameters` 컬렉션:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-166">With seven parameters in the `UpdateParameters` collection:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample3.aspx)]

<span data-ttu-id="1d0cf-167">마찬가지로,는 `DeleteCommand` 속성 및 `DeleteParameters` 컬렉션 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-167">Similarly, the `DeleteCommand` property and `DeleteParameters` collection should look like the following:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample4.sql)]


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample5.aspx)]

<span data-ttu-id="1d0cf-168">확대 하는 것 외에도 합니다 `WHERE` 절을 `UpdateCommand` 및 `DeleteCommand` 속성 (및 해당 매개 변수 컬렉션에 추가 매개 변수를 추가) 사용 하 여 낙관적 동시성 옵션 두 개의 다른 조정 선택 속성:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-168">In addition to augmenting the `WHERE` clauses of the `UpdateCommand` and `DeleteCommand` properties (and adding the additional parameters to the respective parameter collections), selecting the Use optimistic concurrency option adjusts two other properties:</span></span>

- <span data-ttu-id="1d0cf-169">변경 된 [ `ConflictDetection` 속성](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) 에서 `OverwriteChanges` (기본값)를 `CompareAllValues`</span><span class="sxs-lookup"><span data-stu-id="1d0cf-169">Changes the [`ConflictDetection` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) from `OverwriteChanges` (the default) to `CompareAllValues`</span></span>
- <span data-ttu-id="1d0cf-170">변경 된 [ `OldValuesParameterFormatString` 속성](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) 에서 {0} (기본값)에 원래\_ {0} 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-170">Changes the [`OldValuesParameterFormatString` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) from {0} (the default) to original\_{0} .</span></span>

<span data-ttu-id="1d0cf-171">데이터 웹 컨트롤 SqlDataSource s를 호출 하는 경우 `Update()` 또는 `Delete()` 원래 값을 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-171">When the data Web control invokes the SqlDataSource s `Update()` or `Delete()` method, it passes in the original values.</span></span> <span data-ttu-id="1d0cf-172">경우 SqlDataSource s `ConflictDetection` 속성이 `CompareAllValues`, 이러한 원래 값이 명령에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-172">If the SqlDataSource s `ConflictDetection` property is set to `CompareAllValues`, these original values are added to the command.</span></span> <span data-ttu-id="1d0cf-173">`OldValuesParameterFormatString` 속성은 이러한 원래 값 매개 변수에 대해 사용 되는 명명 패턴을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-173">The `OldValuesParameterFormatString` property provides the naming pattern used for these original value parameters.</span></span> <span data-ttu-id="1d0cf-174">데이터 소스 구성 마법사를 사용 하 여 원래\_ {0} 각 원래 매개 변수 이름 및는 `UpdateCommand` 하 고 `DeleteCommand` 속성 및 `UpdateParameters` 및 `DeleteParameters` 컬렉션 적절 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-174">The Configure Data Source wizard uses original\_{0} and names each original parameter in the `UpdateCommand` and `DeleteCommand` properties and `UpdateParameters` and `DeleteParameters` collections accordingly.</span></span>

> [!NOTE]
> <span data-ttu-id="1d0cf-175">SqlDataSource 컨트롤 s 삽입 기능을 사용 하지 다시 것에 자유롭게 삭제 되므로 합니다 `InsertCommand` 속성 및 해당 `InsertParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-175">Since we re not using the SqlDataSource control s inserting capabilities, feel free to remove the `InsertCommand` property and its `InsertParameters` collection.</span></span>


## <a name="correctly-handlingnullvalues"></a><span data-ttu-id="1d0cf-176">올바르게 처리`NULL`값</span><span class="sxs-lookup"><span data-stu-id="1d0cf-176">Correctly Handling`NULL`Values</span></span>

<span data-ttu-id="1d0cf-177">아쉽게도 증강 `UPDATE` 및 `DELETE` 문을 자동으로 생성 된 낙관적 동시성을 사용 하는 경우 데이터 소스 구성 마법사에서 수행 *되지* 포함 하는 레코드를 사용 하 여 회사 `NULL` 값.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-177">Unfortunately, the augmented `UPDATE` and `DELETE` statements autogenerated by the Configure Data Source wizard when using optimistic concurrency do *not* work with records that contain `NULL` values.</span></span> <span data-ttu-id="1d0cf-178">이유를 확인 하려면이 SqlDataSource가 것이 좋습니다 `UpdateCommand`:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-178">To see why, consider our SqlDataSource s `UpdateCommand`:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample6.sql)]

<span data-ttu-id="1d0cf-179">`UnitPrice` 열에는 `Products` 테이블에 있을 수 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-179">The `UnitPrice` column in the `Products` table can have `NULL` values.</span></span> <span data-ttu-id="1d0cf-180">특정 레코드가 있는 경우는 `NULL` 에 대 한 값 `UnitPrice`의 `WHERE` 절 부분 `[UnitPrice] = @original_UnitPrice` 됩니다 *항상* 때문에 False로 평가 `NULL = NULL` 항상 False를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-180">If a particular record has a `NULL` value for `UnitPrice`, the `WHERE` clause portion `[UnitPrice] = @original_UnitPrice` will *always* evaluate to False because `NULL = NULL` always returns False.</span></span> <span data-ttu-id="1d0cf-181">따라서 레코드 포함 하는 `NULL` 값을 편집 하거나 삭제할 수로 `UPDATE` 하 고 `DELETE` 문을 `WHERE` 절을 업데이트 하거나 삭제할 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-181">Therefore, records that contain `NULL` values cannot be edited or deleted, as the `UPDATE` and `DELETE` statements `WHERE` clauses won't return any rows to update or delete.</span></span>

> [!NOTE]
> <span data-ttu-id="1d0cf-182">이 버그의 2004 년 6 월에에서 Microsoft로 보고 먼저 되었습니다 [SqlDataSource 생성 된 잘못 된 SQL 문을](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) 되었으며 나타내기 ASP.NET의 다음 버전에서 수정 될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-182">This bug was first reported to Microsoft in June of 2004 in [SqlDataSource Generates Incorrect SQL Statements](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) and is reportedly scheduled to be fixed in the next version of ASP.NET.</span></span>


<span data-ttu-id="1d0cf-183">이 해결 하려면 수동으로 업데이트 해야 합니다 `WHERE` 절 모두를 `UpdateCommand` 및 `DeleteCommand` 속성에 대 한 **모든** 열 수 있는 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-183">To fix this, we have to manually update the `WHERE` clauses in both the `UpdateCommand` and `DeleteCommand` properties for **all** columns that can have `NULL` values.</span></span> <span data-ttu-id="1d0cf-184">일반적으로 변경할 `[ColumnName] = @original_ColumnName` 에:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-184">In general, change `[ColumnName] = @original_ColumnName` to:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample7.sql)]

<span data-ttu-id="1d0cf-185">이 수정 속성 창에서 UpdateQuery 또는 DeleteQuery 옵션을 통해 선언적 태그를 통해 직접 또는 업데이트를 통해 구성할 수 있으며 사용자 지정 SQL 문 또는 저장된 프로시저 옵션의 구성 데이터를 지정에서 하는 탭 삭제 소스 마법사입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-185">This modification can be made directly through the declarative markup, via the UpdateQuery or DeleteQuery options from the Properties window, or through the UPDATE and DELETE tabs in the Specify a custom SQL statement or stored procedure option in the Configure Data Source wizard.</span></span> <span data-ttu-id="1d0cf-186">이 수정에 대 한 다시 수 있어야 합니다 *모든* 열에는 `UpdateCommand` 하 고 `DeleteCommand` s `WHERE` 절을 포함할 수 있는 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-186">Again, this modification must be made for *every* column in the `UpdateCommand` and `DeleteCommand` s `WHERE` clause that can contain `NULL` values.</span></span>

<span data-ttu-id="1d0cf-187">이 예제를 적용 하면 수정한 다음 결과 `UpdateCommand` 고 `DeleteCommand` 값:</span><span class="sxs-lookup"><span data-stu-id="1d0cf-187">Applying this to our example results in the following modified `UpdateCommand` and `DeleteCommand` values:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample8.sql)]

## <a name="step-2-adding-a-gridview-with-edit-and-delete-options"></a><span data-ttu-id="1d0cf-188">2단계: 편집 및 삭제 옵션을 사용 하 여 GridView를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-188">Step 2: Adding a GridView with Edit and Delete Options</span></span>

<span data-ttu-id="1d0cf-189">낙관적 동시성을 지원 하도록 SqlDataSource를 사용 하 여에이 동시성 제어를 활용 하는 페이지 데이터 웹 컨트롤을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-189">With the SqlDataSource configured to support optimistic concurrency, all that remains is to add a data Web control to the page that utilizes this concurrency control.</span></span> <span data-ttu-id="1d0cf-190">이 자습서에서는 편집을 제공 하는 GridView를 추가 및 삭제 기능을 사용 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-190">For this tutorial, let s add a GridView that provides both edit and delete functionality.</span></span> <span data-ttu-id="1d0cf-191">이렇게 하려면 GridView 집합과 디자이너 도구 상자에서 끌어 해당 `ID` 에 `Products`입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-191">To accomplish this, drag a GridView from the Toolbox onto the Designer and set its `ID` to `Products`.</span></span> <span data-ttu-id="1d0cf-192">GridView가 스마트 태그에 바인딩하지는 `ProductsDataSourceWithOptimisticConcurrency` 1 단계에서에서 추가한 SqlDataSource 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-192">From the GridView s smart tag, bind it to the `ProductsDataSourceWithOptimisticConcurrency` SqlDataSource control added in Step 1.</span></span> <span data-ttu-id="1d0cf-193">마지막으로, 스마트 태그에서 편집을 사용 하도록 설정 및 삭제 사용 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-193">Finally, check the Enable Editing and Enable Deleting options from the smart tag.</span></span>


<span data-ttu-id="1d0cf-194">[![SqlDataSource를 GridView을 바인딩하고 편집 및 삭제를 사용 하도록 설정](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-194">[![Bind the GridView to the SqlDataSource and Enable Editing and Deleting](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span></span>

<span data-ttu-id="1d0cf-195">**그림 6**: SqlDataSource 및 편집 사용 및 삭제에 GridView를 바인딩 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-195">**Figure 6**: Bind the GridView to the SqlDataSource and Enable Editing and Deleting ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span></span>


<span data-ttu-id="1d0cf-196">GridView를 추가한 후 제거 하 여 모양을 구성 합니다 `ProductID` BoundField 변경를 `ProductName` BoundField s `HeaderText` 속성을 업데이트 하 고 제품에는 `UnitPrice` BoundField 있도록 해당 `HeaderText` 속성은 단순히 가격입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-196">After adding the GridView, configure its appearance by removing the `ProductID` BoundField, changing the `ProductName` BoundField s `HeaderText` property to Product, and updating the `UnitPrice` BoundField so that its `HeaderText` property is simply Price.</span></span> <span data-ttu-id="1d0cf-197">이상적으로 d 강화에 대 한 RequiredFieldValidator 포함 하도록 편집 인터페이스를 `ProductName` 값 및에 대해 CompareValidator의 `UnitPrice` 값 (s 올바른 형식의 숫자 값을 확인).</span><span class="sxs-lookup"><span data-stu-id="1d0cf-197">Ideally, we d enhance the editing interface to include a RequiredFieldValidator for the `ProductName` value and a CompareValidator for the `UnitPrice` value (to ensure it s a properly formatted numeric value).</span></span> <span data-ttu-id="1d0cf-198">참조 된 [데이터 수정 인터페이스 사용자 지정](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) GridView s 편집 인터페이스 사용자 지정에 대 한 자세한 설명에 대 한 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-198">Refer to the [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorial for a more in-depth look at customizing the GridView s editing interface.</span></span>

> [!NOTE]
> <span data-ttu-id="1d0cf-199">SqlDataSource GridView에서 전달 된 원래 값은 s 뷰 상태를 사용 해야 하는 GridView 뷰 상태에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-199">The GridView s view state must be enabled since the original values passed from the GridView to the SqlDataSource are stored in view state.</span></span>


<span data-ttu-id="1d0cf-200">GridView에 다음과 같이이 수정에 확인 한 후 GridView, SqlDataSource 선언적 태그는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-200">After making these modifications to the GridView, the GridView and SqlDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample9.aspx)]

<span data-ttu-id="1d0cf-201">작업에서 낙관적 동시성 제어를 확인 하려면 두 개의 브라우저 창을 열고 로드는 `OptimisticConcurrency.aspx` 모두의 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-201">To see the optimistic concurrency control in action, open two browser windows and load the `OptimisticConcurrency.aspx` page in both.</span></span> <span data-ttu-id="1d0cf-202">첫 번째 제품 두 브라우저에 대 한 편집 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-202">Click on the Edit buttons for the first product in both browsers.</span></span> <span data-ttu-id="1d0cf-203">하나의 브라우저에서 제품 이름을 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-203">In one browser, change the product name and click Update.</span></span> <span data-ttu-id="1d0cf-204">브라우저에서 포스트백 됩니다 하 고 방금 편집한 레코드에 대 한 새 제품 이름을 보여 주는 GridView 해당 미리 편집 모드로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-204">The browser will postback and the GridView will return to its pre-editing mode, showing the new product name for the record just edited.</span></span>

<span data-ttu-id="1d0cf-205">두 번째 브라우저 창에서 제품 이름 원래 값으로 나감) (하지만 가격을 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-205">In the second browser window, change the price (but leave the product name as its original value) and click Update.</span></span> <span data-ttu-id="1d0cf-206">포스트백에서 표는 미리 편집 모드를 반환 하지만 가격 변경 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-206">On postback, the grid returns to its pre-editing mode, but the change to the price is not recorded.</span></span> <span data-ttu-id="1d0cf-207">두 번째 브라우저는 이전 가격으로 새 제품 이름 같은 첫 번째 값을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-207">The second browser shows the same value as the first one the new product name with the old price.</span></span> <span data-ttu-id="1d0cf-208">두 번째 브라우저 창에서 변경한 내용을 손실 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-208">The changes made in the second browser window were lost.</span></span> <span data-ttu-id="1d0cf-209">또한 변경 내용이 손실 대신 자동으로 예외 없거나 동시성 위반을 방금 발생 했음을 나타내는 메시지가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-209">Moreover, the changes were lost rather quietly, as there was no exception or message indicating that a concurrency violation just occurred.</span></span>


<span data-ttu-id="1d0cf-210">[![두 번째 브라우저 창에서 변경 내용이 자동으로 손실](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-210">[![The Changes in the Second Browser Window Were Silently Lost](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span></span>

<span data-ttu-id="1d0cf-211">**그림 7**: 두 번째 브라우저 창이 자동으로 손실 된의 변경 내용 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-211">**Figure 7**: The Changes in the Second Browser Window Were Silently Lost ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span></span>


<span data-ttu-id="1d0cf-212">두 번째 브라우저의 변경 내용이 커밋 이유 이유 이어서 합니다 `UPDATE` 문이의 `WHERE` 절 모든 레코드를 필터링 하 고 따라서 모든 행에 영향을 주지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-212">The reason why the second browser s changes were not committed was because the `UPDATE` statement s `WHERE` clause filtered out all records and therefore did not affect any rows.</span></span> <span data-ttu-id="1d0cf-213">살펴볼 s는 `UPDATE` 문을 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-213">Let s look at the `UPDATE` statement again:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample10.sql)]

<span data-ttu-id="1d0cf-214">원래 제품 이름에 지정 된 브라우저 창을 두 번째 레코드를 업데이트할 때의 `WHERE` (첫 번째 브라우저에 의해 변경 되었습니다) 이므로 기존 제품 이름과 함께 등록 되는 절 만들어지고 t 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-214">When the second browser window updates the record, the original product name specified in the `WHERE` clause doesn t match up with the existing product name (since it was changed by the first browser).</span></span> <span data-ttu-id="1d0cf-215">따라서 문을 `[ProductName] = @original_ProductName` False를 반환 하며 `UPDATE` 모든 레코드에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-215">Therefore, the statement `[ProductName] = @original_ProductName` returns False, and the `UPDATE` does not affect any records.</span></span>

> [!NOTE]
> <span data-ttu-id="1d0cf-216">동일한 방식으로 작동을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-216">Delete works in the same manner.</span></span> <span data-ttu-id="1d0cf-217">두 개의 브라우저 창을 열고, 하나를 사용 하 여 특정된 제품을 편집한 다음 해당 변경 내용을 저장 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-217">With two browser windows open, start by editing a given product with one, and then saving its changes.</span></span> <span data-ttu-id="1d0cf-218">변경 내용을 하나의 브라우저에서을 저장 한 후 다른 동일한 제품에 대 한 삭제 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-218">After saving the changes in the one browser, click the Delete button for the same product in the other.</span></span> <span data-ttu-id="1d0cf-219">원래 값 don t 일치 하므로 합니다 `DELETE` 문이의 `WHERE` 절 삭제 자동으로 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-219">Since the original values don t match up in the `DELETE` statement s `WHERE` clause, the delete silently fails.</span></span>


<span data-ttu-id="1d0cf-220">두 번째 브라우저 창에서 최종 사용자가의 관점에서 [업데이트] 단추를 클릭 한 후 표 미리 편집 모드를 반환 하지만 해당 변경 내용이 손실 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-220">From the end user s perspective in the second browser window, after clicking the Update button the grid returns to the pre-editing mode, but their changes were lost.</span></span> <span data-ttu-id="1d0cf-221">그러나 여기서 s는 변경 하지는 시각적 피드백 없음.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-221">However, there s no visual feedback that their changes didn't stick.</span></span> <span data-ttu-id="1d0cf-222">이상적으로 사용자가 변경 내용을 동시성 위반을 손실 되 면 d 알릴 수 하 고, 아마도, 표 편집 모드로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-222">Ideally, if a user s changes are lost to a concurrency violation, we d notify them and, perhaps, keep the grid in edit mode.</span></span> <span data-ttu-id="1d0cf-223">가이 작업을 수행 하는 방법을 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-223">Let s look at how to accomplish this.</span></span>

## <a name="step-3-determining-when-a-concurrency-violation-has-occurred"></a><span data-ttu-id="1d0cf-224">3단계: 동시성 위반이 발생 했을 때를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-224">Step 3: Determining When a Concurrency Violation Has Occurred</span></span>

<span data-ttu-id="1d0cf-225">동시성 위반을가 변경 하나에 거부 되므로 동시성 위반이 발생 했을 때 사용자에 게 경고할 좋을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-225">Since a concurrency violation rejects the changes one has made, it would be nice to alert the user when a concurrency violation has occurred.</span></span> <span data-ttu-id="1d0cf-226">사용자 경고를 통해의 컨트롤을 추가 레이블 웹 라는 페이지의 맨 위에 `ConcurrencyViolationMessage` 해당 `Text` 메시지를 표시 하는 속성: 업데이트 하거나 다른 사용자가 동시에 업데이트 된 레코드를 삭제 하려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-226">To alert the user, let s add a Label Web control to the top of the page named `ConcurrencyViolationMessage` whose `Text` property displays the following message: You have attempted to update or delete a record that was simultaneously updated by another user.</span></span> <span data-ttu-id="1d0cf-227">다른 사용자의 변경 내용을 검토 하 고 업데이트를 다시 실행 하거나 삭제 하십시오.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-227">Please review the other user's changes and then redo your update or delete.</span></span> <span data-ttu-id="1d0cf-228">가 레이블 컨트롤을 설정 `CssClass` 에 정의 된 CSS 클래스에는 경고로 속성 `Styles.css` 빨간색, 기울임꼴, 굵게 및 큰 글꼴의 텍스트를 표시 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-228">Set the Label control s `CssClass` property to Warning, which is a CSS class defined in `Styles.css` that displays text in a red, italic, bold, and large font.</span></span> <span data-ttu-id="1d0cf-229">마지막으로 s 레이블 설정 `Visible` 하 고 `EnableViewState` 속성을 `False`입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-229">Finally, set the Label s `Visible` and `EnableViewState` properties to `False`.</span></span> <span data-ttu-id="1d0cf-230">명시적으로 설정한 포스트백에만 제외 하 고 레이블을 숨기는이 해당 `Visible` 속성을 `True`입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-230">This will hide the Label except for only those postbacks where we explicitly set its `Visible` property to `True`.</span></span>


<span data-ttu-id="1d0cf-231">[![경고를 표시 하려면 페이지에는 레이블 컨트롤 추가](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-231">[![Add a Label Control to the Page to Display the Warning](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span></span>

<span data-ttu-id="1d0cf-232">**그림 8**: 경고를 표시 하려면 페이지에 레이블 컨트롤을 추가 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-232">**Figure 8**: Add a Label Control to the Page to Display the Warning ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span></span>


<span data-ttu-id="1d0cf-233">업데이트 또는 삭제, GridView s를 수행할 때 `RowUpdated` 고 `RowDeleted` 이벤트 처리기는 요청 된 update 또는 delete 해당 데이터 소스 컨트롤을 수행한 후 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-233">When performing an update or delete, the GridView s `RowUpdated` and `RowDeleted` event handlers fire after its data source control has performed the requested update or delete.</span></span> <span data-ttu-id="1d0cf-234">행 개수 이러한 이벤트 처리기에서 작업에 의해 영향을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-234">We can determine how many rows were affected by the operation from these event handlers.</span></span> <span data-ttu-id="1d0cf-235">표시 하고자 하는 0 개의 행에 영향을 받은 경우는 `ConcurrencyViolationMessage` 레이블.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-235">If zero rows were affected, we want to display the `ConcurrencyViolationMessage` Label.</span></span>

<span data-ttu-id="1d0cf-236">둘 다에 대 한 이벤트 처리기를 만듭니다는 `RowUpdated` 및 `RowDeleted` 이벤트 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-236">Create an event handler for both the `RowUpdated` and `RowDeleted` events and add the following code:</span></span>


[!code-vb[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample11.vb)]

<span data-ttu-id="1d0cf-237">두 이벤트 처리기에서 확인 합니다 `e.AffectedRows` 속성 0 이면 설정 및는 `ConcurrencyViolationMessage` 레이블 s `Visible` 속성을 `True`입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-237">In both event handlers we check the `e.AffectedRows` property and, if it equals 0, set the `ConcurrencyViolationMessage` Label s `Visible` property to `True`.</span></span> <span data-ttu-id="1d0cf-238">에 `RowUpdated` 이벤트 처리기도 하도록 지시를 설정 하 여 편집 모드로 유지 GridView는 `KeepInEditMode` 속성을 true로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-238">In the `RowUpdated` event handler, we also instruct the GridView to stay in edit mode by setting the `KeepInEditMode` property to true.</span></span> <span data-ttu-id="1d0cf-239">이 과정에서 다른 사용자가의 데이터를 편집 인터페이스에 로드 되도록 데이터 표를 다시 바인딩할 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-239">In doing so, we need to rebind the data to the grid so that the other user s data is loaded into the editing interface.</span></span> <span data-ttu-id="1d0cf-240">GridView가 호출 하 여 이렇게 `DataBind()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-240">This is accomplished by calling the GridView s `DataBind()` method.</span></span>

<span data-ttu-id="1d0cf-241">그림 9 있듯이 이러한 두 이벤트 처리기를 사용 하 여 동시성 위반이 발생할 때마다 확실 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-241">As Figure 9 shows, with these two event handlers, a very noticeable message is displayed whenever a concurrency violation occurs.</span></span>


<span data-ttu-id="1d0cf-242">[![동시성 위반이 발생 하는 경우 메시지가 표시 됩니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-242">[![A Message is Displayed in the Face of a Concurrency Violation](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span></span>

<span data-ttu-id="1d0cf-243">**그림 9**: 동시성 위반이 발생 하는 경우 메시지가 표시 됩니다 ([클릭 하 여 큰 이미지 보기](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span><span class="sxs-lookup"><span data-stu-id="1d0cf-243">**Figure 9**: A Message is Displayed in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span></span>


## <a name="summary"></a><span data-ttu-id="1d0cf-244">요약</span><span class="sxs-lookup"><span data-stu-id="1d0cf-244">Summary</span></span>

<span data-ttu-id="1d0cf-245">웹 응용 프로그램을 만들 때 여기서 여러 동시 사용자가 편집 하 고 동일한 데이터에 동시성 제어 옵션을 고려해 야 할 중요 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-245">When creating a web application where multiple, concurrent users may be editing the same data, it is important to consider concurrency control options.</span></span> <span data-ttu-id="1d0cf-246">기본적으로 ASP.NET 데이터 웹 컨트롤 및 데이터 소스 제어를 사용 하지 않는 모든 동시성 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-246">By default, the ASP.NET data Web controls and data source controls do not employ any concurrency control.</span></span> <span data-ttu-id="1d0cf-247">이 자습서에서 보았듯이 SqlDataSource 사용 하 여 낙관적 동시성 제어를 구현는 비교적 빠르고 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-247">As we saw in this tutorial, implementing optimistic concurrency control with the SqlDataSource is relatively quick and easy.</span></span> <span data-ttu-id="1d0cf-248">SqlDataSource 처리를 투자할 대부분이 보강 사용자 추가 대 한 `WHERE` 절이 자동으로 생성 된 `UPDATE` 및 `DELETE` 제한이 없지만 문은 처리에 몇 가지 미묘한 `NULL` 에 설명 된 대로 열 값을 올바르게 처리 `NULL` 섹션 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-248">The SqlDataSource handles most of the legwork for your adding augmented `WHERE` clauses to the autogenerated `UPDATE` and `DELETE` statements but there are a few subtleties in handling `NULL` value columns, as discussed in the Correctly Handling `NULL` Values section.</span></span>

<span data-ttu-id="1d0cf-249">이 자습서는 SqlDataSource 검사도 마칩니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-249">This tutorial concludes our examination of the SqlDataSource.</span></span> <span data-ttu-id="1d0cf-250">나머지 자습서는 ObjectDataSource, 계층화 된 아키텍처를 사용 하 여 데이터를 사용 하 여 작업 돌아갈 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-250">Our remaining tutorials will return to working with data using the ObjectDataSource and tiered architecture.</span></span>

<span data-ttu-id="1d0cf-251">즐거운 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="1d0cf-251">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="1d0cf-252">저자 소개</span><span class="sxs-lookup"><span data-stu-id="1d0cf-252">About the Author</span></span>

<span data-ttu-id="1d0cf-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적의 저자 이자 설립자입니다 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 Microsoft 웹 기술을 사용 하 여 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="1d0cf-254">Scott는 독립 컨설턴트, 강사, 그리고 기록기로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-254">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="1d0cf-255">최근 저서는 [ *Sams 설명 직접 ASP.NET 2.0 24 시간 동안의*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-255">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="1d0cf-256">그에 도달할 수 있습니다 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="1d0cf-256">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="1d0cf-257">찾을 수 있는 저자의 블로그를 통해 또는 [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="1d0cf-257">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="1d0cf-258">이전</span><span class="sxs-lookup"><span data-stu-id="1d0cf-258">Previous</span></span>](inserting-updating-and-deleting-data-with-the-sqldatasource-vb.md)
