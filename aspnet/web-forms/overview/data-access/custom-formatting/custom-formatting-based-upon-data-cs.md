---
uid: web-forms/overview/data-access/custom-formatting/custom-formatting-based-upon-data-cs
title: 데이터에 따라 사용자 지정 형식C#지정 () | Microsoft Docs
author: rick-anderson
description: 이에 바인딩된 데이터를 기반으로 GridView, DetailsView 또는 FormView의 형식을 조정 하는 것은 여러 가지 방법으로 수행할 수 있습니다. 이 자습서에서는 ...
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 871a4574-f89c-4214-b786-79253ed3653b
msc.legacyurl: /web-forms/overview/data-access/custom-formatting/custom-formatting-based-upon-data-cs
msc.type: authoredcontent
ms.openlocfilehash: d8f3fa337eda0ceed041475ecb52f8b378b9fbba
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/28/2019
ms.locfileid: "74600772"
---
# <a name="custom-formatting-based-upon-data-c"></a><span data-ttu-id="98d18-104">데이터에 따라 사용자 지정 형식 지정(C#)</span><span class="sxs-lookup"><span data-stu-id="98d18-104">Custom Formatting Based Upon Data (C#)</span></span>

<span data-ttu-id="98d18-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="98d18-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="98d18-106">[샘플 앱 다운로드](https://download.microsoft.com/download/9/6/9/969e5c94-dfb6-4e47-9570-d6d9e704c3c1/ASPNET_Data_Tutorial_11_CS.exe) 또는 [PDF 다운로드](custom-formatting-based-upon-data-cs/_static/datatutorial11cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="98d18-106">[Download Sample App](https://download.microsoft.com/download/9/6/9/969e5c94-dfb6-4e47-9570-d6d9e704c3c1/ASPNET_Data_Tutorial_11_CS.exe) or [Download PDF](custom-formatting-based-upon-data-cs/_static/datatutorial11cs1.pdf)</span></span>

> <span data-ttu-id="98d18-107">이에 바인딩된 데이터를 기반으로 GridView, DetailsView 또는 FormView의 형식을 조정 하는 것은 여러 가지 방법으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-107">Adjusting the format of the GridView, DetailsView, or FormView based upon the data bound to it can be accomplished in multiple ways.</span></span> <span data-ttu-id="98d18-108">이 자습서에서는 데이터 바인딩된 및 RowDataBound 바인딩 이벤트 처리기를 사용 하 여 데이터 바인딩된 서식 지정을 수행 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-108">In this tutorial we'll look at how to accomplish data bound formatting through the use of the DataBound and RowDataBound event handlers.</span></span>

## <a name="introduction"></a><span data-ttu-id="98d18-109">소개</span><span class="sxs-lookup"><span data-stu-id="98d18-109">Introduction</span></span>

<span data-ttu-id="98d18-110">많은 스타일 관련 속성을 통해 GridView, DetailsView 및 FormView 컨트롤의 모양을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-110">The appearance of the GridView, DetailsView, and FormView controls can be customized through a myriad of style-related properties.</span></span> <span data-ttu-id="98d18-111">`CssClass`, `Font`, `BorderWidth`, `BorderStyle`, `BorderColor`, `Width`, `Height`등의 속성은 렌더링 된 컨트롤의 일반적인 모양을 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-111">Properties like `CssClass`, `Font`, `BorderWidth`, `BorderStyle`, `BorderColor`, `Width`, and `Height`, among others, dictate the general appearance of the rendered control.</span></span> <span data-ttu-id="98d18-112">`HeaderStyle`, `RowStyle`, `AlternatingRowStyle`등의 속성을 사용 하 여 이러한 동일한 스타일 설정을 특정 섹션에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-112">Properties including `HeaderStyle`, `RowStyle`, `AlternatingRowStyle`, and others allow these same style settings to be applied to particular sections.</span></span> <span data-ttu-id="98d18-113">마찬가지로 이러한 스타일 설정은 필드 수준에서 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-113">Likewise, these style settings can be applied at the field level.</span></span>

<span data-ttu-id="98d18-114">그러나 많은 시나리오에서 서식 지정 요구 사항은 표시 된 데이터의 값에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-114">In many scenarios though, the formatting requirements depend upon the value of the displayed data.</span></span> <span data-ttu-id="98d18-115">예를 들어 품절 제품에 주목 하기 위해 제품 정보를 표시 하는 보고서는 `UnitsInStock` 및 `UnitsOnOrder` 필드가 모두 0 인 제품에 대해 배경색을 노란색으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-115">For example, to draw attention to out of stock products, a report listing product information might set the background color to yellow for those products whose `UnitsInStock` and `UnitsOnOrder` fields are both equal to 0.</span></span> <span data-ttu-id="98d18-116">비용이 많이 드는 제품을 강조 하기 위해 이러한 제품의 가격을 굵게 표시 하는 글꼴을 $75.00 이상으로 표시 하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-116">To highlight the more expensive products, we may want to display the prices of those products costing more than $75.00 in a bold font.</span></span>

<span data-ttu-id="98d18-117">이에 바인딩된 데이터를 기반으로 GridView, DetailsView 또는 FormView의 형식을 조정 하는 것은 여러 가지 방법으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-117">Adjusting the format of the GridView, DetailsView, or FormView based upon the data bound to it can be accomplished in multiple ways.</span></span> <span data-ttu-id="98d18-118">이 자습서에서는 `DataBound` 및 `RowDataBound` 이벤트 처리기를 사용 하 여 데이터 바인딩된 서식 지정을 수행 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-118">In this tutorial we'll look at how to accomplish data bound formatting through the use of the `DataBound` and `RowDataBound` event handlers.</span></span> <span data-ttu-id="98d18-119">다음 자습서에서는 다른 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-119">In the next tutorial we'll explore an alternative approach.</span></span>

## <a name="using-the-detailsview-controlsdataboundevent-handler"></a><span data-ttu-id="98d18-120">DetailsView 컨트롤의`DataBound`이벤트 처리기 사용</span><span class="sxs-lookup"><span data-stu-id="98d18-120">Using the DetailsView Control's`DataBound`Event Handler</span></span>

<span data-ttu-id="98d18-121">데이터 소스 컨트롤이 나 컨트롤의 `DataSource` 속성에 데이터를 프로그래밍 방식으로 할당 하 고 해당 `DataBind()` 메서드를 호출 하 여 데이터를 DetailsView에 바인딩하면 다음과 같은 일련의 단계가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-121">When data is bound to a DetailsView, either from a data source control or through programmatically assigning data to the control's `DataSource` property and calling its `DataBind()` method, the following sequence of steps occur:</span></span>

1. <span data-ttu-id="98d18-122">데이터 웹 컨트롤의 `DataBinding` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-122">The data Web control's `DataBinding` event fires.</span></span>
2. <span data-ttu-id="98d18-123">데이터는 데이터 웹 컨트롤에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-123">The data is bound to the data Web control.</span></span>
3. <span data-ttu-id="98d18-124">데이터 웹 컨트롤의 `DataBound` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-124">The data Web control's `DataBound` event fires.</span></span>

<span data-ttu-id="98d18-125">사용자 지정 논리는 이벤트 처리기를 통해 1 단계 및 3 단계 바로 뒤에 삽입 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-125">Custom logic can be injected immediately after steps 1 and 3 through an event handler.</span></span> <span data-ttu-id="98d18-126">`DataBound` 이벤트에 대 한 이벤트 처리기를 만들어 데이터 웹 컨트롤에 바인딩된 데이터를 프로그래밍 방식으로 확인 하 고 필요에 따라 형식을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-126">By creating an event handler for the `DataBound` event we can programmatically determine the data that has been bound to the data Web control and adjust the formatting as needed.</span></span> <span data-ttu-id="98d18-127">이를 설명 하기 위해 제품에 대 한 일반 정보를 나열 하는 DetailsView을 만들어 $75.00를 초과 하는 경우 ***굵은 기울임꼴 글꼴로*** `UnitPrice` 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-127">To illustrate this let's create a DetailsView that will list general information about a product, but will display the `UnitPrice` value in a ***bold, italic font*** if it exceeds $75.00.</span></span>

## <a name="step-1-displaying-the-product-information-in-a-detailsview"></a><span data-ttu-id="98d18-128">1 단계: DetailsView에서 제품 정보 표시</span><span class="sxs-lookup"><span data-stu-id="98d18-128">Step 1: Displaying the Product Information in a DetailsView</span></span>

<span data-ttu-id="98d18-129">`CustomFormatting` 폴더에서 `CustomColors.aspx` 페이지를 열고, 도구 상자에서 DetailsView 컨트롤을 디자이너로 끌고, `ID` 속성 값을 `ExpensiveProductsPriceInBoldItalic`로 설정 하 고, `ProductsBLL` 클래스의 `GetProducts()` 메서드를 호출 하는 새 ObjectDataSource 컨트롤에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-129">Open the `CustomColors.aspx` page in the `CustomFormatting` folder, drag a DetailsView control from the Toolbox onto the Designer, set its `ID` property value to `ExpensiveProductsPriceInBoldItalic`, and bind it to a new ObjectDataSource control that invokes the `ProductsBLL` class's `GetProducts()` method.</span></span> <span data-ttu-id="98d18-130">이 작업을 수행 하는 자세한 단계는 앞의 자습서에서 자세히 검토 했으므로 간략하게 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-130">The detailed steps for accomplishing this are omitted here for brevity since we examined them in detail in previous tutorials.</span></span>

<span data-ttu-id="98d18-131">ObjectDataSource를 DetailsView에 바인딩한 후에는 잠시 시간을 사용 하 여 필드 목록을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-131">Once you've bound the ObjectDataSource to the DetailsView, take a moment to modify the field list.</span></span> <span data-ttu-id="98d18-132">`ProductID`, `SupplierID`, `CategoryID`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`및 `Discontinued` BoundFields를 제거 하 고 나머지 BoundFields의 이름을 바꾸고 다시 포맷 했습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-132">I've opted to remove the `ProductID`, `SupplierID`, `CategoryID`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued` BoundFields and renamed and reformatted the remaining BoundFields.</span></span> <span data-ttu-id="98d18-133">또한 `Width` 및 `Height` 설정을 해제 했습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-133">I also cleared out the `Width` and `Height` settings.</span></span> <span data-ttu-id="98d18-134">DetailsView에는 단일 레코드만 표시 되므로 최종 사용자가 모든 제품을 볼 수 있도록 하려면 페이징을 사용 하도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-134">Since the DetailsView displays only a single record, we need to enable paging in order to allow the end user to view all of the products.</span></span> <span data-ttu-id="98d18-135">이렇게 하려면 DetailsView의 스마트 태그에서 페이징 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-135">Do so by checking the Enable Paging checkbox in the DetailsView's smart tag.</span></span>

<span data-ttu-id="98d18-136">[![DetailsView의 스마트 태그에서 페이징 사용 확인란을 선택 합니다.](custom-formatting-based-upon-data-cs/_static/image2.png)](custom-formatting-based-upon-data-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-136">[![Check the Enable Paging Checkbox in the DetailsView's Smart Tag](custom-formatting-based-upon-data-cs/_static/image2.png)](custom-formatting-based-upon-data-cs/_static/image1.png)</span></span>

<span data-ttu-id="98d18-137">**그림 1**: DetailsView의 스마트 태그에서 페이징 사용 확인란을 선택 합니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image3.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-137">**Figure 1**: Check the Enable Paging Checkbox in the DetailsView's Smart Tag ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image3.png))</span></span>

<span data-ttu-id="98d18-138">이러한 변경 후에는 DetailsView 태그가 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-138">After these changes, the DetailsView markup will be:</span></span>

[!code-aspx[Main](custom-formatting-based-upon-data-cs/samples/sample1.aspx)]

<span data-ttu-id="98d18-139">잠시 시간을 들 여 브라우저에서이 페이지를 테스트해 보세요.</span><span class="sxs-lookup"><span data-stu-id="98d18-139">Take a moment to test out this page in your browser.</span></span>

<span data-ttu-id="98d18-140">[DetailsView 컨트롤 ![한 번에 하나의 제품을 표시 합니다.](custom-formatting-based-upon-data-cs/_static/image5.png)](custom-formatting-based-upon-data-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-140">[![The DetailsView Control Displays One Product at a Time](custom-formatting-based-upon-data-cs/_static/image5.png)](custom-formatting-based-upon-data-cs/_static/image4.png)</span></span>

<span data-ttu-id="98d18-141">**그림 2**: DetailsView 컨트롤은 한 번에 하나의 제품을 표시 합니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image6.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-141">**Figure 2**: The DetailsView Control Displays One Product at a Time ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image6.png))</span></span>

## <a name="step-2-programmatically-determining-the-value-of-the-data-in-the-databound-event-handler"></a><span data-ttu-id="98d18-142">2 단계: 데이터 바인딩된 이벤트 처리기에서 프로그래밍 방식으로 데이터 값 확인</span><span class="sxs-lookup"><span data-stu-id="98d18-142">Step 2: Programmatically Determining the Value of the Data in the DataBound Event Handler</span></span>

<span data-ttu-id="98d18-143">`UnitPrice` 값이 $75.00를 초과 하는 제품에 대 한 굵게 기울임꼴 글꼴로 가격을 표시 하기 위해 먼저 `UnitPrice` 값을 프로그래밍 방식으로 확인할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-143">In order to display the price in a bold, italic font for those products whose `UnitPrice` value exceeds $75.00, we need to first be able to programmatically determine the `UnitPrice` value.</span></span> <span data-ttu-id="98d18-144">DetailsView의 경우 `DataBound` 이벤트 처리기에서이를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-144">For the DetailsView, this can be accomplished in the `DataBound` event handler.</span></span> <span data-ttu-id="98d18-145">이벤트 처리기를 만들려면 디자이너에서 DetailsView를 클릭 한 다음 속성 창로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-145">To create the event handler click on the DetailsView in the Designer then navigate to the Properties window.</span></span> <span data-ttu-id="98d18-146">표시 되지 않으면 F4 키를 누르거나 보기 메뉴로 이동 하 여 속성 창 메뉴 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-146">Press F4 to bring it up, if it's not visible, or go to the View menu and select the Properties Window menu option.</span></span> <span data-ttu-id="98d18-147">속성 창에서 번개 볼트 아이콘을 클릭 하 여 DetailsView의 이벤트를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-147">From the Properties window, click on the lightning bolt icon to list the DetailsView's events.</span></span> <span data-ttu-id="98d18-148">그런 다음 `DataBound` 이벤트를 두 번 클릭 하거나 만들려는 이벤트 처리기의 이름을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-148">Next, either double-click the `DataBound` event or type in the name of the event handler you want to create.</span></span>

![데이터 바인딩된 이벤트에 대 한 이벤트 처리기 만들기](custom-formatting-based-upon-data-cs/_static/image7.png)

<span data-ttu-id="98d18-150">**그림 3**: `DataBound` 이벤트에 대 한 이벤트 처리기 만들기</span><span class="sxs-lookup"><span data-stu-id="98d18-150">**Figure 3**: Create an Event Handler for the `DataBound` Event</span></span>

<span data-ttu-id="98d18-151">이렇게 하면 이벤트 처리기가 자동으로 생성 되 고 추가 된 코드 부분으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-151">Doing so will automatically create the event handler and take you to the code portion where it has been added.</span></span> <span data-ttu-id="98d18-152">이 시점에서 다음을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-152">At this point you will see:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample2.cs)]

<span data-ttu-id="98d18-153">DetailsView에 바인딩된 데이터는 `DataItem` 속성을 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-153">The data bound to the DetailsView can be accessed via the `DataItem` property.</span></span> <span data-ttu-id="98d18-154">강력한 형식의 DataRow 인스턴스 컬렉션으로 구성 된 강력한 형식의 DataTable에 컨트롤을 바인딩하는 것을 기억 하세요.</span><span class="sxs-lookup"><span data-stu-id="98d18-154">Recall that we are binding our controls to a strongly-typed DataTable, which is composed of a collection of strongly-typed DataRow instances.</span></span> <span data-ttu-id="98d18-155">DataTable이 DetailsView에 바인딩되면 DataTable의 첫 번째 DataRow가 DetailsView의 `DataItem` 속성에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-155">When the DataTable is bound to the DetailsView, the first DataRow in the DataTable is assigned to the DetailsView's `DataItem` property.</span></span> <span data-ttu-id="98d18-156">특히 `DataItem` 속성에 `DataRowView` 개체가 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-156">Specifically, the `DataItem` property is assigned a `DataRowView` object.</span></span> <span data-ttu-id="98d18-157">`DataRowView`의 `Row` 속성을 사용 하 여 실제로 `ProductsRow` 인스턴스인 기본 DataRow 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-157">We can use the `DataRowView`'s `Row` property to get access to the underlying DataRow object, which is actually a `ProductsRow` instance.</span></span> <span data-ttu-id="98d18-158">이 `ProductsRow` 인스턴스가 있으면 단순히 개체의 속성 값을 검사 하 여 결정을 내릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-158">Once we have this `ProductsRow` instance we can make our decision by simply inspecting the object's property values.</span></span>

<span data-ttu-id="98d18-159">다음 코드에서는 DetailsView 컨트롤에 바인딩되는 `UnitPrice` 값이 $75.00 보다 큰지 여부를 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-159">The following code illustrates how to determine whether the `UnitPrice` value bound to the DetailsView control is greater than $75.00:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample3.cs)]

> [!NOTE]
> <span data-ttu-id="98d18-160">`UnitPrice`는 데이터베이스에 `NULL` 값이 있을 수 있으므로 먼저 `ProductsRow`의 `UnitPrice` 속성에 액세스 하기 전에 `NULL` 값을 처리 하 고 있지 않은지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-160">Since `UnitPrice` can have a `NULL` value in the database, we first check to make sure that we're not dealing with a `NULL` value before accessing the `ProductsRow`'s `UnitPrice` property.</span></span> <span data-ttu-id="98d18-161">이 검사는 `NULL` 값이 있을 때 `UnitPrice` 속성에 액세스 하려고 하면 `ProductsRow` 개체가 [StrongTypingException 예외](https://msdn.microsoft.com/library/system.data.strongtypingexception.aspx)를 throw 하기 때문에 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-161">This check is important because if we attempt to access the `UnitPrice` property when it has a `NULL` value the `ProductsRow` object will throw a [StrongTypingException exception](https://msdn.microsoft.com/library/system.data.strongtypingexception.aspx).</span></span>

## <a name="step-3-formatting-the-unitprice-value-in-the-detailsview"></a><span data-ttu-id="98d18-162">3 단계: DetailsView에서 UnitPrice 값 서식 지정</span><span class="sxs-lookup"><span data-stu-id="98d18-162">Step 3: Formatting the UnitPrice Value in the DetailsView</span></span>

<span data-ttu-id="98d18-163">이 시점에서 DetailsView에 바인딩된 `UnitPrice` 값에 $75.00을 초과 하는 값이 있는지 여부를 확인할 수 있지만이에 따라 DetailsView의 형식을 프로그래밍 방식으로 조정 하는 방법을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-163">At this point we can determine whether the `UnitPrice` value bound to the DetailsView has a value that exceeds $75.00, but we've yet to see how to programmatically adjust the DetailsView's formatting accordingly.</span></span> <span data-ttu-id="98d18-164">DetailsView에서 전체 행의 서식을 수정 하려면 `DetailsViewID.Rows[index]`을 사용 하 여 프로그래밍 방식으로 행에 액세스 합니다. 특정 셀을 수정 하려면 access `DetailsViewID.Rows[index].Cells[index]`를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-164">To modify the formatting of an entire row in the DetailsView, programmatically access the row using `DetailsViewID.Rows[index]`; to modify a particular cell, access use `DetailsViewID.Rows[index].Cells[index]`.</span></span> <span data-ttu-id="98d18-165">행 또는 셀에 대 한 참조가 있으면 스타일 관련 속성을 설정 하 여 모양을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-165">Once we have a reference to the row or cell we can then adjust its appearance by setting its style-related properties.</span></span>

<span data-ttu-id="98d18-166">행에 프로그래밍 방식으로 액세스 하려면 행의 인덱스 (0부터 시작)를 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-166">Accessing a row programmatically requires that you know the row's index, which starts at 0.</span></span> <span data-ttu-id="98d18-167">`UnitPrice` 행은 DetailsView에서 5 번째 행 이며 인덱스 4를 제공 하 고 `ExpensiveProductsPriceInBoldItalic.Rows[4]`를 사용 하 여 프로그래밍 방식으로 액세스할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-167">The `UnitPrice` row is the fifth row in the DetailsView, giving it an index of 4 and making it programmatically accessible using `ExpensiveProductsPriceInBoldItalic.Rows[4]`.</span></span> <span data-ttu-id="98d18-168">이 시점에서 다음 코드를 사용 하 여 전체 행의 내용이 굵은 기울임꼴 글꼴로 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-168">At this point we could have the entire row's content displayed in a bold, italic font by using the following code:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample4.cs)]

<span data-ttu-id="98d18-169">그러나 *이렇게 하면 레이블* (Price) 및 값이 굵게 표시 되 고 기울임꼴로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-169">However, this will make *both* the label (Price) and the value bold and italic.</span></span> <span data-ttu-id="98d18-170">값을 굵게 표시 하 고 기울임꼴로 표시 하려는 경우 다음을 사용 하 여이 서식을 행의 두 번째 셀에 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-170">If we want to make just the value bold and italic we need to apply this formatting to the second cell in the row, which can be accomplished using the following:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample5.cs)]

<span data-ttu-id="98d18-171">이 자습서에서는 앞에서 설명한 대로 특정 스타일 속성을 설정 하는 대신 스타일 시트를 사용 하 여 렌더링 된 태그와 스타일 관련 정보를 명확 하 게 분리 하므로 스타일 시트 클래스를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-171">Since our tutorials thus far have used stylesheets to maintain a clean separation between the rendered markup and style-related information, rather than setting the specific style properties as shown above let's instead use a CSS class.</span></span> <span data-ttu-id="98d18-172">`Styles.css` 스타일 시트를 열고 다음 정의를 사용 하 여 `ExpensivePriceEmphasis` 라는 새 CSS 클래스를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-172">Open the `Styles.css` stylesheet and add a new CSS class named `ExpensivePriceEmphasis` with the following definition:</span></span>

[!code-css[Main](custom-formatting-based-upon-data-cs/samples/sample6.css)]

<span data-ttu-id="98d18-173">그런 다음 `DataBound` 이벤트 처리기에서 셀의 `CssClass` 속성을 `ExpensivePriceEmphasis`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-173">Then, in the `DataBound` event handler, set the cell's `CssClass` property to `ExpensivePriceEmphasis`.</span></span> <span data-ttu-id="98d18-174">다음 코드에서는 `DataBound` 이벤트 처리기를 전체적으로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-174">The following code shows the `DataBound` event handler in its entirety:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample7.cs)]

<span data-ttu-id="98d18-175">$75.00 보다 저렴 한 Chai 볼 때 가격은 일반 글꼴로 표시 됩니다 (그림 4 참조).</span><span class="sxs-lookup"><span data-stu-id="98d18-175">When viewing Chai, which costs less than $75.00, the price is displayed in a normal font (see Figure 4).</span></span> <span data-ttu-id="98d18-176">그러나 가격이 $97.00 인 Mishi Kobe Niku를 볼 때 가격은 굵은 기울임꼴 글꼴로 표시 됩니다 (그림 5 참조).</span><span class="sxs-lookup"><span data-stu-id="98d18-176">However, when viewing Mishi Kobe Niku, which has a price of $97.00, the price is displayed in a bold, italic font (see Figure 5).</span></span>

<span data-ttu-id="98d18-177">[$75.00 보다 작은 ![가격은 일반 글꼴로 표시 됩니다.](custom-formatting-based-upon-data-cs/_static/image9.png)](custom-formatting-based-upon-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-177">[![Prices Less than $75.00 are Displayed in a Normal Font](custom-formatting-based-upon-data-cs/_static/image9.png)](custom-formatting-based-upon-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="98d18-178">**그림 4**: $75.00 보다 작은 가격은 일반 글꼴로 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image10.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-178">**Figure 4**: Prices Less than $75.00 are Displayed in a Normal Font ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image10.png))</span></span>

<span data-ttu-id="98d18-179">[![고가의 제품 가격은 굵은 기울임꼴 글꼴로 표시 됩니다.](custom-formatting-based-upon-data-cs/_static/image12.png)](custom-formatting-based-upon-data-cs/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-179">[![Expensive Products' Prices are Displayed in a Bold, Italic Font](custom-formatting-based-upon-data-cs/_static/image12.png)](custom-formatting-based-upon-data-cs/_static/image11.png)</span></span>

<span data-ttu-id="98d18-180">**그림 5**: 고가의 제품 가격은 굵은 기울임꼴 글꼴로 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image13.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-180">**Figure 5**: Expensive Products' Prices are Displayed in a Bold, Italic Font ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image13.png))</span></span>

## <a name="using-the-formview-controlsdataboundevent-handler"></a><span data-ttu-id="98d18-181">FormView 컨트롤의`DataBound`이벤트 처리기 사용</span><span class="sxs-lookup"><span data-stu-id="98d18-181">Using the FormView Control's`DataBound`Event Handler</span></span>

<span data-ttu-id="98d18-182">FormView에 바인딩된 내부 데이터를 확인 하는 단계는 DetailsView의 `DataBound` 이벤트 처리기를 만드는 단계와 동일 하며 `DataItem` 속성을 컨트롤에 바인딩된 적절 한 개체 형식으로 캐스팅 하 고 진행 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-182">The steps for determining the underlying data bound to a FormView are identical to those for a DetailsView create a `DataBound` event handler, cast the `DataItem` property to the appropriate object type bound to the control, and determine how to proceed.</span></span> <span data-ttu-id="98d18-183">그러나 FormView와 DetailsView은 사용자 인터페이스 모양이 업데이트 되는 방식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-183">The FormView and DetailsView differ, however, in how their user interface's appearance is updated.</span></span>

<span data-ttu-id="98d18-184">FormView에 BoundFields가 포함 되어 있지 않으므로 `Rows` 컬렉션이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-184">The FormView does not contain any BoundFields and therefore lacks the `Rows` collection.</span></span> <span data-ttu-id="98d18-185">대신 FormView는 정적 HTML, 웹 컨트롤 및 데이터 바인딩 구문이 혼합 되어 있을 수 있는 템플릿으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-185">Instead, a FormView is composed of templates, which can contain a mix of static HTML, Web controls, and databinding syntax.</span></span> <span data-ttu-id="98d18-186">FormView의 스타일을 조정 하려면 일반적으로 FormView의 템플릿 내에서 하나 이상의 웹 컨트롤 스타일을 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-186">Adjusting the style of a FormView typically involves adjusting the style of one or more of the Web controls within the FormView's templates.</span></span>

<span data-ttu-id="98d18-187">이를 설명 하기 위해 FormView를 사용 하 여 이전 예제와 같은 제품을 나열 해 보겠습니다. 하지만 이번에는 재고 단위가 10 보다 작거나 같은 경우 빨간색 글꼴로 표시 되는 재고의 제품 이름과 단위도 표시 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-187">To illustrate this, let's use a FormView to list products like in the previous example, but this time let's display just the product name and units in stock with the units in stock displayed in a red font if it is less than or equal to 10.</span></span>

## <a name="step-4-displaying-the-product-information-in-a-formview"></a><span data-ttu-id="98d18-188">4 단계: FormView에서 제품 정보 표시</span><span class="sxs-lookup"><span data-stu-id="98d18-188">Step 4: Displaying the Product Information in a FormView</span></span>

<span data-ttu-id="98d18-189">DetailsView 아래 `CustomColors.aspx` 페이지에 FormView를 추가 하 고 `ID` 속성을 `LowStockedProductsInRed`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-189">Add a FormView to the `CustomColors.aspx` page beneath the DetailsView and set its `ID` property to `LowStockedProductsInRed`.</span></span> <span data-ttu-id="98d18-190">FormView를 이전 단계에서 만든 ObjectDataSource 컨트롤에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-190">Bind the FormView to the ObjectDataSource control created from the previous step.</span></span> <span data-ttu-id="98d18-191">이렇게 하면 FormView에 대 한 `ItemTemplate`, `EditItemTemplate`및 `InsertItemTemplate` 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-191">This will create an `ItemTemplate`, `EditItemTemplate`, and `InsertItemTemplate` for the FormView.</span></span> <span data-ttu-id="98d18-192">`EditItemTemplate`를 제거 하 고 `InsertItemTemplate` `ItemTemplate`를 간소화 하 여 각각의 적절 하 게 명명 된 레이블 컨트롤에 `ProductName` 및 `UnitsInStock` 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-192">Remove the `EditItemTemplate` and `InsertItemTemplate` and simplify the `ItemTemplate` to include just the `ProductName` and `UnitsInStock` values, each in their own appropriately-named Label controls.</span></span> <span data-ttu-id="98d18-193">이전 예제에서 DetailsView와 마찬가지로 FormView의 스마트 태그에서 페이징 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-193">As with the DetailsView from the earlier example, also check the Enable Paging checkbox in the FormView's smart tag.</span></span>

<span data-ttu-id="98d18-194">이러한 편집 후에는 FormView의 태그가 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-194">After these edits your FormView's markup should look similar to the following:</span></span>

[!code-aspx[Main](custom-formatting-based-upon-data-cs/samples/sample8.aspx)]

<span data-ttu-id="98d18-195">`ItemTemplate`에는 다음이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-195">Note that the `ItemTemplate` contains:</span></span>

- <span data-ttu-id="98d18-196">**정적 HTML** 텍스트 "Product:" 및 "Unit In Stock:"은 `<br />` 및 `<b>` 요소와 함께 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-196">**Static HTML** the text "Product:" and "Units In Stock:" along with the `<br />` and `<b>` elements.</span></span>
- <span data-ttu-id="98d18-197">**웹** 에서는 두 개의 레이블 컨트롤 `ProductNameLabel` 및 `UnitsInStockLabel`를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-197">**Web controls** the two Label controls, `ProductNameLabel` and `UnitsInStockLabel`.</span></span>
- <span data-ttu-id="98d18-198">**데이터 바인딩 구문** 이러한 필드의 값을 레이블 컨트롤의 `Text` 속성에 할당 하는 `<%# Bind("ProductName") %>` 및 `<%# Bind("UnitsInStock") %>` 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-198">**Databinding syntax** the `<%# Bind("ProductName") %>` and `<%# Bind("UnitsInStock") %>` syntax, which assigns the values from these fields to the Label controls' `Text` properties.</span></span>

## <a name="step-5-programmatically-determining-the-value-of-the-data-in-the-databound-event-handler"></a><span data-ttu-id="98d18-199">5 단계: 데이터 바인딩된 이벤트 처리기에서 프로그래밍 방식으로 데이터 값 확인</span><span class="sxs-lookup"><span data-stu-id="98d18-199">Step 5: Programmatically Determining the Value of the Data in the DataBound Event Handler</span></span>

<span data-ttu-id="98d18-200">FormView의 태그가 완료 되 면 다음 단계는 `UnitsInStock` 값이 10 보다 작거나 같은지를 프로그래밍 방식으로 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-200">With the FormView's markup complete, the next step is to programmatically determine if the `UnitsInStock` value is less than or equal to 10.</span></span> <span data-ttu-id="98d18-201">이는 DetailsView과 동일한 방식으로 FormView와 정확히 동일한 방법으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-201">This is accomplished in the exact same manner with the FormView as it was with the DetailsView.</span></span> <span data-ttu-id="98d18-202">먼저 FormView의 `DataBound` 이벤트에 대 한 이벤트 처리기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-202">Start by creating an event handler for the FormView's `DataBound` event.</span></span>

![데이터 바인딩된 이벤트 처리기 만들기](custom-formatting-based-upon-data-cs/_static/image14.png)

<span data-ttu-id="98d18-204">**그림 6**: `DataBound` 이벤트 처리기 만들기</span><span class="sxs-lookup"><span data-stu-id="98d18-204">**Figure 6**: Create the `DataBound` Event Handler</span></span>

<span data-ttu-id="98d18-205">이벤트 처리기에서 FormView의 `DataItem` 속성을 `ProductsRow` 인스턴스로 캐스팅 하 고 `UnitsInPrice` 값이 빨간색 글꼴로 표시 되어야 하는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-205">In the event handler cast the FormView's `DataItem` property to a `ProductsRow` instance and determine whether the `UnitsInPrice` value is such that we need to display it in a red font.</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample9.cs)]

## <a name="step-6-formatting-the-unitsinstocklabel-label-control-in-the-formviews-itemtemplate"></a><span data-ttu-id="98d18-206">6 단계: FormView의 ItemTemplate에서 UnitsInStockLabel Label 컨트롤 서식 지정</span><span class="sxs-lookup"><span data-stu-id="98d18-206">Step 6: Formatting the UnitsInStockLabel Label Control in the FormView's ItemTemplate</span></span>

<span data-ttu-id="98d18-207">마지막 단계는 값이 10 이하인 경우 표시 되는 `UnitsInStock` 값을 빨간색 글꼴로 서식 지정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-207">The final step is to format the displayed `UnitsInStock` value in a red font if the value is 10 or less.</span></span> <span data-ttu-id="98d18-208">이를 수행 하려면 `ItemTemplate`에서 `UnitsInStockLabel` 컨트롤에 프로그래밍 방식으로 액세스 하 고 해당 텍스트가 빨간색으로 표시 되도록 스타일 속성을 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-208">To accomplish this we need to programmatically access the `UnitsInStockLabel` control in the `ItemTemplate` and set its style properties so that its text is displayed in red.</span></span> <span data-ttu-id="98d18-209">템플릿에서 웹 컨트롤에 액세스 하려면 다음과 같이 `FindControl("controlID")` 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-209">To access a Web control in a template, use the `FindControl("controlID")` method like this:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample10.cs)]

<span data-ttu-id="98d18-210">이 예제에서는 `ID` 값이 `UnitsInStockLabel`레이블 컨트롤에 액세스 하려고 하므로 다음을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-210">For our example we want to access a Label control whose `ID` value is `UnitsInStockLabel`, so we'd use:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample11.cs)]

<span data-ttu-id="98d18-211">웹 컨트롤에 대 한 프로그래밍 참조가 있으면 필요에 따라 스타일 관련 속성을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-211">Once we have a programmatic reference to the Web control, we can modify its style-related properties as needed.</span></span> <span data-ttu-id="98d18-212">이전 예제와 마찬가지로 `LowUnitsInStockEmphasis`라는 `Styles.css`에서 CSS 클래스를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-212">As with the earlier example, I've created a CSS class in `Styles.css` named `LowUnitsInStockEmphasis`.</span></span> <span data-ttu-id="98d18-213">Label 웹 컨트롤에이 스타일을 적용 하려면 해당 `CssClass` 속성을 적절 하 게 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-213">To apply this style to the Label Web control, set its `CssClass` property accordingly.</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample12.cs)]

> [!NOTE]
> <span data-ttu-id="98d18-214">템플릿 서식을 지정 하는 구문은 `FindControl("controlID")`를 사용 하 여 웹 컨트롤에 프로그래밍 방식으로 액세스 한 다음, DetailsView 또는 GridView 컨트롤에서 템플릿 [필드](https://msdn.microsoft.com/library/system.web.ui.webcontrols.templatefield(VS.80).aspx) 를 사용 하는 경우에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-214">The syntax for formatting a template programmatically accessing the Web control using `FindControl("controlID")` and then setting its style-related properties can also be used when using [TemplateFields](https://msdn.microsoft.com/library/system.web.ui.webcontrols.templatefield(VS.80).aspx) in the DetailsView or GridView controls.</span></span> <span data-ttu-id="98d18-215">다음 자습서에서 템플릿 필드를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-215">We'll examine TemplateFields in our next tutorial.</span></span>

<span data-ttu-id="98d18-216">그림 7에는 `UnitsInStock` 값이 10 보다 큰 제품을 볼 때 FormView가 표시 되 고, 그림 8의 제품에는 10 보다 작은 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-216">Figures 7 shows the FormView when viewing a product whose `UnitsInStock` value is greater than 10, while the product in Figure 8 has its value less than 10.</span></span>

<span data-ttu-id="98d18-217">[재고가 충분히 많은 제품 ![사용자 지정 서식 지정이 적용 되지 않습니다.](custom-formatting-based-upon-data-cs/_static/image16.png)](custom-formatting-based-upon-data-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-217">[![For Products With a Sufficiently Large Units In Stock, No Custom Formatting is Applied](custom-formatting-based-upon-data-cs/_static/image16.png)](custom-formatting-based-upon-data-cs/_static/image15.png)</span></span>

<span data-ttu-id="98d18-218">**그림 7**: 재고에 충분히 큰 단위가 포함 된 제품의 경우 사용자 지정 서식 지정이 적용 되지 않음 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="98d18-218">**Figure 7**: For Products With a Sufficiently Large Units In Stock, No Custom Formatting is Applied ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image17.png))</span></span>

<span data-ttu-id="98d18-219">[값이 10 이하인 제품에 대해 재고 번호 단위를 빨간색으로 표시 ![](custom-formatting-based-upon-data-cs/_static/image19.png)](custom-formatting-based-upon-data-cs/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-219">[![The Units in Stock Number is Shown in Red for Those Products With Values of 10 or Less](custom-formatting-based-upon-data-cs/_static/image19.png)](custom-formatting-based-upon-data-cs/_static/image18.png)</span></span>

<span data-ttu-id="98d18-220">**그림 8**: 10 이하의 값을 포함 하는 제품에 대해 재고 번호 단위는 빨간색으로 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image20.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-220">**Figure 8**: The Units in Stock Number is Shown in Red for Those Products With Values of 10 or Less ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image20.png))</span></span>

## <a name="formatting-with-the-gridviewsrowdataboundevent"></a><span data-ttu-id="98d18-221">GridView의`RowDataBound`이벤트로 서식 지정</span><span class="sxs-lookup"><span data-stu-id="98d18-221">Formatting with the GridView's`RowDataBound`Event</span></span>

<span data-ttu-id="98d18-222">이전에는 DetailsView 및 FormView가 데이터 바인딩 중에 진행률을 제어 하는 단계의 순서를 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-222">Earlier we examined the sequence of steps the DetailsView and FormView controls progress through during databinding.</span></span> <span data-ttu-id="98d18-223">이러한 단계를 다시 리프레셔로 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-223">Let's look over these steps once again as a refresher.</span></span>

1. <span data-ttu-id="98d18-224">데이터 웹 컨트롤의 `DataBinding` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-224">The data Web control's `DataBinding` event fires.</span></span>
2. <span data-ttu-id="98d18-225">데이터는 데이터 웹 컨트롤에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-225">The data is bound to the data Web control.</span></span>
3. <span data-ttu-id="98d18-226">데이터 웹 컨트롤의 `DataBound` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-226">The data Web control's `DataBound` event fires.</span></span>

<span data-ttu-id="98d18-227">이 세 가지 간단한 단계는 단일 레코드만 표시 하므로 DetailsView 및 FormView에 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-227">These three simple steps are sufficient for the DetailsView and FormView because they display only a single record.</span></span> <span data-ttu-id="98d18-228">GridView에 바인딩된 *모든* 레코드를 표시 하는 경우 (첫 번째만이 아니라) 2 단계는 약간 더 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-228">For the GridView, which displays *all* records bound to it (not just the first), step 2 is a bit more involved.</span></span>

<span data-ttu-id="98d18-229">2 단계에서 GridView는 데이터 소스를 열거 하 고 각 레코드에 대해 `GridViewRow` 인스턴스를 만들고 현재 레코드를 여기에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-229">In step 2 the GridView enumerates the data source and, for each record, creates a `GridViewRow` instance and binds the current record to it.</span></span> <span data-ttu-id="98d18-230">GridView에 추가 된 각 `GridViewRow`에 대해 두 개의 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-230">For each `GridViewRow` added to the GridView, two events are raised:</span></span>

- <span data-ttu-id="98d18-231">`GridViewRow`를 만든 후에 **`RowCreated`** 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-231">**`RowCreated`** fires after the `GridViewRow` has been created</span></span>
- <span data-ttu-id="98d18-232">**`RowDataBound`** 현재 레코드가 `GridViewRow`바인딩된 후에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-232">**`RowDataBound`** fires after the current record has been bound to the `GridViewRow`.</span></span>

<span data-ttu-id="98d18-233">GridView의 경우 다음과 같은 일련의 단계를 통해 데이터 바인딩을 보다 정확 하 게 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-233">For the GridView, then, data binding is more accurately described by the following sequence of steps:</span></span>

1. <span data-ttu-id="98d18-234">GridView의 `DataBinding` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-234">The GridView's `DataBinding` event fires.</span></span>
2. <span data-ttu-id="98d18-235">데이터가 GridView에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-235">The data is bound to the GridView.</span></span>   
  
   <span data-ttu-id="98d18-236">데이터 원본의 각 레코드에 대해</span><span class="sxs-lookup"><span data-stu-id="98d18-236">For each record in the data source</span></span> 

    1. <span data-ttu-id="98d18-237">`GridViewRow` 개체 만들기</span><span class="sxs-lookup"><span data-stu-id="98d18-237">Create a `GridViewRow` object</span></span>
    2. <span data-ttu-id="98d18-238">`RowCreated` 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-238">Fire the `RowCreated` event</span></span>
    3. <span data-ttu-id="98d18-239">레코드를 `GridViewRow`에 바인딩</span><span class="sxs-lookup"><span data-stu-id="98d18-239">Bind the record to the `GridViewRow`</span></span>
    4. <span data-ttu-id="98d18-240">`RowDataBound` 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-240">Fire the `RowDataBound` event</span></span>
    5. <span data-ttu-id="98d18-241">`Rows` 컬렉션에 `GridViewRow` 추가</span><span class="sxs-lookup"><span data-stu-id="98d18-241">Add the `GridViewRow` to the `Rows` collection</span></span>
3. <span data-ttu-id="98d18-242">GridView의 `DataBound` 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-242">The GridView's `DataBound` event fires.</span></span>

<span data-ttu-id="98d18-243">GridView의 개별 레코드 형식을 사용자 지정 하려면 `RowDataBound` 이벤트에 대 한 이벤트 처리기를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-243">To customize the format of the GridView's individual records, then, we need to create an event handler for the `RowDataBound` event.</span></span> <span data-ttu-id="98d18-244">이를 설명 하기 위해 `CustomColors.aspx` 페이지에 GridView를 추가 해 보겠습니다. 여기에는 각 제품에 대 한 이름, 범주 및 가격이 표시 되 고 가격이 노랑 배경색으로 $10.00 미만인 제품이 강조 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-244">To illustrate this, let's add a GridView to the `CustomColors.aspx` page that lists the name, category, and price for each product, highlighting those products whose price is less than $10.00 with a yellow background color.</span></span>

## <a name="step-7-displaying-product-information-in-a-gridview"></a><span data-ttu-id="98d18-245">7 단계: GridView에 제품 정보 표시</span><span class="sxs-lookup"><span data-stu-id="98d18-245">Step 7: Displaying Product Information in a GridView</span></span>

<span data-ttu-id="98d18-246">이전 예제에서 FormView 아래의 GridView를 추가 하 고 해당 `ID` 속성을 `HighlightCheapProducts`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-246">Add a GridView beneath the FormView from the previous example and set its `ID` property to `HighlightCheapProducts`.</span></span> <span data-ttu-id="98d18-247">페이지의 모든 제품을 반환 하는 ObjectDataSource가 이미 있으므로 GridView를 해당에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-247">Since we already have an ObjectDataSource that returns all products on the page, bind the GridView to that.</span></span> <span data-ttu-id="98d18-248">마지막으로, 제품의 이름, 범주 및 가격만 포함 하도록 GridView의 BoundFields를 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-248">Finally, edit the GridView's BoundFields to include just the products' names, categories, and prices.</span></span> <span data-ttu-id="98d18-249">이러한 편집 후 GridView의 태그는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-249">After these edits the GridView's markup should look like:</span></span>

[!code-aspx[Main](custom-formatting-based-upon-data-cs/samples/sample13.aspx)]

<span data-ttu-id="98d18-250">그림 9에서는 브라우저를 통해 볼 때이 시점에 대 한 진행률을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-250">Figure 9 shows our progress to this point when viewed through a browser.</span></span>

<span data-ttu-id="98d18-251">[GridView ![각 제품의 이름, 범주 및 가격이 나열 됩니다.](custom-formatting-based-upon-data-cs/_static/image22.png)](custom-formatting-based-upon-data-cs/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-251">[![The GridView Lists the Name, Category, and Price For Each Product](custom-formatting-based-upon-data-cs/_static/image22.png)](custom-formatting-based-upon-data-cs/_static/image21.png)</span></span>

<span data-ttu-id="98d18-252">**그림 9**: GridView에 각 제품의 이름, 범주 및 가격이 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image23.png)).</span><span class="sxs-lookup"><span data-stu-id="98d18-252">**Figure 9**: The GridView Lists the Name, Category, and Price For Each Product ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image23.png))</span></span>

## <a name="step-8-programmatically-determining-the-value-of-the-data-in-the-rowdatabound-event-handler"></a><span data-ttu-id="98d18-253">8 단계: RowDataBound 바인딩 이벤트 처리기에서 프로그래밍 방식으로 데이터 값 결정</span><span class="sxs-lookup"><span data-stu-id="98d18-253">Step 8: Programmatically Determining the Value of the Data in the RowDataBound Event Handler</span></span>

<span data-ttu-id="98d18-254">`ProductsDataTable` GridView에 바인딩되면 `ProductsRow` 인스턴스가 열거 되 고 각 `ProductsRow`에 대해 `GridViewRow` 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-254">When the `ProductsDataTable` is bound to the GridView its `ProductsRow` instances are enumerated and for each `ProductsRow` a `GridViewRow` is created.</span></span> <span data-ttu-id="98d18-255">`GridViewRow`의 `DataItem` 속성은 특정 `ProductRow`에 할당 된 후 GridView의 `RowDataBound` 이벤트 처리기가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-255">The `GridViewRow`'s `DataItem` property is assigned to the particular `ProductRow`, after which the GridView's `RowDataBound` event handler is raised.</span></span> <span data-ttu-id="98d18-256">GridView에 바인딩된 각 제품의 `UnitPrice` 값을 확인 하려면 GridView의 `RowDataBound` 이벤트에 대 한 이벤트 처리기를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-256">To determine the `UnitPrice` value for each product bound to the GridView, then, we need to create an event handler for the GridView's `RowDataBound` event.</span></span> <span data-ttu-id="98d18-257">이 이벤트 처리기에서는 현재 `GridViewRow`에 대 한 `UnitPrice` 값을 검사 하 고 해당 행에 대 한 서식 지정을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-257">In this event handler we can inspect the `UnitPrice` value for the current `GridViewRow` and make a formatting decision for that row.</span></span>

<span data-ttu-id="98d18-258">이 이벤트 처리기는 FormView 및 DetailsView와 동일한 일련의 단계를 사용 하 여 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-258">This event handler can be created using the same series of steps as with the FormView and DetailsView.</span></span>

![GridView의 RowDataBound 바인딩된 이벤트에 대 한 이벤트 처리기 만들기](custom-formatting-based-upon-data-cs/_static/image24.png)

<span data-ttu-id="98d18-260">**그림 10**: GridView의 `RowDataBound` 이벤트에 대 한 이벤트 처리기 만들기</span><span class="sxs-lookup"><span data-stu-id="98d18-260">**Figure 10**: Create an Event Handler for the GridView's `RowDataBound` Event</span></span>

<span data-ttu-id="98d18-261">이러한 방식으로 이벤트 처리기를 만들면 다음 코드가 ASP.NET 페이지의 코드 부분에 자동으로 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-261">Creating the event handler in this manner will cause the following code to be automatically added to the ASP.NET page's code portion:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample14.cs)]

<span data-ttu-id="98d18-262">`RowDataBound` 이벤트가 발생 하는 경우 이벤트 처리기는 이름이 `Row`인 속성이 있는 `GridViewRowEventArgs`형식의 개체를 두 번째 매개 변수로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-262">When the `RowDataBound` event fires, the event handler is passed as its second parameter an object of type `GridViewRowEventArgs`, which has a property named `Row`.</span></span> <span data-ttu-id="98d18-263">이 속성은 단순히 데이터 바인딩된 `GridViewRow`에 대 한 참조를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-263">This property returns a reference to the `GridViewRow` that was just data bound.</span></span> <span data-ttu-id="98d18-264">`GridViewRow`에 바인딩된 `ProductsRow` 인스턴스에 액세스 하려면 다음과 같이 `DataItem` 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-264">To access the `ProductsRow` instance bound to the `GridViewRow` we use the `DataItem` property like so:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample15.cs)]

<span data-ttu-id="98d18-265">`RowDataBound` 이벤트 처리기를 사용 하는 경우 GridView는 여러 행 형식으로 구성 되 고 *모든* 행 형식에 대해이 이벤트가 발생 한다는 점에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-265">When working with the `RowDataBound` event handler it is important to keep in mind that the GridView is composed of different types of rows and that this event is fired for *all* row types.</span></span> <span data-ttu-id="98d18-266">`GridViewRow`형식은 `RowType` 속성에 의해 결정 될 수 있으며 가능한 값 중 하나를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-266">A `GridViewRow`'s type can be determined by its `RowType` property, and can have one of the possible values:</span></span>

- <span data-ttu-id="98d18-267">GridView의 `DataSource` 레코드에 바인딩된 행을 `DataRow`</span><span class="sxs-lookup"><span data-stu-id="98d18-267">`DataRow` a row that is bound to a record from the GridView's `DataSource`</span></span>
- <span data-ttu-id="98d18-268">GridView의 `DataSource` 비어 있는 경우 표시 되는 행 `EmptyDataRow`</span><span class="sxs-lookup"><span data-stu-id="98d18-268">`EmptyDataRow` the row displayed if the GridView's `DataSource` is empty</span></span>
- <span data-ttu-id="98d18-269">바닥글 행을 `Footer` 합니다. GridView의 `ShowFooter` 속성이로 설정 된 경우 표시 됩니다 `true`</span><span class="sxs-lookup"><span data-stu-id="98d18-269">`Footer` the footer row; shown if the GridView's `ShowFooter` property is set to `true`</span></span>
- <span data-ttu-id="98d18-270">머리글 행을 `Header` 합니다. GridView의 ShowHeader 속성이 `true` (기본값)로 설정 된 경우 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-270">`Header` the header row; shown if the GridView's ShowHeader property is set to `true` (the default)</span></span>
- <span data-ttu-id="98d18-271">페이징을 구현 하는 GridView의 `Pager` 페이징 인터페이스를 표시 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-271">`Pager` for GridView's that implement paging, the row that displays the paging interface</span></span>
- <span data-ttu-id="98d18-272">GridView에는 사용 되지 않지만 DataList 및 Repeater 컨트롤의 `RowType` 속성에서 사용 되는 `Separator` 다음 자습서에서 설명 하는 두 가지 데이터 웹 컨트롤</span><span class="sxs-lookup"><span data-stu-id="98d18-272">`Separator` not used for the GridView, but used by the `RowType` properties for the DataList and Repeater controls, two data Web controls we'll discuss in future tutorials</span></span>

<span data-ttu-id="98d18-273">`EmptyDataRow`, `Header`, `Footer`및 `Pager` 행은 `DataSource` 레코드와 연결 되지 않으므로 항상 `null` 속성의 `DataItem` 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-273">Since the `EmptyDataRow`, `Header`, `Footer`, and `Pager` rows aren't associated with a `DataSource` record, they will always have a `null` value for their `DataItem` property.</span></span> <span data-ttu-id="98d18-274">이러한 이유로 현재 `GridViewRow`의 `DataItem` 속성을 사용 하기 전에 먼저 `DataRow`를 처리 하 고 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-274">For this reason, before attempting to work with the current `GridViewRow`'s `DataItem` property, we first must make sure that we're dealing with a `DataRow`.</span></span> <span data-ttu-id="98d18-275">다음과 같이 `GridViewRow`의 `RowType` 속성을 확인 하 여이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-275">This can be accomplished by checking the `GridViewRow`'s `RowType` property like so:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample16.cs)]

## <a name="step-9-highlighting-the-row-yellow-when-the-unitprice-value-is-less-than-1000"></a><span data-ttu-id="98d18-276">9 단계: UnitPrice 값이 $10.00 보다 작은 경우 노란색 행 강조 표시</span><span class="sxs-lookup"><span data-stu-id="98d18-276">Step 9: Highlighting the Row Yellow When the UnitPrice Value is Less than $10.00</span></span>

<span data-ttu-id="98d18-277">마지막 단계는 해당 행의 `UnitPrice` 값이 $10.00 보다 작은 경우 전체 `GridViewRow`를 프로그래밍 방식으로 강조 표시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-277">The last step is to programmatically highlight the entire `GridViewRow` if the `UnitPrice` value for that row is less than $10.00.</span></span> <span data-ttu-id="98d18-278">GridView의 행 이나 셀에 액세스 하기 위한 구문은 전체 행에 액세스 하기 위해 DetailsView `GridViewID.Rows[index]`와 동일 하며, `GridViewID.Rows[index].Cells[index]` 특정 셀에 액세스 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-278">The syntax for accessing a GridView's rows or cells is the same as with the DetailsView `GridViewID.Rows[index]` to access the entire row, `GridViewID.Rows[index].Cells[index]` to access a particular cell.</span></span> <span data-ttu-id="98d18-279">그러나 `RowDataBound` 이벤트 처리기가 데이터 바인딩된 `GridViewRow`를 발생 시키면 GridView의 `Rows` 컬렉션에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-279">However, when the `RowDataBound` event handler fires the data bound `GridViewRow` has yet to be added to the GridView's `Rows` collection.</span></span> <span data-ttu-id="98d18-280">따라서 Rows 컬렉션을 사용 하 여 `RowDataBound` 이벤트 처리기에서 현재 `GridViewRow` 인스턴스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-280">Therefore you cannot access the current `GridViewRow` instance from the `RowDataBound` event handler using the Rows collection.</span></span>

<span data-ttu-id="98d18-281">`GridViewID.Rows[index]`대신 `e.Row`를 사용 하 여 `RowDataBound` 이벤트 처리기에서 현재 `GridViewRow` 인스턴스를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-281">Instead of `GridViewID.Rows[index]`, we can reference the current `GridViewRow` instance in the `RowDataBound` event handler using `e.Row`.</span></span> <span data-ttu-id="98d18-282">즉, 사용 하는 `RowDataBound` 이벤트 처리기에서 현재 `GridViewRow` 인스턴스를 강조 표시 하기 위해 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-282">That is, in order to highlight the current `GridViewRow` instance from the `RowDataBound` event handler we would use:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample17.cs)]

<span data-ttu-id="98d18-283">`GridViewRow`의 `BackColor` 속성을 직접 설정 하는 대신 CSS 클래스를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-283">Rather than set the `GridViewRow`'s `BackColor` property directly, let's stick with using CSS classes.</span></span> <span data-ttu-id="98d18-284">배경색을 노란색으로 설정 하는 `AffordablePriceEmphasis` 라는 CSS 클래스를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-284">I've created a CSS class named `AffordablePriceEmphasis` that sets the background color to yellow.</span></span> <span data-ttu-id="98d18-285">완료 된 `RowDataBound` 이벤트 처리기는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-285">The completed `RowDataBound` event handler follows:</span></span>

[!code-csharp[Main](custom-formatting-based-upon-data-cs/samples/sample18.cs)]

<span data-ttu-id="98d18-286">[![가장 저렴 한 제품을 노란색으로 강조 표시 합니다.](custom-formatting-based-upon-data-cs/_static/image26.png)](custom-formatting-based-upon-data-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="98d18-286">[![The Most Affordable Products are Highlighted Yellow](custom-formatting-based-upon-data-cs/_static/image26.png)](custom-formatting-based-upon-data-cs/_static/image25.png)</span></span>

<span data-ttu-id="98d18-287">**그림 11**: 가장 저렴 한 제품을 노란색으로 강조 표시 ([전체 크기 이미지를 보려면 클릭](custom-formatting-based-upon-data-cs/_static/image27.png))</span><span class="sxs-lookup"><span data-stu-id="98d18-287">**Figure 11**: The Most Affordable Products are Highlighted Yellow ([Click to view full-size image](custom-formatting-based-upon-data-cs/_static/image27.png))</span></span>

## <a name="summary"></a><span data-ttu-id="98d18-288">요약</span><span class="sxs-lookup"><span data-stu-id="98d18-288">Summary</span></span>

<span data-ttu-id="98d18-289">이 자습서에서는 컨트롤에 바인딩된 데이터를 기반으로 GridView, DetailsView 및 FormView의 형식을 지정 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-289">In this tutorial we saw how to format the GridView, DetailsView, and FormView based on the data bound to the control.</span></span> <span data-ttu-id="98d18-290">이를 위해 필요에 따라 기본 데이터가 형식 변경과 함께 검사 된 `DataBound` 또는 `RowDataBound` 이벤트에 대 한 이벤트 처리기를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-290">To accomplish this we created an event handler for the `DataBound` or `RowDataBound` events, where the underlying data was examined along with a formatting change, if needed.</span></span> <span data-ttu-id="98d18-291">DetailsView 또는 FormView에 바인딩된 데이터에 액세스 하려면 `DataBound` 이벤트 처리기에서 `DataItem` 속성을 사용 합니다. GridView의 경우 각 `GridViewRow` 인스턴스의 `DataItem` 속성은 `RowDataBound` 이벤트 처리기에서 사용할 수 있는 해당 행에 바인딩된 데이터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-291">To access the data bound to a DetailsView or FormView, we use the `DataItem` property in the `DataBound` event handler; for a GridView, each `GridViewRow` instance's `DataItem` property contains the data bound to that row, which is available in the `RowDataBound` event handler.</span></span>

<span data-ttu-id="98d18-292">데이터 웹 컨트롤의 서식 지정을 프로그래밍 방식으로 조정 하는 구문은 웹 컨트롤과 서식 지정 되는 데이터의 표시 방법에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-292">The syntax for programmatically adjusting the data Web control's formatting depends upon the Web control and how the data to be formatted is displayed.</span></span> <span data-ttu-id="98d18-293">DetailsView 및 GridView 컨트롤의 경우 행과 셀은 서 수 인덱스로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-293">For DetailsView and GridView controls, the rows and cells can be accessed by an ordinal index.</span></span> <span data-ttu-id="98d18-294">템플릿을 사용 하는 FormView의 경우 `FindControl("controlID")` 메서드는 일반적으로 템플릿 내에서 웹 컨트롤을 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-294">For the FormView, which uses templates, the `FindControl("controlID")` method is commonly used to locate a Web control from within the template.</span></span>

<span data-ttu-id="98d18-295">다음 자습서에서는 GridView 및 DetailsView에서 템플릿을 사용 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-295">In the next tutorial we'll look at how to use templates with the GridView and DetailsView.</span></span> <span data-ttu-id="98d18-296">또한 기본 데이터를 기반으로 서식을 지정 하는 다른 기술을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-296">Additionally, we'll see another technique for customizing the formatting based on the underlying data.</span></span>

<span data-ttu-id="98d18-297">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="98d18-297">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="98d18-298">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="98d18-298">About the Author</span></span>

<span data-ttu-id="98d18-299">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(7 개의 ASP/ASP. NET books 및 [4GuysFromRolla.com](http://www.4guysfromrolla.com)창립자)은 1998부터 Microsoft 웹 기술을 사용 하 여 작업 했습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-299">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="98d18-300">Scott은 독립 컨설턴트, 강사 및 기록기로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-300">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="98d18-301">최신 책은 [*24 시간 이내에 ASP.NET 2.0을 sams teach yourself*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)것입니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-301">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="98d18-302">mitchell@4GuysFromRolla.com에 도달할 수 있습니다 [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="98d18-302">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="98d18-303">또는 블로그를 통해 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-303">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="98d18-304">특별히 감사 합니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-304">Special Thanks To</span></span>

<span data-ttu-id="98d18-305">이 자습서 시리즈는 많은 유용한 검토자가 검토 했습니다.</span><span class="sxs-lookup"><span data-stu-id="98d18-305">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="98d18-306">이 자습서에 대 한 잠재 고객 검토자가 E.R.</span><span class="sxs-lookup"><span data-stu-id="98d18-306">Lead reviewers for this tutorial were E.R.</span></span> <span data-ttu-id="98d18-307">Gilmore, Dennis Patterson이 및 Dan Jagers.</span><span class="sxs-lookup"><span data-stu-id="98d18-307">Gilmore, Dennis Patterson, and Dan Jagers.</span></span> <span data-ttu-id="98d18-308">예정 된 MSDN 문서를 검토 하는 데 관심이 있나요?</span><span class="sxs-lookup"><span data-stu-id="98d18-308">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="98d18-309">그렇다면mitchell@4GuysFromRolla.com에서 줄을 삭제 [합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="98d18-309">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="98d18-310">다음</span><span class="sxs-lookup"><span data-stu-id="98d18-310">Next</span></span>](using-templatefields-in-the-gridview-control-cs.md)
