---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application
title: ASP.NET 4 웹 응용 프로그램에서 Entity Framework 4.0를 사용 하 여 동시성 처리 | Microsoft Docs
author: tdykstra
description: 이 자습서 시리즈는 Entity Framework 4.0 자습서 시리즈 시작에서 만든 Contoso 대학 웹 응용 프로그램을 기반으로 합니다. I...
ms.author: riande
ms.date: 01/26/2011
ms.assetid: a5aa22a6-fb7f-4f41-9c7f-addda151940b
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: 3df5f7d9c8fb22e1ea34fe16560bdb9a1309bb56
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78513503"
---
# <a name="handling-concurrency-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a><span data-ttu-id="fb18f-104">ASP.NET 4 웹 응용 프로그램에서 Entity Framework 4.0를 사용 하 여 동시성 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-104">Handling Concurrency with the Entity Framework 4.0 in an ASP.NET 4 Web Application</span></span>

<span data-ttu-id="fb18f-105">만든 사람 [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="fb18f-105">by [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="fb18f-106">이 자습서 시리즈는 [Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) 자습서 시리즈 시작에서 만든 Contoso 대학 웹 응용 프로그램을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-106">This tutorial series builds on the Contoso University web application that is created by the [Getting Started with the Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) tutorial series.</span></span> <span data-ttu-id="fb18f-107">이전 자습서를 완료 하지 않은 경우이 자습서의 시작 점으로, 만든 [응용 프로그램을 다운로드할](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-107">If you didn't complete the earlier tutorials, as a starting point for this tutorial you can [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) that you would have created.</span></span> <span data-ttu-id="fb18f-108">전체 자습서 시리즈에서 만든 [응용 프로그램을 다운로드할](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-108">You can also [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) that is created by the complete tutorial series.</span></span> <span data-ttu-id="fb18f-109">자습서에 대 한 질문이 있는 경우 [ASP.NET Entity Framework 포럼](https://forums.asp.net/1227.aspx)에 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-109">If you have questions about the tutorials, you can post them to the [ASP.NET Entity Framework forum](https://forums.asp.net/1227.aspx).</span></span>

<span data-ttu-id="fb18f-110">이전 자습서에서는 `ObjectDataSource` 컨트롤과 Entity Framework를 사용 하 여 데이터를 정렬 하 고 필터링 하는 방법을 배웠습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-110">In the previous tutorial you learned how to sort and filter data using the `ObjectDataSource` control and the Entity Framework.</span></span> <span data-ttu-id="fb18f-111">이 자습서에서는 Entity Framework를 사용 하는 ASP.NET 웹 응용 프로그램에서 동시성을 처리 하는 옵션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-111">This tutorial shows options for handling concurrency in an ASP.NET web application that uses the Entity Framework.</span></span> <span data-ttu-id="fb18f-112">강사 office 할당을 업데이트 하는 전용 웹 페이지를 새로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-112">You will create a new web page that's dedicated to updating instructor office assignments.</span></span> <span data-ttu-id="fb18f-113">해당 페이지와 앞에서 만든 부서 페이지에서 동시성 문제를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-113">You'll handle concurrency issues in that page and in the Departments page that you created earlier.</span></span>

<span data-ttu-id="fb18f-114">[![Image06](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-114">[![Image06](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span></span>

<span data-ttu-id="fb18f-115">[![Image01](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-115">[![Image01](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span></span>

## <a name="concurrency-conflicts"></a><span data-ttu-id="fb18f-116">동시성 충돌</span><span class="sxs-lookup"><span data-stu-id="fb18f-116">Concurrency Conflicts</span></span>

<span data-ttu-id="fb18f-117">동시성 충돌은 한 사용자가 레코드를 편집 하 고 첫 번째 사용자의 변경 내용이 데이터베이스에 기록 되기 전에 다른 사용자가 동일한 레코드를 편집할 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-117">A concurrency conflict occurs when one user edits a record and another user edits the same record before the first user's change is written to the database.</span></span> <span data-ttu-id="fb18f-118">이러한 충돌을 검색 하도록 Entity Framework를 설정 하지 않으면 데이터베이스를 마지막으로 업데이트 하 여 다른 사용자의 변경 내용을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-118">If you don't set up the Entity Framework to detect such conflicts, whoever updates the database last overwrites the other user's changes.</span></span> <span data-ttu-id="fb18f-119">많은 응용 프로그램에서이 위험이 허용 되며, 가능한 동시성 충돌을 처리 하도록 응용 프로그램을 구성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-119">In many applications, this risk is acceptable, and you don't have to configure the application to handle possible concurrency conflicts.</span></span> <span data-ttu-id="fb18f-120">(사용자가 거의 없거나 업데이트가 많지 않은 경우 또는 일부 변경 내용을 덮어쓰는 경우에는 중요 하지 않은 경우에는 동시성 프로그래밍의 비용이 이점 보다 클 수 있습니다.) 동시성 충돌에 대해 걱정 하지 않아도 되는 경우이 자습서를 건너뛸 수 있습니다. 시리즈의 나머지 두 자습서는이 자습서에서 작성 한 항목에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-120">(If there are few users, or few updates, or if isn't really critical if some changes are overwritten, the cost of programming for concurrency might outweigh the benefit.) If you don't need to worry about concurrency conflicts, you can skip this tutorial; the remaining two tutorials in the series don't depend on anything you build in this one.</span></span>

### <a name="pessimistic-concurrency-locking"></a><span data-ttu-id="fb18f-121">비관적 동시성 (잠금)</span><span class="sxs-lookup"><span data-stu-id="fb18f-121">Pessimistic Concurrency (Locking)</span></span>

<span data-ttu-id="fb18f-122">애플리케이션에서 동시성 시나리오에서 실수로 인한 데이터 손실을 방지할 필요가 있는 경우 해당 작업을 수행하는 한 가지 방법은 데이터베이스 잠금을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-122">If your application does need to prevent accidental data loss in concurrency scenarios, one way to do that is to use database locks.</span></span> <span data-ttu-id="fb18f-123">이를 *비관적 동시성*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-123">This is called *pessimistic concurrency*.</span></span> <span data-ttu-id="fb18f-124">예를 들어 데이터베이스에서 행을 읽기 전에 읽기 전용 또는 업데이트 액세스에 대한 잠금을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-124">For example, before you read a row from a database, you request a lock for read-only or for update access.</span></span> <span data-ttu-id="fb18f-125">업데이트 액세스에 대한 행을 잠그는 경우 변경 중인 데이터의 복사본을 가져오기 때문에 다른 사용자는 읽기 전용 또는 업데이트 액세스에 대한 행을 잠그도록 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-125">If you lock a row for update access, no other users are allowed to lock the row either for read-only or update access, because they would get a copy of data that's in the process of being changed.</span></span> <span data-ttu-id="fb18f-126">읽기 전용 액세스에 대한 행을 잠그는 경우 다른 사용자도 읽기 전용에 대해 잠글 수 있지만 업데이트에 대해서는 잠글 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-126">If you lock a row for read-only access, others can also lock it for read-only access but not for update.</span></span>

<span data-ttu-id="fb18f-127">잠금 관리에는 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-127">Managing locks has some disadvantages.</span></span> <span data-ttu-id="fb18f-128">프로그램을 설정하는 데 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-128">It can be complex to program.</span></span> <span data-ttu-id="fb18f-129">중요 한 데이터베이스 관리 리소스가 필요 하며, 응용 프로그램의 사용자 수가 증가 함에 따라 성능 문제가 발생할 수 있습니다 (즉, 크기를 조정 하지 않음).</span><span class="sxs-lookup"><span data-stu-id="fb18f-129">It requires significant database management resources, and it can cause performance problems as the number of users of an application increases (that is, it doesn't scale well).</span></span> <span data-ttu-id="fb18f-130">이러한 이유로 모든 데이터베이스 관리 시스템은 비관적 동시성을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-130">For these reasons, not all database management systems support pessimistic concurrency.</span></span> <span data-ttu-id="fb18f-131">Entity Framework는이에 대 한 기본 제공 지원을 제공 하지 않으며이 자습서에서 구현 방법을 보여 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-131">The Entity Framework provides no built-in support for it, and this tutorial doesn't show you how to implement it.</span></span>

### <a name="optimistic-concurrency"></a><span data-ttu-id="fb18f-132">낙관적 동시성</span><span class="sxs-lookup"><span data-stu-id="fb18f-132">Optimistic Concurrency</span></span>

<span data-ttu-id="fb18f-133">비관적 동시성 대신 *낙관적 동시성*을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-133">The alternative to pessimistic concurrency is *optimistic concurrency*.</span></span> <span data-ttu-id="fb18f-134">낙관적 동시성은 동시성 충돌 발생을 허용한 다음, 그럴 경우 적절하게 반응하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-134">Optimistic concurrency means allowing concurrency conflicts to happen, and then reacting appropriately if they do.</span></span> <span data-ttu-id="fb18f-135">예를 들어, John은 *학과* 페이지를 실행 하 고, History 부서에 대 한 **편집** 링크를 클릭 하 고, **예산** 크기를 $1000000.00에서 $125000.00으로 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-135">For example, John runs the *Department.aspx* page, clicks the **Edit** link for the History department, and reduces the **Budget** amount from $1,000,000.00 to $125,000.00.</span></span> <span data-ttu-id="fb18f-136">(John은 경쟁 부서를 관리 하 고 자신의 부서에 대 한 비용을 확보 하려고 합니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-136">(John administers a competing department and wants to free up money for his own department.)</span></span>

<span data-ttu-id="fb18f-137">[![Image07](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-137">[![Image07](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span></span>

<span data-ttu-id="fb18f-138">John이 **업데이트**를 클릭 하기 전에 Jane은 같은 페이지를 실행 하 고, History 부서에 대 한 **편집** 링크를 클릭 한 다음 **시작 날짜** 필드를 1/10/2011에서 1/1/1999로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-138">Before John clicks **Update**, Jane runs the same page, clicks the **Edit** link for the History department, and then changes the **Start Date** field from 1/10/2011 to 1/1/1999.</span></span> <span data-ttu-id="fb18f-139">Jane은 기록 부서를 관리 하 고 더 seniority를 제공 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-139">(Jane administers the History department and wants to give it more seniority.)</span></span>

<span data-ttu-id="fb18f-140">[![Image08](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-140">[![Image08](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span></span>

<span data-ttu-id="fb18f-141">먼저 **업데이트** 를 클릭 한 다음 Jane은 **업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-141">John clicks **Update** first, then Jane clicks **Update**.</span></span> <span data-ttu-id="fb18f-142">Jane의 브라우저는 이제 $1000000.00으로 **예산** 금액을 나열 하지만, 크기가 John에서 $125000.00로 변경 되었기 때문에 잘못 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-142">Jane's browser now lists the **Budget** amount as $1,000,000.00, but this is incorrect because the amount has been changed by John to $125,000.00.</span></span>

<span data-ttu-id="fb18f-143">이 시나리오에서 수행할 수 있는 작업에는 다음이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-143">Some of the actions you can take in this scenario include the following:</span></span>

- <span data-ttu-id="fb18f-144">사용자가 수정한 속성의 추적을 유지하고 데이터베이스에서 해당하는 열만 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-144">You can keep track of which property a user has modified and update only the corresponding columns in the database.</span></span> <span data-ttu-id="fb18f-145">예제 시나리오에서 서로 다른 속성이 두 사용자에 의해 업데이트되었기 때문에 데이터가 손실되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-145">In the example scenario, no data would be lost, because different properties were updated by the two users.</span></span> <span data-ttu-id="fb18f-146">다음에 누군가가 기록 부서를 탐색할 때 1/1/1999 및 $125000.00이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-146">The next time someone browses the History department, they will see 1/1/1999 and $125,000.00.</span></span> 

    <span data-ttu-id="fb18f-147">이는 Entity Framework의 기본 동작으로, 데이터 손실이 발생할 수 있는 충돌 수를 크게 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-147">This is the default behavior in the Entity Framework, and it can substantially reduce the number of conflicts that could result in data loss.</span></span> <span data-ttu-id="fb18f-148">그러나 엔터티의 같은 속성을 변경 하는 경우에는 이러한 동작으로 인해 데이터 손실이 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-148">However, this behavior doesn't avoid data loss if competing changes are made to the same property of an entity.</span></span> <span data-ttu-id="fb18f-149">또한이 동작은 항상 가능 하지는 않습니다. 저장 프로시저를 엔터티 형식에 매핑하면 엔터티에 대 한 변경 내용이 데이터베이스에 적용 될 때 엔터티의 속성이 모두 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-149">In addition, this behavior isn't always possible; when you map stored procedures to an entity type, all of an entity's properties are updated when any changes to the entity are made in the database.</span></span>
- <span data-ttu-id="fb18f-150">Jane의 변경 내용이 John의 변경 내용을 덮어쓰는 것을 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-150">You can let Jane's change overwrite John's change.</span></span> <span data-ttu-id="fb18f-151">Jane이 **업데이트**를 클릭 하면 **예산** 금액이 $1000000.00로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-151">After Jane clicks **Update**, the **Budget** amount goes back to $1,000,000.00.</span></span> <span data-ttu-id="fb18f-152">이를 *클라이언트 우선* 또는 *최종 우선* 시나리오라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-152">This is called a *Client Wins* or *Last in Wins* scenario.</span></span> <span data-ttu-id="fb18f-153">(클라이언트의 값은 데이터 저장소에 있는 것 보다 우선 적용 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-153">(The client's values take precedence over what's in the data store.)</span></span>
- <span data-ttu-id="fb18f-154">Jane의 변경 내용이 데이터베이스에서 업데이트 되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-154">You can prevent Jane's change from being updated in the database.</span></span> <span data-ttu-id="fb18f-155">일반적으로 오류 메시지를 표시 하 고, 데이터의 현재 상태를 표시 하 고, 변경 하려는 경우 변경 내용을 다시 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-155">Typically, you would display an error message, show her the current state of the data, and allow her to reenter her changes if she still wants to make them.</span></span> <span data-ttu-id="fb18f-156">사용자의 입력을 저장 하 고 다시 입력 하지 않고 다시 적용할 수 있는 기회를 제공 하 여 프로세스를 추가로 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-156">You could further automate the process by saving her input and giving her an opportunity to reapply it without having to reenter it.</span></span> <span data-ttu-id="fb18f-157">이를 *저장소 우선* 시나리오라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-157">This is called a *Store Wins* scenario.</span></span> <span data-ttu-id="fb18f-158">(데이터 저장소 값은 클라이언트에서 전송한 값에 우선합니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-158">(The data-store values take precedence over the values submitted by the client.)</span></span>

### <a name="detecting-concurrency-conflicts"></a><span data-ttu-id="fb18f-159">동시성 충돌 감지</span><span class="sxs-lookup"><span data-stu-id="fb18f-159">Detecting Concurrency Conflicts</span></span>

<span data-ttu-id="fb18f-160">Entity Framework에서 Entity Framework throw 하는 `OptimisticConcurrencyException` 예외를 처리 하 여 충돌을 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-160">In the Entity Framework, you can resolve conflicts by handling `OptimisticConcurrencyException` exceptions that the Entity Framework throws.</span></span> <span data-ttu-id="fb18f-161">이러한 예외를 throw하는 시기를 확인하기 위해 Entity Framework에서 충돌을 검색할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-161">In order to know when to throw these exceptions, the Entity Framework must be able to detect conflicts.</span></span> <span data-ttu-id="fb18f-162">따라서 데이터베이스와 데이터 모델을 적절하게 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-162">Therefore, you must configure the database and the data model appropriately.</span></span> <span data-ttu-id="fb18f-163">충돌 검색을 활성화하기 위한 몇 가지 옵션은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-163">Some options for enabling conflict detection include the following:</span></span>

- <span data-ttu-id="fb18f-164">데이터베이스에 행이 변경 된 시기를 결정 하는 데 사용할 수 있는 테이블 열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-164">In the database, include a table column that can be used to determine when a row has been changed.</span></span> <span data-ttu-id="fb18f-165">그런 다음 SQL `Update` 또는 `Delete` 명령의 `Where` 절에 해당 열을 포함 하도록 Entity Framework를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-165">You can then configure the Entity Framework to include that column in the `Where` clause of SQL `Update` or `Delete` commands.</span></span>

    <span data-ttu-id="fb18f-166">이는 `OfficeAssignment` 테이블의 `Timestamp` 열 용도입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-166">That's the purpose of the `Timestamp` column in the `OfficeAssignment` table.</span></span>

    <span data-ttu-id="fb18f-167">[![Image09](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-167">[![Image09](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span></span>

    <span data-ttu-id="fb18f-168">`Timestamp` 열의 데이터 형식을 `Timestamp`라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-168">The data type of the `Timestamp` column is also called `Timestamp`.</span></span> <span data-ttu-id="fb18f-169">그러나 열에는 실제로 날짜 또는 시간 값이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-169">However, the column doesn't actually contain a date or time value.</span></span> <span data-ttu-id="fb18f-170">대신이 값은 행이 업데이트 될 때마다 증가 하는 일련 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-170">Instead, the value is a sequential number that's incremented each time the row is updated.</span></span> <span data-ttu-id="fb18f-171">`Update` 또는 `Delete` 명령에서 `Where` 절은 원래 `Timestamp` 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-171">In an `Update` or `Delete` command, the `Where` clause includes the original `Timestamp` value.</span></span> <span data-ttu-id="fb18f-172">업데이트 되는 행이 다른 사용자에 의해 변경 된 경우 `Timestamp`의 값은 원래 값과 다르므로 `Where` 절은 업데이트할 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-172">If the row being updated has been changed by another user, the value in `Timestamp` is different than the original value, so the `Where` clause returns no row to update.</span></span> <span data-ttu-id="fb18f-173">Entity Framework 현재 `Update` 또는 `Delete` 명령에 의해 업데이트 된 행이 없는 것을 발견 하는 경우 (즉, 영향을 받는 행의 수가 0 인 경우)이는 동시성 충돌로 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-173">When the Entity Framework finds that no rows have been updated by the current `Update` or `Delete` command (that is, when the number of affected rows is zero), it interprets that as a concurrency conflict.</span></span>
- <span data-ttu-id="fb18f-174">`Update` 및 `Delete` 명령의 `Where` 절에서 테이블에 있는 모든 열의 원래 값을 포함 하도록 Entity Framework를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-174">Configure the Entity Framework to include the original values of every column in the table in the `Where` clause of `Update` and `Delete` commands.</span></span>

    <span data-ttu-id="fb18f-175">첫 번째 옵션에서와 같이 행을 처음 읽은 후 행의 내용이 변경 된 경우에는 `Where` 절이 업데이트할 행을 반환 하지 않습니다 .이는 Entity Framework에서 동시성 충돌로 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-175">As in the first option, if anything in the row has changed since the row was first read, the `Where` clause won't return a row to update, which the Entity Framework interprets as a concurrency conflict.</span></span> <span data-ttu-id="fb18f-176">이 메서드는 `Timestamp` 필드를 사용 하는 것과 효과적 이지만 비효율적 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-176">This method is as effective as using a `Timestamp` field, but can be inefficient.</span></span> <span data-ttu-id="fb18f-177">많은 열이 있는 데이터베이스 테이블의 경우 `Where` 절이 매우 클 수 있으며, 웹 응용 프로그램에서는 많은 양의 상태를 유지 관리 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-177">For database tables that have many columns, it can result in very large `Where` clauses, and in a web application it can require that you maintain large amounts of state.</span></span> <span data-ttu-id="fb18f-178">많은 양의 상태를 유지 관리 하는 것은 서버 리소스 (예: 세션 상태)가 필요 하거나 웹 페이지 자체 (예: 보기 상태)에 포함 되어야 하므로 응용 프로그램 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-178">Maintaining large amounts of state can affect application performance because it either requires server resources (for example, session state) or must be included in the web page itself (for example, view state).</span></span>

<span data-ttu-id="fb18f-179">이 자습서에서는 추적 속성이 없는 엔터티 (`Department` 엔터티)와 추적 속성 (`OfficeAssignment` 엔터티)이 있는 엔터티에 대 한 낙관적 동시성 충돌에 대 한 오류 처리를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-179">In this tutorial you will add error handling for optimistic concurrency conflicts for an entity that doesn't have a tracking property (the `Department` entity) and for an entity that does have a tracking property (the `OfficeAssignment` entity).</span></span>

## <a name="handling-optimistic-concurrency-without-a-tracking-property"></a><span data-ttu-id="fb18f-180">추적 속성 없이 낙관적 동시성 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-180">Handling Optimistic Concurrency Without a Tracking Property</span></span>

<span data-ttu-id="fb18f-181">추적 (`Timestamp`) 속성이 없는 `Department` 엔터티에 대해 낙관적 동시성을 구현 하려면 다음 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-181">To implement optimistic concurrency for the `Department` entity, which doesn't have a tracking (`Timestamp`) property, you will complete the following tasks:</span></span>

- <span data-ttu-id="fb18f-182">`Department` 엔터티에 대해 동시성 추적을 사용 하도록 데이터 모델을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-182">Change the data model to enable concurrency tracking for `Department` entities.</span></span>
- <span data-ttu-id="fb18f-183">`SchoolRepository` 클래스에서 `SaveChanges` 메서드의 동시성 예외를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-183">In the `SchoolRepository` class, handle concurrency exceptions in the `SaveChanges` method.</span></span>
- <span data-ttu-id="fb18f-184">학과 페이지 *에서* 시도 된 변경이 실패 했음을 사용자 경고에 표시 하 여 동시성 예외를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-184">In the *Departments.aspx* page, handle concurrency exceptions by displaying a message to the user warning that the attempted changes were unsuccessful.</span></span> <span data-ttu-id="fb18f-185">사용자는 현재 값을 확인 하 고 필요한 경우 변경 내용을 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-185">The user can then see the current values and retry the changes if they are still needed.</span></span>

### <a name="enabling-concurrency-tracking-in-the-data-model"></a><span data-ttu-id="fb18f-186">데이터 모델에서 동시성 추적 사용</span><span class="sxs-lookup"><span data-stu-id="fb18f-186">Enabling Concurrency Tracking in the Data Model</span></span>

<span data-ttu-id="fb18f-187">Visual Studio에서이 시리즈의 이전 자습서에서 작업 중인 Contoso 대학 웹 응용 프로그램을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-187">In Visual Studio, open the Contoso University web application that you were working with in the previous tutorial in this series.</span></span>

<span data-ttu-id="fb18f-188">*SchoolModel*를 열고 데이터 모델 디자이너에서 `Department` 엔터티의 `Name` 속성을 마우스 오른쪽 단추로 클릭 한 다음 **속성**을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-188">Open *SchoolModel.edmx*, and in the data model designer, right-click the `Name` property in the `Department` entity and then click **Properties**.</span></span> <span data-ttu-id="fb18f-189">**속성** 창에서 `ConcurrencyMode` 속성을 `Fixed`로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-189">In the **Properties** window, change the `ConcurrencyMode` property to `Fixed`.</span></span>

<span data-ttu-id="fb18f-190">[![Image16](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-190">[![Image16](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span></span>

<span data-ttu-id="fb18f-191">기본 키가 아닌 다른 스칼라 속성 (`Budget`, `StartDate`및 `Administrator`에 대해 동일한 작업을 수행 합니다. 탐색 속성에 대해서는이 작업을 수행할 수 없습니다. 이는 Entity Framework에서 `Update`을 생성 하거나 SQL 명령을 `Delete` 여 데이터베이스의 `Department` 엔터티를 업데이트할 때마다 원래 값이 있는 열을 `Where` 절에 포함 하도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-191">Do the same for the other non-primary-key scalar properties (`Budget`, `StartDate`, and `Administrator`.) (You can't do this for navigation properties.) This specifies that whenever the Entity Framework generates a `Update` or `Delete` SQL command to update the `Department` entity in the database, these columns (with original values) must be included in the `Where` clause.</span></span> <span data-ttu-id="fb18f-192">`Update` 또는 `Delete` 명령이 실행 될 때 행을 찾을 수 없는 경우 Entity Framework는 낙관적 동시성 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-192">If no row is found when the `Update` or `Delete` command executes, the Entity Framework will throw an optimistic-concurrency exception.</span></span>

<span data-ttu-id="fb18f-193">데이터 모델을 저장 하 고 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-193">Save and close the data model.</span></span>

### <a name="handling-concurrency-exceptions-in-the-dal"></a><span data-ttu-id="fb18f-194">DAL에서 동시성 예외 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-194">Handling Concurrency Exceptions in the DAL</span></span>

<span data-ttu-id="fb18f-195">*SchoolRepository.cs* 를 열고 `System.Data` 네임 스페이스에 대해 다음 `using` 문을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-195">Open *SchoolRepository.cs* and add the following `using` statement for the `System.Data` namespace:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

<span data-ttu-id="fb18f-196">낙관적 동시성 예외를 처리 하는 다음과 같은 새 `SaveChanges` 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-196">Add the following new `SaveChanges` method, which handles optimistic concurrency exceptions:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

<span data-ttu-id="fb18f-197">이 메서드가 호출 될 때 동시성 오류가 발생 하면 메모리에 있는 엔터티의 속성 값이 현재 데이터베이스의 값으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-197">If a concurrency error occurs when this method is called, the property values of the entity in memory are replaced with the values currently in the database.</span></span> <span data-ttu-id="fb18f-198">웹 페이지에서 처리할 수 있도록 동시성 예외가 다시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-198">The concurrency exception is rethrown so that the web page can handle it.</span></span>

<span data-ttu-id="fb18f-199">`DeleteDepartment` 및 `UpdateDepartment` 메서드에서 새 메서드를 호출 하기 위해 기존 `context.SaveChanges()` 호출을 `SaveChanges()`에 대 한 호출로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-199">In the `DeleteDepartment` and `UpdateDepartment` methods, replace the existing call to `context.SaveChanges()` with a call to `SaveChanges()` in order to invoke the new method.</span></span>

### <a name="handling-concurrency-exceptions-in-the-presentation-layer"></a><span data-ttu-id="fb18f-200">프레젠테이션 계층에서 동시성 예외 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-200">Handling Concurrency Exceptions in the Presentation Layer</span></span>

<span data-ttu-id="fb18f-201">학과 *.aspx* 를 열고 `DepartmentsObjectDataSource` 컨트롤에 `OnDeleted="DepartmentsObjectDataSource_Deleted"` 특성을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-201">Open *Departments.aspx* and add an `OnDeleted="DepartmentsObjectDataSource_Deleted"` attribute to the `DepartmentsObjectDataSource` control.</span></span> <span data-ttu-id="fb18f-202">이제 컨트롤의 여는 태그는 다음 예제와 유사 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-202">The opening tag for the control will now resemble the following example.</span></span>

[!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

<span data-ttu-id="fb18f-203">다음 예제와 같이 `DepartmentsGridView` 컨트롤에서 `DataKeyNames` 특성의 모든 테이블 열을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-203">In the `DepartmentsGridView` control, specify all of the table columns in the `DataKeyNames` attribute, as shown in the following example.</span></span> <span data-ttu-id="fb18f-204">이렇게 하면 매우 큰 뷰 상태 필드가 생성 됩니다 .이는 추적 필드를 사용 하는 것이 일반적으로 동시성 충돌을 추적 하는 기본 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-204">Note that this will create very large view state fields, which is one reason why using a tracking field is generally the preferred way to track concurrency conflicts.</span></span>

[!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

<span data-ttu-id="fb18f-205">*Departments.aspx.cs* 를 열고 `System.Data` 네임 스페이스에 대해 다음 `using` 문을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-205">Open *Departments.aspx.cs* and add the following `using` statement for the `System.Data` namespace:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

<span data-ttu-id="fb18f-206">다음 새 메서드를 추가 합니다 .이 메서드는 데이터 소스 컨트롤의 `Updated`에서 호출 하 고 동시성 예외를 처리 하기 위한 이벤트 처리기를 `Deleted` 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-206">Add the following new method, which you will call from the data source control's `Updated` and `Deleted` event handlers for handling concurrency exceptions:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

<span data-ttu-id="fb18f-207">이 코드는 예외 형식을 확인 하 고, 동시성 예외인 경우 코드는 `ValidationSummary` 컨트롤에 메시지를 표시 하는 `CustomValidator` 컨트롤을 동적으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-207">This code checks the exception type, and if it's a concurrency exception, the code dynamically creates a `CustomValidator` control that in turn displays a message in the `ValidationSummary` control.</span></span>

<span data-ttu-id="fb18f-208">이전에 추가한 `Updated` 이벤트 처리기에서 새 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-208">Call the new method from the `Updated` event handler that you added earlier.</span></span> <span data-ttu-id="fb18f-209">또한 동일한 메서드를 호출 하지만 다른 작업은 수행 하지 않는 새 `Deleted` 이벤트 처리기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-209">In addition, create a new `Deleted` event handler that calls the same method (but doesn't do anything else):</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

### <a name="testing-optimistic-concurrency-in-the-departments-page"></a><span data-ttu-id="fb18f-210">부서 페이지에서 낙관적 동시성 테스트</span><span class="sxs-lookup"><span data-stu-id="fb18f-210">Testing Optimistic Concurrency in the Departments Page</span></span>

<span data-ttu-id="fb18f-211">*부서 .aspx* 페이지를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-211">Run the *Departments.aspx* page.</span></span>

<span data-ttu-id="fb18f-212">[![Image17](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-212">[![Image17](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span></span>

<span data-ttu-id="fb18f-213">행에서 **편집** 을 클릭 하 고 **예산** 열에서 값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-213">Click **Edit** in a row and change the value in the **Budget** column.</span></span> <span data-ttu-id="fb18f-214">기존 `School` 데이터베이스 레코드에 잘못 된 데이터가 포함 되어 있으므로이 자습서에 대해 만든 레코드만 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-214">(Remember that you can only edit records that you've created for this tutorial, because the existing `School` database records contain some invalid data.</span></span> <span data-ttu-id="fb18f-215">경제성 부서에 대 한 레코드는 시험해 볼 수 있는 것이 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-215">The record for the Economics department is a safe one to experiment with.)</span></span>

<span data-ttu-id="fb18f-216">[![Image18](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-216">[![Image18](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span></span>

<span data-ttu-id="fb18f-217">새 브라우저 창을 열고 페이지를 다시 실행 합니다. 첫 번째 브라우저 창의 주소 상자에서 두 번째 브라우저 창으로 URL을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-217">Open a new browser window and run the page again (copy the URL from the first browser window's address box to the second browser window).</span></span>

<span data-ttu-id="fb18f-218">[![Image17](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-218">[![Image17](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span></span>

<span data-ttu-id="fb18f-219">이전에 편집한 동일한 행에서 **편집** 을 클릭 하 고 **예산** 값을 다른 값으로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-219">Click **Edit** in the same row you edited earlier and change the **Budget** value to something different.</span></span>

<span data-ttu-id="fb18f-220">[![Image19](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-220">[![Image19](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span></span>

<span data-ttu-id="fb18f-221">두 번째 브라우저 창에서 **업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-221">In the second browser window, click **Update**.</span></span> <span data-ttu-id="fb18f-222">**예산** 금액이이 새 값으로 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-222">The **Budget** amount is successfully changed to this new value.</span></span>

<span data-ttu-id="fb18f-223">[![Image20](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-223">[![Image20](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span></span>

<span data-ttu-id="fb18f-224">첫 번째 브라우저 창에서 **업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-224">In the first browser window, click **Update**.</span></span> <span data-ttu-id="fb18f-225">업데이트가 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-225">The update fails.</span></span> <span data-ttu-id="fb18f-226">두 번째 브라우저 창에서 설정한 값을 사용 하 여 **예산** 금액이 다시 표시 되 고 오류 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-226">The **Budget** amount is redisplayed using the value you set in the second browser window, and you see an error message.</span></span>

<span data-ttu-id="fb18f-227">[![Image21](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-227">[![Image21](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span></span>

## <a name="handling-optimistic-concurrency-using-a-tracking-property"></a><span data-ttu-id="fb18f-228">추적 속성을 사용 하 여 낙관적 동시성 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-228">Handling Optimistic Concurrency Using a Tracking Property</span></span>

<span data-ttu-id="fb18f-229">추적 속성이 있는 엔터티에 대 한 낙관적 동시성을 처리 하려면 다음 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-229">To handle optimistic concurrency for an entity that has a tracking property, you will complete the following tasks:</span></span>

- <span data-ttu-id="fb18f-230">데이터 모델에 저장 프로시저를 추가 하 여 `OfficeAssignment` 엔터티를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-230">Add stored procedures to the data model to manage `OfficeAssignment` entities.</span></span> <span data-ttu-id="fb18f-231">(추적 속성 및 저장 프로시저는 함께 사용할 필요가 없습니다. 여기에 설명 된 대로 함께 그룹화 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-231">(Tracking properties and stored procedures don't have to be used together; they're just grouped together here for illustration.)</span></span>
- <span data-ttu-id="fb18f-232">DAL에서 낙관적 동시성 예외를 처리 하는 코드를 비롯 하 여 `OfficeAssignment` 엔터티에 대 한 CRUD 및 BLL에 CRUD 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-232">Add CRUD methods to the DAL and the BLL for `OfficeAssignment` entities, including code to handle optimistic concurrency exceptions in the DAL.</span></span>
- <span data-ttu-id="fb18f-233">Office 할당 웹 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-233">Create an office-assignments web page.</span></span>
- <span data-ttu-id="fb18f-234">새 웹 페이지에서 낙관적 동시성을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-234">Test optimistic concurrency in the new web page.</span></span>

### <a name="adding-officeassignment-stored-procedures-to-the-data-model"></a><span data-ttu-id="fb18f-235">데이터 모델에 OfficeAssignment 저장 프로시저 추가</span><span class="sxs-lookup"><span data-stu-id="fb18f-235">Adding OfficeAssignment Stored Procedures to the Data Model</span></span>

<span data-ttu-id="fb18f-236">모델 디자이너에서 *SchoolModel* 파일을 열고 디자인 화면을 마우스 오른쪽 단추로 클릭 한 다음 **데이터베이스에서 모델 업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-236">Open the *SchoolModel.edmx* file in the model designer, right-click the design surface, and click **Update Model from Database**.</span></span> <span data-ttu-id="fb18f-237">**데이터베이스 개체 선택** 대화 상자의 **추가** 탭에서 **저장 프로시저** 를 확장 하 고 세 개의 `OfficeAssignment` 저장 프로시저 (다음 스크린샷 참조)를 선택한 다음 **마침**을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-237">In the **Add** tab of the **Choose Your Database Objects** dialog box, expand **Stored Procedures** and select the three `OfficeAssignment` stored procedures (see the following screenshot), and then click **Finish**.</span></span> <span data-ttu-id="fb18f-238">이러한 저장 프로시저는 스크립트를 사용 하 여 다운로드 하거나 만들 때 데이터베이스에 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-238">(These stored procedures were already in the database when you downloaded or created it using a script.)</span></span>

<span data-ttu-id="fb18f-239">[![Image02](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-239">[![Image02](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span></span>

<span data-ttu-id="fb18f-240">`OfficeAssignment` 엔터티를 마우스 오른쪽 단추로 클릭 하 고 **저장 프로시저 매핑**을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-240">Right-click the `OfficeAssignment` entity and select **Stored Procedure Mapping**.</span></span>

<span data-ttu-id="fb18f-241">[![Image03](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-241">[![Image03](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span></span>

<span data-ttu-id="fb18f-242">해당 저장 프로시저를 사용 하도록 **Insert**, **Update**및 **Delete** 함수를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-242">Set the **Insert**, **Update**, and **Delete** functions to use their corresponding stored procedures.</span></span> <span data-ttu-id="fb18f-243">`Update` 함수의 `OrigTimestamp` 매개 변수에 대해 **속성** 을 `Timestamp`로 설정 하 고 **원래 값 사용** 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-243">For the `OrigTimestamp` parameter of the `Update` function, set the **Property** to `Timestamp` and select the **Use Original Value** option.</span></span>

<span data-ttu-id="fb18f-244">[![Image04](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image30.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image29.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-244">[![Image04](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image30.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image29.png)</span></span>

<span data-ttu-id="fb18f-245">Entity Framework `UpdateOfficeAssignment` 저장 프로시저를 호출 하면 `OrigTimestamp` 매개 변수에 `Timestamp` 열의 원래 값이 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-245">When the Entity Framework calls the `UpdateOfficeAssignment` stored procedure, it will pass the original value of the `Timestamp` column in the `OrigTimestamp` parameter.</span></span> <span data-ttu-id="fb18f-246">저장 프로시저는 `Where` 절에서이 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-246">The stored procedure uses this parameter in its `Where` clause:</span></span>

[!code-sql[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.sql)]

<span data-ttu-id="fb18f-247">또한 저장 프로시저는 업데이트 후에 `Timestamp` 열의 새 값을 선택 하 여 Entity Framework 메모리에 있는 `OfficeAssignment` 엔터티를 해당 데이터베이스 행과 동기화 상태로 유지할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-247">The stored procedure also selects the new value of the `Timestamp` column after the update so that the Entity Framework can keep the `OfficeAssignment` entity that's in memory in sync with the corresponding database row.</span></span>

<span data-ttu-id="fb18f-248">사무실 할당을 삭제 하는 저장 프로시저에는 `OrigTimestamp` 매개 변수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-248">(Note that the stored procedure for deleting an office assignment doesn't have an `OrigTimestamp` parameter.</span></span> <span data-ttu-id="fb18f-249">따라서 Entity Framework 엔터티를 삭제 하기 전에 변경 되지 않은 것으로 확인할 수 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-249">Because of this, the Entity Framework can't verify that an entity is unchanged before deleting it.)</span></span>

<span data-ttu-id="fb18f-250">데이터 모델을 저장 하 고 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-250">Save and close the data model.</span></span>

### <a name="adding-officeassignment-methods-to-the-dal"></a><span data-ttu-id="fb18f-251">DAL에 OfficeAssignment 메서드 추가</span><span class="sxs-lookup"><span data-stu-id="fb18f-251">Adding OfficeAssignment Methods to the DAL</span></span>

<span data-ttu-id="fb18f-252">*ISchoolRepository.cs* 를 열고 `OfficeAssignment` 엔터티 집합에 대해 다음과 같은 CRUD 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-252">Open *ISchoolRepository.cs* and add the following CRUD methods for the `OfficeAssignment` entity set:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

<span data-ttu-id="fb18f-253">*SchoolRepository.cs*에 다음과 같은 새 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-253">Add the following new methods to *SchoolRepository.cs*.</span></span> <span data-ttu-id="fb18f-254">`UpdateOfficeAssignment` 메서드에서는 `context.SaveChanges`대신 로컬 `SaveChanges` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-254">In the `UpdateOfficeAssignment` method, you call the local `SaveChanges` method instead of `context.SaveChanges`.</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

<span data-ttu-id="fb18f-255">테스트 프로젝트에서 *MockSchoolRepository.cs* 를 열고 다음 `OfficeAssignment` COLLECTION 및 CRUD 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-255">In the test project, open *MockSchoolRepository.cs* and add the following `OfficeAssignment` collection and CRUD methods to it.</span></span> <span data-ttu-id="fb18f-256">(모의 리포지토리는 리포지토리 인터페이스를 구현 해야 합니다. 그렇지 않으면 솔루션이 컴파일되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="fb18f-256">(The mock repository must implement the repository interface, or the solution won't compile.)</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

### <a name="adding-officeassignment-methods-to-the-bll"></a><span data-ttu-id="fb18f-257">OfficeAssignment 메서드를 BLL에 추가</span><span class="sxs-lookup"><span data-stu-id="fb18f-257">Adding OfficeAssignment Methods to the BLL</span></span>

<span data-ttu-id="fb18f-258">주 프로젝트에서 *SchoolBL.cs* 를 열고 `OfficeAssignment` 엔터티 집합에 대해 다음과 같은 CRUD 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-258">In the main project, open *SchoolBL.cs* and add the following CRUD methods for the `OfficeAssignment` entity set to it:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

## <a name="creating-an-officeassignments-web-page"></a><span data-ttu-id="fb18f-259">OfficeAssignments 웹 페이지 만들기</span><span class="sxs-lookup"><span data-stu-id="fb18f-259">Creating an OfficeAssignments Web Page</span></span>

<span data-ttu-id="fb18f-260">*Site.master* 마스터 페이지를 사용 하는 새 웹 페이지를 만들고 이름을 *OfficeAssignments*로 다시 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-260">Create a new web page that uses the *Site.Master* master page and name it *OfficeAssignments.aspx*.</span></span> <span data-ttu-id="fb18f-261">`Content2`이라는 `Content` 컨트롤에 다음 태그를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-261">Add the following markup to the `Content` control named `Content2`:</span></span>

[!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.aspx)]

<span data-ttu-id="fb18f-262">`DataKeyNames` 특성에서 태그는 `Timestamp` 속성 뿐만 아니라 레코드 키 (`InstructorID`)를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-262">Notice that in the `DataKeyNames` attribute, the markup specifies the `Timestamp` property as well as the record key (`InstructorID`).</span></span> <span data-ttu-id="fb18f-263">`DataKeyNames` 특성에 속성을 지정 하면 컨트롤이 다시 게시 처리 중에 원래 값을 사용할 수 있도록 컨트롤 상태 (뷰 상태와 유사)로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-263">Specifying properties in the `DataKeyNames` attribute causes the control to save them in control state (which is similar to view state) so that the original values are available during postback processing.</span></span>

<span data-ttu-id="fb18f-264">`Timestamp` 값을 저장 하지 않은 경우 Entity Framework는 SQL `Update` 명령의 `Where` 절에 대해이 값을 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-264">If you didn't save the `Timestamp` value, the Entity Framework would not have it for the `Where` clause of the SQL `Update` command.</span></span> <span data-ttu-id="fb18f-265">따라서 업데이트할 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-265">Consequently nothing would be found to update.</span></span> <span data-ttu-id="fb18f-266">따라서 Entity Framework `OfficeAssignment` 엔터티가 업데이트 될 때마다 낙관적 동시성 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-266">As a result, the Entity Framework would throw an optimistic concurrency exception every time an `OfficeAssignment` entity is updated.</span></span>

<span data-ttu-id="fb18f-267">*OfficeAssignments.aspx.cs* 를 열고 데이터 액세스 계층에 대해 다음 `using` 문을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-267">Open *OfficeAssignments.aspx.cs* and add the following `using` statement for the data access layer:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

<span data-ttu-id="fb18f-268">Dynamic Data 기능을 사용할 수 있는 다음 `Page_Init` 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-268">Add the following `Page_Init` method, which enables Dynamic Data functionality.</span></span> <span data-ttu-id="fb18f-269">또한 동시성 오류를 확인 하기 위해 `ObjectDataSource` 컨트롤의 `Updated` 이벤트에 대해 다음 처리기를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-269">Also add the following handler for the `ObjectDataSource` control's `Updated` event in order to check for concurrency errors:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

### <a name="testing-optimistic-concurrency-in-the-officeassignments-page"></a><span data-ttu-id="fb18f-270">OfficeAssignments 페이지에서 낙관적 동시성 테스트</span><span class="sxs-lookup"><span data-stu-id="fb18f-270">Testing Optimistic Concurrency in the OfficeAssignments Page</span></span>

<span data-ttu-id="fb18f-271">*OfficeAssignments* 페이지를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-271">Run the *OfficeAssignments.aspx* page.</span></span>

<span data-ttu-id="fb18f-272">[![Image10](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image32.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-272">[![Image10](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image32.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image31.png)</span></span>

<span data-ttu-id="fb18f-273">행에서 **편집** 을 클릭 하 고 **위치** 열에서 값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-273">Click **Edit** in a row and change the value in the **Location** column.</span></span>

<span data-ttu-id="fb18f-274">[![Image11](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image34.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-274">[![Image11](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image34.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image33.png)</span></span>

<span data-ttu-id="fb18f-275">새 브라우저 창을 열고 페이지를 다시 실행 합니다. 첫 번째 브라우저 창에서 두 번째 브라우저 창으로 URL을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-275">Open a new browser window and run the page again (copy the URL from the first browser window to the second browser window).</span></span>

<span data-ttu-id="fb18f-276">[![Image10](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image36.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-276">[![Image10](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image36.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image35.png)</span></span>

<span data-ttu-id="fb18f-277">이전에 편집한 동일한 행에서 **편집** 을 클릭 하 고 **위치** 값을 다른 값으로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-277">Click **Edit** in the same row you edited earlier and change the **Location** value to something different.</span></span>

<span data-ttu-id="fb18f-278">[![Image12](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image38.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-278">[![Image12](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image38.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image37.png)</span></span>

<span data-ttu-id="fb18f-279">두 번째 브라우저 창에서 **업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-279">In the second browser window, click **Update**.</span></span>

<span data-ttu-id="fb18f-280">[![Image13](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image40.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-280">[![Image13](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image40.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image39.png)</span></span>

<span data-ttu-id="fb18f-281">첫 번째 브라우저 창으로 전환 하 고 **업데이트**를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-281">Switch to the first browser window and click **Update**.</span></span>

<span data-ttu-id="fb18f-282">[![Image15](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image42.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-282">[![Image15](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image42.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image41.png)</span></span>

<span data-ttu-id="fb18f-283">오류 메시지가 표시 되 고 **위치** 값이 업데이트 되어 두 번째 브라우저 창에서 변경한 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-283">You see an error message and the **Location** value has been updated to show the value you changed it to in the second browser window.</span></span>

## <a name="handling-concurrency-with-the-entitydatasource-control"></a><span data-ttu-id="fb18f-284">EntityDataSource 컨트롤을 사용 하 여 동시성 처리</span><span class="sxs-lookup"><span data-stu-id="fb18f-284">Handling Concurrency with the EntityDataSource Control</span></span>

<span data-ttu-id="fb18f-285">`EntityDataSource` 컨트롤은 데이터 모델의 동시성 설정을 인식 하 고 업데이트 및 삭제 작업을 적절 하 게 처리 하는 기본 제공 논리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-285">The `EntityDataSource` control includes built-in logic that recognizes the concurrency settings in the data model and handles update and delete operations accordingly.</span></span> <span data-ttu-id="fb18f-286">그러나 모든 예외와 마찬가지로 사용자에 게 친숙 한 오류 메시지를 제공 하기 위해 `OptimisticConcurrencyException` 예외를 직접 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-286">However, as with all exceptions, you must handle `OptimisticConcurrencyException` exceptions yourself in order to provide a user-friendly error message.</span></span>

<span data-ttu-id="fb18f-287">다음으로 `EntityDataSource` 컨트롤을 사용 하는 *강의* 페이지를 구성 하 여 업데이트 및 삭제 작업을 허용 하 고 동시성 충돌이 발생 하는 경우 오류 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-287">Next, you will configure the *Courses.aspx* page (which uses an `EntityDataSource` control) to allow update and delete operations and to display an error message if a concurrency conflict occurs.</span></span> <span data-ttu-id="fb18f-288">`Course` 엔터티에는 동시성 추적 열이 없으므로 `Department` 엔터티를 사용 하 여 수행한 것과 동일한 메서드를 사용 합니다. 키가 아닌 모든 속성의 값을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-288">The `Course` entity doesn't have a concurrency tracking column, so you will use the same method that you did with the `Department` entity: track the values of all non-key properties.</span></span>

<span data-ttu-id="fb18f-289">*SchoolModel* 파일을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-289">Open the *SchoolModel.edmx* file.</span></span> <span data-ttu-id="fb18f-290">`Course` 엔터티의 키가 아닌 속성 (`Title`, `Credits`및 `DepartmentID`)에 대해 **동시성 모드** 속성을 `Fixed`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-290">For the non-key properties of the `Course` entity (`Title`, `Credits`, and `DepartmentID`), set the **Concurrency Mode** property to `Fixed`.</span></span> <span data-ttu-id="fb18f-291">그런 다음 데이터 모델을 저장 하 고 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-291">Then save and close the data model.</span></span>

<span data-ttu-id="fb18f-292">*Default.aspx* 페이지를 열고 다음과 같이 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-292">Open the *Courses.aspx* page and make the following changes:</span></span>

- <span data-ttu-id="fb18f-293">`CoursesEntityDataSource` 컨트롤에서 `EnableUpdate="true"` 및 `EnableDelete="true"` 특성을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-293">In the `CoursesEntityDataSource` control, add `EnableUpdate="true"` and `EnableDelete="true"` attributes.</span></span> <span data-ttu-id="fb18f-294">이제 해당 컨트롤의 여는 태그는 다음 예제와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-294">The opening tag for that control now resembles the following example:</span></span>

    [!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample16.aspx)]
- <span data-ttu-id="fb18f-295">`CoursesGridView` 컨트롤에서 `DataKeyNames` 특성 값을 `"CourseID,Title,Credits,DepartmentID"`로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-295">In the `CoursesGridView` control, change the `DataKeyNames` attribute value to `"CourseID,Title,Credits,DepartmentID"`.</span></span> <span data-ttu-id="fb18f-296">그런 다음 **편집** 및 **삭제** 단추 (`<asp:CommandField ShowEditButton="True" ShowDeleteButton="True" />`)를 표시 하는 `Columns` 요소에 `CommandField` 요소를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-296">Then add a `CommandField` element to the `Columns` element that shows **Edit** and **Delete** buttons (`<asp:CommandField ShowEditButton="True" ShowDeleteButton="True" />`).</span></span> <span data-ttu-id="fb18f-297">이제 `GridView` 컨트롤은 다음 예제와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-297">The `GridView` control now resembles the following example:</span></span>

    [!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample17.aspx)]

<span data-ttu-id="fb18f-298">페이지를 실행 하 고 부서 페이지에서 수행한 것과 같은 충돌 상황을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-298">Run the page and create a conflict situation as you did before in the Departments page.</span></span> <span data-ttu-id="fb18f-299">두 브라우저 창에서 페이지를 실행 하 고, 각 창의 같은 줄에서 **편집** 을 클릭 하 고, 각 창에서 다른 변경을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-299">Run the page in two browser windows, click **Edit** in the same line in each window, and make a different change in each one.</span></span> <span data-ttu-id="fb18f-300">한 창에서 **업데이트** 를 클릭 한 다음 다른 창에서 **업데이트** 를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-300">Click **Update** in one window and then click **Update** in the other window.</span></span> <span data-ttu-id="fb18f-301">**업데이트** 를 두 번 클릭 하면 처리 되지 않은 동시성 예외로 인해 발생 하는 오류 페이지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-301">When you click **Update** the second time, you see the error page that results from an unhandled concurrency exception.</span></span>

<span data-ttu-id="fb18f-302">[![Image22](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image44.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image43.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-302">[![Image22](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image44.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image43.png)</span></span>

<span data-ttu-id="fb18f-303">이 오류는 `ObjectDataSource` 컨트롤에 대해 처리 하는 방법과 매우 비슷한 방식으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-303">You handle this error in a manner very similar to how you handled it for the `ObjectDataSource` control.</span></span> <span data-ttu-id="fb18f-304">*Default.aspx* 페이지를 열고 `CoursesEntityDataSource` 컨트롤에서 `Deleted` 및 `Updated` 이벤트에 대 한 처리기를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-304">Open the *Courses.aspx* page, and in the `CoursesEntityDataSource` control, specify handlers for the `Deleted` and `Updated` events.</span></span> <span data-ttu-id="fb18f-305">이제 컨트롤의 여는 태그는 다음 예제와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-305">The opening tag of the control now resembles the following example:</span></span>

[!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample18.aspx)]

<span data-ttu-id="fb18f-306">`CoursesGridView` 컨트롤 전에 다음 `ValidationSummary` 컨트롤을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-306">Before the `CoursesGridView` control, add the following `ValidationSummary` control:</span></span>

[!code-aspx[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample19.aspx)]

<span data-ttu-id="fb18f-307">*Courses.aspx.cs*에서 `System.Data` 네임 스페이스에 대 한 `using` 문을 추가 하 고, 동시성 예외를 확인 하는 메서드를 추가 하 고, `EntityDataSource` 컨트롤의 `Updated` 및 `Deleted` 처리기에 대 한 처리기를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-307">In *Courses.aspx.cs*, add a `using` statement for the `System.Data` namespace, add a method that checks for concurrency exceptions, and add handlers for the `EntityDataSource` control's `Updated` and `Deleted` handlers.</span></span> <span data-ttu-id="fb18f-308">코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-308">The code will look like the following:</span></span>

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample20.cs)]

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/samples/sample21.cs)]

<span data-ttu-id="fb18f-309">이 코드와 `ObjectDataSource` 컨트롤에 대해 수행한 작업의 차이점은이 경우 동시성 예외는 해당 예외의 `InnerException` 속성이 아닌 이벤트 인수 개체의 `Exception` 속성에 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-309">The only difference between this code and what you did for the `ObjectDataSource` control is that in this case the concurrency exception is in the `Exception` property of the event arguments object rather than in that exception's `InnerException` property.</span></span>

<span data-ttu-id="fb18f-310">페이지를 실행 하 고 동시성 충돌을 다시 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-310">Run the page and create a concurrency conflict again.</span></span> <span data-ttu-id="fb18f-311">이번에는 다음과 같은 오류 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-311">This time you see an error message:</span></span>

<span data-ttu-id="fb18f-312">[![Image23](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image46.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image45.png)</span><span class="sxs-lookup"><span data-stu-id="fb18f-312">[![Image23](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image46.png)](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application/_static/image45.png)</span></span>

<span data-ttu-id="fb18f-313">동시성 충돌 처리에 대한 소개를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-313">This completes the introduction to handling concurrency conflicts.</span></span> <span data-ttu-id="fb18f-314">다음 자습서에서는 Entity Framework를 사용 하는 웹 응용 프로그램의 성능을 향상 시키는 방법에 대 한 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb18f-314">The next tutorial will provide guidance on how to improve performance in a web application that uses the Entity Framework.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="fb18f-315">[이전](using-the-entity-framework-and-the-objectdatasource-control-part-3-sorting-and-filtering.md)
> [다음](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application.md)</span><span class="sxs-lookup"><span data-stu-id="fb18f-315">[Previous](using-the-entity-framework-and-the-objectdatasource-control-part-3-sorting-and-filtering.md)
[Next](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application.md)</span></span>
