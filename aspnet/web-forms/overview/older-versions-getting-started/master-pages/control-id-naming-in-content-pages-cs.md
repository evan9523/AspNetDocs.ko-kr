---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
title: 콘텐츠 페이지 (C#)에서 ID 명명 제어 | Microsoft Docs
author: rick-anderson
description: Contentplaceholder 명명 컨테이너 역할을 하 고 따라서 (FindConrol)를 통해 어려운 컨트롤을 사용 하 여 프로그래밍 방식으로 작업을 확인 하는 방법을 보여 줍니다...
ms.author: riande
ms.date: 06/10/2008
ms.assetid: 1c7d0916-0988-4b4f-9a03-935e4b5af6af
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
msc.type: authoredcontent
ms.openlocfilehash: 0c8617bb14c7023cfd926022b66c69bb5762758b
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/01/2019
ms.locfileid: "57055210"
---
<a name="control-id-naming-in-content-pages-c"></a><span data-ttu-id="0d7e3-103">콘텐츠 페이지에서 컨트롤 ID 이름 지정(C#)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-103">Control ID Naming in Content Pages (C#)</span></span>
====================
<span data-ttu-id="0d7e3-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0d7e3-105">[코드를 다운로드](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip) 또는 [PDF 다운로드](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-105">[Download Code](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip) or [Download PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span></span>

> <span data-ttu-id="0d7e3-106">Contentplaceholder 명명 컨테이너 역할을 하 고 따라서 (FindConrol)를 통해 어려운 컨트롤을 사용 하 여 프로그래밍 방식으로 작업을 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindConrol).</span></span> <span data-ttu-id="0d7e3-107">이 문제와 해결 방법에 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="0d7e3-108">결과 ClientID 값을 프로그래밍 방식으로 액세스 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>


## <a name="introduction"></a><span data-ttu-id="0d7e3-109">소개</span><span class="sxs-lookup"><span data-stu-id="0d7e3-109">Introduction</span></span>

<span data-ttu-id="0d7e3-110">모든 ASP.NET 서버 컨트롤에 포함는 `ID` 속성을 고유 하 게 컨트롤을 식별 하는 컨트롤은 프로그래밍 방식으로 액세스할 코드 숨김 클래스에서에서는 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="0d7e3-111">마찬가지로, HTML 문서에서 요소를 포함할 수 있습니다는 `id` 요소를 고유 하 게 식별 하는 특성; 이러한 `id` 값은 보통 특정 HTML 요소를 프로그래밍 방식으로 참조 하려면 클라이언트 쪽 스크립트에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="0d7e3-112">이 점을 고려 하 고 가정할 수도 있습니다는 ASP.NET 서버 컨트롤을 HTML로 렌더링 될 때 해당 `ID` 값으로 사용 되는 `id` 렌더링 된 HTML 요소의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="0d7e3-113">이 아니므로 반드시 경우 특정 상황에서 하나의 단일 제어 `ID` 렌더링 되는 태그에 값이 여러 번 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="0d7e3-114">GridView 컨트롤 레이블 웹 컨트롤을 사용 하 여 templatefield로 포함 하는 것이 좋습니다는 `ID` ProductName의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of ProductName.</span></span> <span data-ttu-id="0d7e3-115">런타임에 해당 데이터 원본에 GridView 바인딩되면이 레이블은 모든 GridView 행에 대해 한 번 반복 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="0d7e3-116">각 렌더링 레이블 요구 고유한 `id` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="0d7e3-117">이러한 시나리오를 처리 하려면 ASP.NET에 특정 컨트롤을 컨테이너 이름으로 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="0d7e3-118">명명 컨테이너 역할을 새 `ID` 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="0d7e3-119">명명 컨테이너 내에 나타나는 모든 서버 컨트롤에는 해당 렌더링 `id` 접두사가 붙은 `ID` 명명 컨테이너 컨트롤의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="0d7e3-120">예를 들어 합니다 `GridView` 고 `GridViewRow` 클래스는 모두 명명 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="0d7e3-121">따라서 레이블 컨트롤을 사용 하 여 GridView templatefield로에 정의 된 `ID` ProductName 렌더링 된 같습니다 `id` 의 값 `GridViewID_GridViewRowID_ProductName`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-121">Consequently, a Label control defined in a GridView TemplateField with `ID` ProductName is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="0d7e3-122">때문에 *GridViewRowID* 결과 각 GridView 행에 대해 고유한 `id` 값은 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="0d7e3-123">합니다 [ `INamingContainer` 인터페이스](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) 명명 컨테이너 특정 ASP.NET 서버 컨트롤을 작동 해야 하는지 나타내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="0d7e3-124">`INamingContainer` 인터페이스 서버 컨트롤을 구현 해야 하는 메서드 나와 있지 않습니다; 대신 한 표식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="0d7e3-125">렌더링 된 태그를 생성에서 컨트롤을이 인터페이스를 구현 하는 경우 다음 ASP.NET 엔진 자동으로 붙입니다 해당 `ID` 값을 해당 하위 항목의 렌더링 `id` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="0d7e3-126">이 프로세스는 2 단계에서에서 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-126">This process is discussed in more detail in Step 2.</span></span>


<span data-ttu-id="0d7e3-127">명명 컨테이너 뿐만 아니라는 렌더링 된 변경 `id` 특성 값, 있지만 어떻게 컨트롤 참조 될 수 있습니다 프로그래밍 방식으로 ASP.NET 페이지의 코드 숨김 클래스에서 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="0d7e3-128">`FindControl("controlID")` 메서드는 일반적으로 웹 컨트롤을 프로그래밍 방식으로 참조 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="0d7e3-129">그러나 `FindControl` 명명 컨테이너를 통해 침투 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="0d7e3-130">직접 사용할 수 없습니다 결과적으로 `Page.FindControl` GridView 또는 다른 명명 컨테이너 내의 컨트롤을 참조 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="0d7e3-131">정답 있는 수에 따라 마스터 페이지 및 ContentPlaceHolders 둘 다로 구현 됩니다 명명 컨테이너.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="0d7e3-132">어떻게 마스터 페이지에 영향을 HTML 요소가이 자습서에서 살펴봅니다 `id` 프로그래밍 방식으로 사용 하 여 콘텐츠 페이지 내에서 웹 컨트롤을 참조 하는 방법 및 값 `FindControl`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="0d7e3-133">1단계: 새 ASP.NET 페이지 추가</span><span class="sxs-lookup"><span data-stu-id="0d7e3-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="0d7e3-134">이 자습서에서 설명한 개념을 보여 주기 위해 웹 사이트를 새 ASP.NET 페이지를 추가 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="0d7e3-135">라는 새 콘텐츠 페이지를 만듭니다 `IDIssues.aspx` 루트 폴더에서에 바인딩하지는 `Site.master` 마스터 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>


![콘텐츠 페이지 IDIssues.aspx 루트 폴더에 추가](control-id-naming-in-content-pages-cs/_static/image1.png)

<span data-ttu-id="0d7e3-137">**그림 01**: 콘텐츠 페이지 추가 `IDIssues.aspx` 루트 폴더에</span><span class="sxs-lookup"><span data-stu-id="0d7e3-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>


<span data-ttu-id="0d7e3-138">Visual Studio는 자동으로 각 마스터 페이지의 네 가지 ContentPlaceHolders에 대 한 콘텐츠 컨트롤을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="0d7e3-139">설명한 것 처럼 합니다 [ *여러 ContentPlaceHolders 및 기본 콘텐츠* ](multiple-contentplaceholders-and-default-content-cs.md) 자습서, 마스터 페이지의 기본 ContentPlaceHolder 콘텐츠 대신 내보내집니다 콘텐츠 컨트롤이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-cs.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="0d7e3-140">때문에 합니다 `QuickLoginUI` 하 고 `LeftColumnContent` ContentPlaceHolders이이 페이지에 대 한 적합 한 기본 태그를 포함, 계속 해 서 해당 제거에서 콘텐츠 컨트롤 `IDIssues.aspx`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="0d7e3-141">이 시점에서 콘텐츠 페이지의 선언적 태그는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-141">At this point, the content page's declarative markup should look like the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample1.aspx)]

<span data-ttu-id="0d7e3-142">에 [ *마스터 페이지에서 제목, 메타 태그 및 기타 HTML 헤더 지정* ](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) 자습서는 사용자 지정 기본 페이지 클래스를 만들었습니다 (`BasePage`) 자동으로 구성 하는 페이지 제목 경우 명시적으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="0d7e3-143">에 대 한 합니다 `IDIssues.aspx` 이 기능을 사용 하 여 페이지에서 페이지의 코드 숨김 클래스에서 파생 되어야 합니다 `BasePage` 클래스 (대신 `System.Web.UI.Page`).</span><span class="sxs-lookup"><span data-stu-id="0d7e3-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="0d7e3-144">다음과 같이 표시 되도록 코드 숨김 클래스의 정의 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-144">Modify the code-behind class's definition so that it looks like the following:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample2.cs)]

<span data-ttu-id="0d7e3-145">마지막으로 업데이트 된 `Web.sitemap` 새이 단원에 대 한 항목을 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="0d7e3-146">추가 `<siteMapNode>` 요소 집합과 해당 `title` 하 고 `url` 특성을 "컨트롤 ID 이름 지정 문제" 및 `~/IDIssues.aspx`각각.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="0d7e3-147">이 추가 마치면 프로그램 `Web.sitemap` 파일의 태그는 다음과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>


[!code-xml[Main](control-id-naming-in-content-pages-cs/samples/sample3.xml)]

<span data-ttu-id="0d7e3-148">그림 2에서 볼 수 있듯이에서 새 사이트 맵 항목 `Web.sitemap` 왼쪽된 열에서 단원 섹션에 즉시 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>


![단원 섹션에는 이제 링크를 포함 &quot;명명 문제 ID를 제어 합니다.&quot;](control-id-naming-in-content-pages-cs/_static/image2.png)

<span data-ttu-id="0d7e3-150">**그림 02**: 단원 섹션에는 이제 "컨트롤 ID 명명 문제"에 대 한 링크 포함</span><span class="sxs-lookup"><span data-stu-id="0d7e3-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>


## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="0d7e3-151">2단계: 렌더링 된 검사`ID`변경</span><span class="sxs-lookup"><span data-stu-id="0d7e3-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="0d7e3-152">ASP.NET 수정 사항을 더 잘 이해 하려면 엔진에 게는 렌더링 된 `id` 서버의 값을 제어, 몇 가지 웹 컨트롤을 추가 해 보겠습니다는 `IDIssues.aspx` 페이지 후 렌더링 되는 브라우저에 보내지는 태그를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="0d7e3-153">텍스트에 특히, 형식 "나이 입력 하세요:" 텍스트 웹 컨트롤 뒤에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="0d7e3-154">더 아래로 페이지에서 추가 단추 웹 컨트롤 및 레이블 웹 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="0d7e3-155">텍스트 상자의 설정 `ID` 하 고 `Columns` 속성을 `Age` 및 3, 각각.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="0d7e3-156">설정 단추 `Text` 하 고 `ID` 속성을 "제출" 및 `SubmitButton`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="0d7e3-157">레이블의 지웁니다 `Text` 속성 집합과 해당 `ID` 에 `Results`입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="0d7e3-158">이 시점에서 콘텐츠 컨트롤의 선언적 태그는 다음과 비슷하게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-158">At this point your Content control's declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample4.aspx)]

<span data-ttu-id="0d7e3-159">그림 3에서는 Visual Studio의 디자이너를 통해 볼 때 페이지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>


<span data-ttu-id="0d7e3-160">[![페이지에는 세 개의 웹 컨트롤이 포함 됩니다:는 텍스트, 단추 및 레이블](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-160">[![The Page Includes Three Web Controls: a TextBox, Button, and Label](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span></span>

<span data-ttu-id="0d7e3-161">**그림 03**: 페이지 포함 세 개의 웹 컨트롤이:는 텍스트, 단추 및 레이블 ([클릭 하 여 큰 이미지 보기](control-id-naming-in-content-pages-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="0d7e3-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image5.png))</span></span>


<span data-ttu-id="0d7e3-162">브라우저를 통해 페이지를 방문 하 고의 HTML 소스를 봅니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="0d7e3-163">아래 태그로 `id` 텍스트 상자, 단추 및 레이블을 웹 컨트롤에 대 한 HTML 요소 값의 조합인 합니다 `ID` 웹 컨트롤의 값 및 `ID` 페이지에서 명명 컨테이너의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample5.html)]

<span data-ttu-id="0d7e3-164">이 자습서의 앞부분에서 설명 했 듯이 마스터 페이지와 해당 ContentPlaceHolders 명명 컨테이너를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="0d7e3-165">결과적으로 모두 참여는 렌더링 된 `ID` 해당 중첩 된 컨트롤의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="0d7e3-166">텍스트 상자의 걸릴 `id` 특성을 예를 들어: `ctl00_MainContent_Age`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="0d7e3-167">이전에 설명한 대로 TextBox 컨트롤의 `ID` 값이 `Age`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="0d7e3-168">이 각각의 ContentPlaceHolder 컨트롤로 접두사로 `ID` 값을 `MainContent`입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="0d7e3-169">이 값이 마스터 페이지에 접두사로 게다가 `ID` 값을 `ctl00`입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="0d7e3-170">최종 결과 `id` 특성 값으로 이루어진는 `ID` 마스터 페이지, ContentPlaceHolder 컨트롤을 자체 입력란의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="0d7e3-171">그림 4에서는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="0d7e3-172">렌더링 된 결정할 `id` 의 `Age` 텍스트 상자를 시작 합니다 `ID` TextBox 컨트롤의 값 `Age`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="0d7e3-173">다음으로, 컨트롤 계층 구조로으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="0d7e3-174">각 명명 컨테이너 (복숭아색 색을 사용 하 여 해당 노드)에서 현재 렌더링 접두사 `id` 의 명명 컨테이너를 사용 하 여 `id`입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>


![렌더링 된 id 특성은 기반에서 ID 값의 명명 컨테이너](control-id-naming-in-content-pages-cs/_static/image6.png)

<span data-ttu-id="0d7e3-176">**그림 04**: 렌더링 된 `id` 특성에 기반을 `ID` 명명 컨테이너의 값</span><span class="sxs-lookup"><span data-stu-id="0d7e3-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>


> [!NOTE]
> <span data-ttu-id="0d7e3-177">앞에서 설명한 것 처럼를 `ctl00` 부분 렌더링 된 `id` 특성을 `ID` 마스터 페이지의 값을 궁금할 수 있습니다 어떻게이 `ID` 값에 대 한 제공.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="0d7e3-178">지정 하지 않았기 하 아무 곳 이나 마스터 페이지나 콘텐츠 페이지에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="0d7e3-179">대부분의 서버 컨트롤과 ASP.NET 페이지에서 페이지의 선언적 태그를 통해 명시적으로 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="0d7e3-180">합니다 `MainContent` 각각의 ContentPlaceHolder 컨트롤로의 태그에 명시적으로 지정 된 `Site.master`; `Age` 텍스트 상자에서 정의한 `IDIssues.aspx`의 태그입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="0d7e3-181">지정할 수 있습니다는 `ID` 이러한 종류의 선언적 구문 또는 속성 창을 통해 컨트롤에 대 한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="0d7e3-182">마스터 페이지 자체와 같은 다른 컨트롤을 선언적 태그에 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="0d7e3-183">따라서 해당 `ID` 값을 자동으로 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="0d7e3-184">ASP.NET 엔진 집합을 `ID` Id를 가진 명시적으로 설정 되지 않은 해당 컨트롤에 대 한 런타임 시 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="0d7e3-185">명명 패턴을 사용 하 여 `ctlXX`, 여기서 *XX* 정수 값인 순차적으로 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>


<span data-ttu-id="0d7e3-186">마스터 페이지 명명 컨테이너 역할을 하기 때문에 마스터 페이지에 정의 된 웹 컨트롤 수도 있는 변경 렌더링 `id` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="0d7e3-187">예를 들어 합니다 `DisplayDate` 에서 마스터 페이지에 추가한 레이블을 합니다 [ *마스터 페이지를 사용 하 여 사이트 전체 레이아웃 만들기* ](creating-a-site-wide-layout-using-master-pages-cs.md) 자습서에 태그를 렌더링 하는 다음과 같은:</span><span class="sxs-lookup"><span data-stu-id="0d7e3-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md) tutorial has the following rendered markup:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample6.html)]

<span data-ttu-id="0d7e3-188">유의 합니다 `id` 모두 마스터 페이지의 포함 `ID` 값 (`ctl00`) 및 `ID` Label 웹 컨트롤의 값 (`DateDisplay`).</span><span class="sxs-lookup"><span data-stu-id="0d7e3-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="0d7e3-189">3단계: 통해 웹 컨트롤을 프로그래밍 방식으로 참조`FindControl`</span><span class="sxs-lookup"><span data-stu-id="0d7e3-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="0d7e3-190">모든 ASP.NET 서버 컨트롤에는 `FindControl("controlID")` 이라는 이름의 컨트롤에 대 한 컨트롤의 하위 항목을 검색 하는 메서드 *controlID*합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="0d7e3-191">이러한 컨트롤이 없으면 반환 됩니다. 일치 하는 컨트롤이 없으면 `FindControl` 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `null`.</span></span>

<span data-ttu-id="0d7e3-192">`FindControl` 위치 액세스를 제어 해야 하지만에 대 한 직접 참조가 없는 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-192">`FindControl` is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="0d7e3-193">예를 들어 GridView와 같은 웹 컨트롤을 데이터로 작업할 때 GridView의 필드 내에서 컨트롤의 선언적 구문에서 한 번 정의 되지만 런타임 시 컨트롤의 인스턴스가 각 GridView 행에 대해 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="0d7e3-194">결과적으로 런타임에 생성 된 컨트롤 존재 하지만 직접 참조를 코드 숨김 클래스에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="0d7e3-195">결과적으로 사용 해야 `FindControl` GridView의 필드 내에서 특정 컨트롤을 사용 하 여 프로그래밍 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="0d7e3-196">(사용 하 여 대 한 자세한 내용은 `FindControl` 데이터 웹 컨트롤의 템플릿 내에서 컨트롤에 액세스 하려면 참조 [데이터를 기반으로 사용자 지정 서식 지정](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md).) 동적으로 웹 컨트롤에 Web Form을 추가할 때 이와 동일한 시나리오에서 발생, 항목에서 설명한 [동적 데이터 입력 사용자 인터페이스 만들기](https://msdn.microsoft.com/library/aa479330.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="0d7e3-197">에서는 사용 하는 `FindControl` 콘텐츠 페이지 내에서 컨트롤을 검색 하는 방법에 대 한 이벤트 처리기를 만들고는 `SubmitButton`의 `Click` 이벤트.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="0d7e3-198">이벤트 처리기에서 프로그래밍 방식으로 참조 하는 다음 코드를 추가 합니다 `Age` 텍스트 상자에 붙여넣습니다 및 `Results` 레이블을 사용 하 여는 `FindControl` 메서드 다음에 메시지를 표시 하 고 `Results` 사용자의 입력을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="0d7e3-199">물론 우리가 사용할 필요가 없는 `FindControl` 이 예제에 대 한 레이블 및 텍스트 상자 컨트롤을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="0d7e3-200">통해 직접 참조 수 해당 `ID` 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="0d7e3-201">사용 하 여 `FindControl` 를 사용 하는 경우를 보여 주기 위해 여기서 `FindControl` 콘텐츠 페이지 로부터 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample7.cs)]

<span data-ttu-id="0d7e3-202">구문을 호출 하는 데 사용 하는 동안 합니다 `FindControl` 메서드를 처음 두 줄에서 약간 다릅니다. `SubmitButton_Click`, 기능적으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="0d7e3-203">모든 ASP.NET 서버 컨트롤을 포함 하는 재현 율을 `FindControl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="0d7e3-204">여기에 `Page` 클래스는 모든 ASP.NET에서 코드 숨김 클래스에서 파생 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="0d7e3-205">따라서 호출 `FindControl("controlID")` 호출 하는 것과 같습니다 `Page.FindControl("controlID")`를 재정의 하지 않은 것으로 가정 합니다 `FindControl` 코드 숨김 클래스 또는 사용자 지정 기본 클래스 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="0d7e3-206">이 코드를 입력 한 후 참조를 `IDIssues.aspx` 브라우저를 통해 페이지에서 나가를 입력 하 고 "제출" 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="0d7e3-207">"제출" 단추를 클릭 하면는 `NullReferenceException` 발생 (그림 5 참조).</span><span class="sxs-lookup"><span data-stu-id="0d7e3-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>


<span data-ttu-id="0d7e3-208">[![NullReferenceException이 발생](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-208">[![A NullReferenceException is Raised](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span></span>

<span data-ttu-id="0d7e3-209">**그림 05**: A `NullReferenceException` 발생 하는 ([큰 이미지를 보려면 클릭](control-id-naming-in-content-pages-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="0d7e3-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image9.png))</span></span>


<span data-ttu-id="0d7e3-210">중단점을 설정 하는 경우는 `SubmitButton_Click` 이벤트 처리기를 호출 모두 표시 됩니다 `FindControl` 반환을 `null` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return a `null` value.</span></span> <span data-ttu-id="0d7e3-211">`NullReferenceException` 에 액세스 하려고 하는 경우 발생 합니다 `Age` 텍스트 상자의 `Text` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="0d7e3-212">문제는 `Control.FindControl` 만 검색 *제어*의 된 하위 *동일한 명명 컨테이너에서*합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are *in the same naming container*.</span></span> <span data-ttu-id="0d7e3-213">새 명명 컨테이너에 대 한 호출을 구성 하는 마스터 페이지 때문 `Page.FindControl("controlID")` 하지 독립적이 마스터 페이지 개체 `ctl00`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="0d7e3-214">(다시 표시 하는 컨트롤 계층 구조를 보려면 그림 4 참조를 `Page` 마스터 페이지 개체의 부모로 개체 `ctl00`.) 따라서 합니다 `Results` 레이블 및 `Age` 텍스트 상자를 찾을 수 없는 및 `ResultsLabel` 및 `AgeTextBox` 의 값이 할당 됩니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `null`.</span></span>

<span data-ttu-id="0d7e3-215">두 가지 해결 방법이 이러한 과제를: 드릴 다운할 수 있습니다, 하나의 명명 컨테이너 적절 한 컨트롤에 한 번에 직접 만들 수 있습니다 또는 `FindControl` 명명 컨테이너 독립적이 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="0d7e3-216">이러한 각 옵션을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="0d7e3-217">적절 한 명명 컨테이너에 드릴 다운</span><span class="sxs-lookup"><span data-stu-id="0d7e3-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="0d7e3-218">사용 하도록 `FindControl` 참조를 `Results` 레이블 또는 `Age` 텍스트 상자를 호출 해야 `FindControl` 동일한 명명 컨테이너에서 상위 컨트롤에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="0d7e3-219">그림 4와 같이, 합니다 `MainContent` 각각의 ContentPlaceHolder 컨트롤로의 유일한 상위 항목은 `Results` 또는 `Age` 동일한 명명 컨테이너 내에서입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="0d7e3-220">즉, 호출을 `FindControl` 메서드에서 `MainContent` 컨트롤 아래 코드 조각과에서 같이 올바르게 참조를 반환 합니다를 `Results` 또는 `Age` 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample8.cs)]

<span data-ttu-id="0d7e3-221">그러나 것을 사용할 수 없습니다는 `MainContent` ContentPlaceHolder 마스터 페이지는 ContentPlaceHolder 정의 되었기 때문에 위의 구문을 사용 하는 콘텐츠 페이지의 코드 숨김 클래스에서.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="0d7e3-222">대신 사용 해야 `FindControl` 에 대 한 참조를 가져오려면 `MainContent`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="0d7e3-223">코드는 `SubmitButton_Click` 다음과 같이 수정을 사용 하 여 이벤트 처리기:</span><span class="sxs-lookup"><span data-stu-id="0d7e3-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample9.cs)]

<span data-ttu-id="0d7e3-224">브라우저를 통해 페이지를 방문 하는 경우 나가를 입력 하 고 "제출" 단추를 클릭 한 `NullReferenceException` 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="0d7e3-225">에 중단점을 설정 하는 경우는 `SubmitButton_Click` 살펴보면 호출 하려고 할 때이 예외가 발생 하는 이벤트 처리기는 `MainContent` 개체의 `FindControl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="0d7e3-226">합니다 `MainContent` 개체가 `null` 때문에 `FindControl` 메서드 "MainContent" 라는 개체를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-226">The `MainContent` object is `null` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="0d7e3-227">기본 이유는 동일 하 게 합니다 `Results` 레이블 및 `Age` 텍스트 상자 컨트롤: `FindControl` 컨트롤 계층 구조의 위쪽에서 검색을 시작 하 고 명명 컨테이너를 침투 하지 않습니다 하지만 `MainContent` ContentPlaceHolder는 명명 컨테이너인 마스터 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="0d7e3-228">사용 하기 전에 `FindControl` 에 대 한 참조를 가져오려면 `MainContent`, 먼저 마스터 페이지 컨트롤에 대 한 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="0d7e3-229">마스터 페이지에 대 한 참조가 있으면 참조를 가져올 수 있습니다는 `MainContent` 통해 ContentPlaceHolder `FindControl` 여기에서 참조 하 고는 `Results` 레이블 및 `Age` 텍스트 상자에 붙여넣습니다 (사용 하 여 다시 `FindControl`).</span><span class="sxs-lookup"><span data-stu-id="0d7e3-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="0d7e3-230">그러나에서는 어떻게 마스터 페이지에 대 한 참조?</span><span class="sxs-lookup"><span data-stu-id="0d7e3-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="0d7e3-231">검사 하 여 합니다 `id` 렌더링된 된 태그에서 특성 것은 분명 하는 마스터 페이지의 `ID` 값은 `ctl00`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="0d7e3-232">사용할 수 있으므로 `Page.FindControl("ctl00")` 마스터 페이지에 대 한 참조를 가져오려면 다음 사용 하 여 해당 개체에 대 한 참조를 가져오려면 `MainContent`등입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="0d7e3-233">다음 코드 조각에서는이 논리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-233">The following snippet illustrates this logic:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample10.cs)]

<span data-ttu-id="0d7e3-234">이 코드는 확실히 작동 하는 동안 것으로 가정 하는 마스터 페이지의 자동 생성 `ID` 은 항상 `ctl00`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="0d7e3-235">되지 자동 생성 된 값에 대 한 가정 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="0d7e3-236">다행 스럽게도 마스터 페이지에 대 한 참조를 통해 액세스할 수 합니다 `Page` 클래스의 `Master` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="0d7e3-237">사용 하지 않고 대신 따라서 `FindControl("ctl00")` 에 액세스 하기 위해 마스터 페이지의 참조를 가져오려면 합니다 `MainContent` ContentPlaceHolder를 대신 사용 하 여 `Page.Master.FindControl("MainContent")`.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="0d7e3-238">업데이트 된 `SubmitButton_Click` 이벤트 처리기를 다음 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample11.cs)]

<span data-ttu-id="0d7e3-239">이 경우 브라우저를 통해 페이지를 방문 하 나가를 입력 하 고 "제출" 단추를 클릭 하면 메시지를 표시 합니다 `Results` 레이블, 예상 대로입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>


<span data-ttu-id="0d7e3-240">[![사용자의 나이 레이블에 표시 됩니다.](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-240">[![The User's Age is Displayed in the Label](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span></span>

<span data-ttu-id="0d7e3-241">**그림 06**: 사용자의 나이 레이블에 표시 됩니다 ([클릭 하 여 큰 이미지 보기](control-id-naming-in-content-pages-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="0d7e3-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image12.png))</span></span>


### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="0d7e3-242">재귀적으로 명명 컨테이너 검색</span><span class="sxs-lookup"><span data-stu-id="0d7e3-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="0d7e3-243">이유는 이전 코드 예제에서는 참조를 `MainContent` 마스터 페이지에서 각각의 ContentPlaceHolder 컨트롤로 차례로 합니다 `Results` 레이블 및 `Age` TextBox 컨트롤에서 `MainContent`, 이므로 `Control.FindControl` 메서드만 검색 합니다. 내 *제어*의 명명 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="0d7e3-244">것 `FindControl` 명명 된 컨테이너 내에서 계속 적합 한 대부분의 시나리오에서 두 개의 서로 다른 명명 컨테이너에 두 개의 동일한 있을 수 있으므로 `ID` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="0d7e3-245">이라는 레이블 웹 컨트롤을 정의 하는 GridView가 있다고 `ProductName` 해당 TemplateFields 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="0d7e3-246">데이터를 런타임에 GridView에 바인딩될 때는 `ProductName` 각 GridView 행에 대해 레이블이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="0d7e3-247">하는 경우 `FindControl` 모든 명명 검색할 컨테이너를 호출 `Page.FindControl("ProductName")`, 어떤 레이블 인스턴스 해야는 `FindControl` 반환?</span><span class="sxs-lookup"><span data-stu-id="0d7e3-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="0d7e3-248">`ProductName` 첫 번째 GridView 행에서 레이블?</span><span class="sxs-lookup"><span data-stu-id="0d7e3-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="0d7e3-249">마지막 행에 있는 것?</span><span class="sxs-lookup"><span data-stu-id="0d7e3-249">The one in the last row?</span></span>

<span data-ttu-id="0d7e3-250">이 있으면 `Control.FindControl` 만 검색 *제어*의 명명 컨테이너는 대부분의 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="0d7e3-251">고유한 있는 연결, 우리와 같은 다른 경우에도 `ID` 전체 컨테이너 이름 명명 및 신중 하 게 액세스를 제어 하는 컨트롤 계층 구조에서 각 명명 컨테이너를 참조할 필요가 없도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="0d7e3-252">필요는 `FindControl` 너무 모든 명명 컨테이너는 재귀적으로 검색 감지 된 변형입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="0d7e3-253">아쉽게도.NET Framework는 이러한 메서드를 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="0d7e3-254">다행 스럽게도 만들 수 있습니다 고유한 `FindControl` 메서드는 재귀적으로 모든 명명 컨테이너를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="0d7e3-255">실제로 사용 하 여 *확장 메서드* 우리를 넣습니다 수는 `FindControlRecursive` 메서드를 합니다 `Control` 클래스의 기존 함께 `FindControl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="0d7e3-256">확장 메서드는.NET Framework 버전 3.5 및 Visual Studio 2008과 함께 제공 되는 언어는 C# 3.0과 Visual Basic 9에 새 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="0d7e3-257">즉, 특별 한 구문을 통해 기존 클래스 형식에 대 한 새 메서드를 만드는 개발자를 위한 확장 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="0d7e3-258">이 유용한 기능에 대 한 자세한 내용은 필자의 기사를 참조 [확장 메서드를 사용 하 여 기본 형식 기능 확장](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>


<span data-ttu-id="0d7e3-259">확장 메서드를 만들려면 새 파일을 추가 합니다 `App_Code` 라는 폴더 `PageExtensionMethods.cs`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.cs`.</span></span> <span data-ttu-id="0d7e3-260">라는 확장 메서드를 추가 `FindControlRecursive` 입력으로 사용 하는 `string` 라는 매개 변수 `controlID`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-260">Add an extension method named `FindControlRecursive` that takes as an input a `string` parameter named `controlID`.</span></span> <span data-ttu-id="0d7e3-261">제대로 작동 하려면 확장 메서드는 클래스 자체 및 해당 확장 메서드는 표시 되어야 하는 중요 한 `static`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-261">For extension methods to work properly, it is vital that the class itself and its extension methods be marked `static`.</span></span> <span data-ttu-id="0d7e3-262">또한 모든 확장 메서드가 해야 그대로 확장 메서드가 적용 되는 형식의 개체를 첫 번째 매개 변수와이 입력된 매개 변수를 키워드가와 야 합니다 `this`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies, and this input parameter must be preceded with the keyword `this`.</span></span>

<span data-ttu-id="0d7e3-263">다음 코드를 추가 합니다 `PageExtensionMethods.cs` 클래스 파일을이 클래스를 정의 하며 `FindControlRecursive` 확장 메서드:</span><span class="sxs-lookup"><span data-stu-id="0d7e3-263">Add the following code to the `PageExtensionMethods.cs` class file to define this class and the `FindControlRecursive` extension method:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample12.cs)]

<span data-ttu-id="0d7e3-264">이 코드를 반환 합니다 `IDIssues.aspx` 페이지의 코드 숨김 클래스와 현재 주석 `FindControl` 메서드 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="0d7e3-265">에 대 한 호출으로 교체할 `Page.FindControlRecursive("controlID")`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="0d7e3-266">확장 메서드에 대 한 간단한 것 IntelliSense 드롭다운 목록에 내에서 직접 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="0d7e3-267">그림 7에서 알 수 있듯이, 입력 페이지를 다음 기간에 도달 합니다 `FindControlRecursive` 메서드는 드롭다운 다른와 함께 IntelliSense에 포함 되어 `Control` 클래스 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-267">As Figure 7 shows, when you type Page and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>


<span data-ttu-id="0d7e3-268">[![확장 메서드 IntelliSense 드롭다운-목록에 포함 된](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-268">[![Extension Methods are Included in the IntelliSense Drop-Downs](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span></span>

<span data-ttu-id="0d7e3-269">**그림 07**: 확장 메서드가에서 IntelliSense 드롭다운에 포함 됩니다 ([클릭 하 여 큰 이미지 보기](control-id-naming-in-content-pages-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="0d7e3-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image15.png))</span></span>


<span data-ttu-id="0d7e3-270">에 다음 코드를 입력 합니다 `SubmitButton_Click` 이벤트 처리기, 페이지를 방문 하 고, 나가를 입력 하 고, "제출" 단추를 클릭 하 여 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="0d7e3-271">그림 6에 다시 표시 된 것과 같이 결과 출력 메시지 수, "age 살 됩니다."</span><span class="sxs-lookup"><span data-stu-id="0d7e3-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample13.cs)]

> [!NOTE]
> <span data-ttu-id="0d7e3-272">확장 메서드는 Visual Studio 2005를 사용 하는 경우 C# 3.0과 Visual Basic 9에 새 확장 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="0d7e3-273">구현 해야 하는 대신는 `FindControlRecursive` 도우미 클래스에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="0d7e3-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) 그의 블로그 게시물에서는 이러한 예제가 포함 되어 [ASP.NET Maser 페이지 및 `FindControl` ](http://www.west-wind.com/WebLog/posts/5127.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>


## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="0d7e3-275">4단계: 사용 하 여 올바른`id`클라이언트 쪽 스크립트에서 값을 특성</span><span class="sxs-lookup"><span data-stu-id="0d7e3-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="0d7e3-276">웹 컨트롤의 렌더링 된이 자습서의이 소개에서 설명한 대로, `id` 특성은 종종 프로그래밍 방식으로 특정 HTML 요소를 참조 하려면 클라이언트 쪽 스크립트에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="0d7e3-277">다음 JavaScript에서 HTML 요소를 참조 하는 예를 들어, 해당 `id` 다음 모달 메시지 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample14.cs)]

<span data-ttu-id="0d7e3-278">회수 하는 페이지는 ASP.NET는 명명 컨테이너를 렌더링된 된 HTML 요소를 포함 하지 마십시오 `id` 특성이 웹 컨트롤의 동일 `ID` 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="0d7e3-279">이 때문에 하드 코딩 하 고 싶을 것 `id` JavaScript 코드에 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="0d7e3-280">즉, 알고 있는 경우 액세스 하려는 합니다 `Age` 클라이언트 쪽 스크립트를 통해 텍스트 웹 컨트롤에 대 한 호출을 통해 이렇게 `document.getElementById("Age")`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="0d7e3-281">이 방법의 문제는 마스터 페이지 (또는 다른 명명 컨테이너 컨트롤)를 사용 하는 경우 렌더링된 된 HTML `id` 웹 컨트롤에 있는 동의어 아닙니다 `ID` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="0d7e3-282">첫 번째 기울기에 브라우저를 통해 페이지를 방문 하 여 실제 결정할 소스를 볼 수 있습니다 `id` 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="0d7e3-283">렌더링 된 알았으면 `id` 값을 붙여넣을 수 있습니다 것에 대 한 호출 `getElementById` 클라이언트 쪽 스크립트를 통해 사용 해야 하는 HTML 요소에 액세스 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="0d7e3-284">이 방법은 이상적인 이므로 특정 변경 내용 페이지의 컨트롤 계층 구조 또는 변경 합니다 `ID` 명명 컨트롤의 속성 변경 결과 `id` 함으로써 JavaScript 코드의 주요 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="0d7e3-285">다행 스럽게도 하는 `id` 렌더링 되는 특성 값이 웹 컨트롤을 통해 서버 쪽 코드에서 액세스할 수 있는 [ `ClientID` 속성](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span><span class="sxs-lookup"><span data-stu-id="0d7e3-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="0d7e3-286">이 속성을 사용 하 여 확인 해야 하는 `id` 클라이언트 쪽 스크립트에서 사용 되는 값을 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="0d7e3-287">예를 들어 페이지에는 JavaScript 함수를 추가할를 호출 하면 값을 표시 합니다 `Age` 모달 메시지 상자에 텍스트 상자에 다음 코드를 추가 `Page_Load` 이벤트 처리기:</span><span class="sxs-lookup"><span data-stu-id="0d7e3-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>


[!code-javascript[Main](control-id-naming-in-content-pages-cs/samples/sample15.js)]

<span data-ttu-id="0d7e3-288">위 코드의 값을 삽입 합니다 `Age` 라는 JavaScript 호출이를 TextBox의 ClientID 속성 `getElementById`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-288">The above code injects the value of the `Age` TextBox's ClientID property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="0d7e3-289">브라우저를 통해이 페이지를 방문 하 고 HTML 소스를 보고 하는 경우 다음 JavaScript 코드를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample16.html)]

<span data-ttu-id="0d7e3-290">알림 방법을 올바른 `id` 특성 값, `ctl00_MainContent_Age`를 호출 내에 나타납니다 `getElementById`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="0d7e3-291">이 값이 런타임에 계산 되므로 이후 변경 페이지 컨트롤 계층 구조에 관계 없이 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="0d7e3-292">JavaScript 예제에는 단순히 올바르게 서버 컨트롤에서 렌더링 된 HTML 요소를 참조 하는 JavaScript 함수를 추가 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="0d7e3-293">이 함수를 사용 하 여 문서를 로드 하거나 특정 사용자의 일부 동작에서 다소 때 함수를 호출 하는 JavaScript를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="0d7e3-294">이 대 한 자세한 내용은 관련 항목을 읽을 [클라이언트 쪽 스크립트를 사용 하 여 작업](https://msdn.microsoft.com/library/aa479302.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>


## <a name="summary"></a><span data-ttu-id="0d7e3-295">요약</span><span class="sxs-lookup"><span data-stu-id="0d7e3-295">Summary</span></span>

<span data-ttu-id="0d7e3-296">특정 ASP.NET 서버 컨트롤의 역할을 명명 컨테이너는 렌더링 된 영향을 미칩니다 `id` 여 canvassed 컨트롤의 범위와 해당 하위 컨트롤의 값 특성을 `FindControl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="0d7e3-297">마스터 페이지와 관련 하 여 자체 마스터 페이지와 해당 ContentPlaceHolder 컨트롤에 컨테이너 이름 명명 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="0d7e3-298">따라서 프로그래밍 방식으로 사용 하는 콘텐츠 페이지 내에서 컨트롤을 참조 하도록 명시 좀 더 많은 작업을 저장 해야 `FindControl`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="0d7e3-299">이 자습서에서는 두 가지 기술을 살펴보았습니다: ContentPlaceHolder 컨트롤로 드릴링 하 고 호출 해당 `FindControl` ; 메서드와 고유한 롤링 `FindControl` 모든 명명 컨테이너를 통해 구현은 재귀적으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="0d7e3-300">명명 컨테이너 소개 웹 컨트롤 참조와 관련 하 여 서버 쪽 문제, 외에 클라이언트 쪽 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="0d7e3-301">없는 경우 컨테이너 웹 컨트롤의 명명 `ID` 속성 값 및 렌더링 `id` 특성 값은 동일한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="0d7e3-302">하지만 명명 컨테이너에는 렌더링 된 추가 `id` 특성이 모두 포함 합니다 `ID` 웹 컨트롤 및 해당 컨트롤 계층의 상위 구조에서 명명 컨테이너의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="0d7e3-303">이러한 명명 문제는 비-문제를 사용 하는 웹 컨트롤의 `ClientID` 렌더링 된 결정할 속성 `id` 클라이언트 쪽 스크립트에서 값을 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="0d7e3-304">즐거운 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="0d7e3-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="0d7e3-305">추가 정보</span><span class="sxs-lookup"><span data-stu-id="0d7e3-305">Further Reading</span></span>

<span data-ttu-id="0d7e3-306">이 자습서에서 다루는 항목에 대 한 자세한 내용은 다음 리소스를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="0d7e3-307">ASP.NET 마스터 페이지 및 `FindControl`</span><span class="sxs-lookup"><span data-stu-id="0d7e3-307">ASP.NET Master Pages and `FindControl`</span></span>](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="0d7e3-308">동적 데이터 입력 사용자 인터페이스 만들기</span><span class="sxs-lookup"><span data-stu-id="0d7e3-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="0d7e3-309">확장 메서드를 사용 하 여 기본 형식 기능 확장</span><span class="sxs-lookup"><span data-stu-id="0d7e3-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="0d7e3-310">방법: 참조 ASP.NET 마스터 페이지 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="0d7e3-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="0d7e3-311">마스터 페이지: 팁, 요령 및 트랩</span><span class="sxs-lookup"><span data-stu-id="0d7e3-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="0d7e3-312">클라이언트 쪽 스크립트를 사용 하 여 작업</span><span class="sxs-lookup"><span data-stu-id="0d7e3-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="0d7e3-313">저자 소개</span><span class="sxs-lookup"><span data-stu-id="0d7e3-313">About the Author</span></span>

<span data-ttu-id="0d7e3-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 작성자의 여러 ASP/ASP.NET 서적과 4GuysFromRolla.com의 설립자 이며, 왔습니다 Microsoft 웹 기술을 1998 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0d7e3-315">Scott는 독립 컨설턴트, 강사, 그리고 기록기로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0d7e3-316">최근 저서는 [ *Sams 설명 직접 ASP.NET 3.5 24 시간 동안의*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0d7e3-317">Scott에 도달할 수 있습니다 [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com) 통하거나 저자의 블로그 [ http://ScottOnWriting.NET ](http://scottonwriting.net/)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="0d7e3-318">특별히 감사</span><span class="sxs-lookup"><span data-stu-id="0d7e3-318">Special Thanks To</span></span>

<span data-ttu-id="0d7e3-319">이 자습서 시리즈는 많은 유용한 검토자가 검토 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0d7e3-320">이 자습서에 대 한 선행 검토자 Zack Jones와 Suchi Barnerjee 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="0d7e3-321">내 향후 MSDN 문서를 검토에 관심이 있으십니까?</span><span class="sxs-lookup"><span data-stu-id="0d7e3-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0d7e3-322">그렇다면 삭제 나에서 선 [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d7e3-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0d7e3-323">[이전](urls-in-master-pages-cs.md)
> [다음](interacting-with-the-master-page-from-the-content-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="0d7e3-323">[Previous](urls-in-master-pages-cs.md)
[Next](interacting-with-the-master-page-from-the-content-page-cs.md)</span></span>
