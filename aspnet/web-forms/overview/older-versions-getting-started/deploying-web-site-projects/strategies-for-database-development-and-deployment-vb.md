---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-vb
title: 데이터베이스 개발 및 배포 전략 (VB) | Microsoft Docs
author: rick-anderson
description: 처음으로 데이터 기반 응용 프로그램을 배포 하는 경우 개발 환경의 데이터베이스를 프로덕션 환경에 무조건 복사할 수 있습니다. B. ...
ms.author: riande
ms.date: 04/23/2009
ms.assetid: 07b8905d-78ac-4252-97fb-8675b3fb0bbf
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-vb
msc.type: authoredcontent
ms.openlocfilehash: 1ea4ade32fb05b9e69647ece7d1a4c400fe9fb21
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/28/2019
ms.locfileid: "74616119"
---
# <a name="strategies-for-database-development-and-deployment-vb"></a><span data-ttu-id="a4d83-104">데이터베이스 개발 및 배포 전략(VB)</span><span class="sxs-lookup"><span data-stu-id="a4d83-104">Strategies for Database Development and Deployment (VB)</span></span>

<span data-ttu-id="a4d83-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="a4d83-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="a4d83-106">PDF 다운로드</span><span class="sxs-lookup"><span data-stu-id="a4d83-106">Download PDF</span></span>](https://download.microsoft.com/download/C/3/9/C391A649-B357-4A7B-BAA4-48C96871FEA6/aspnet_tutorial10_DBDevel_vb.pdf)

> <span data-ttu-id="a4d83-107">처음으로 데이터 기반 응용 프로그램을 배포 하는 경우 개발 환경의 데이터베이스를 프로덕션 환경에 무조건 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-107">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="a4d83-108">그러나 후속 배포에서 블라인드 복사를 수행 하면 프로덕션 데이터베이스에 입력 된 데이터를 덮어쓰게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-108">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="a4d83-109">대신 데이터베이스를 배포 하는 경우 프로덕션 데이터베이스에 마지막으로 배포 된 이후 개발 데이터베이스의 변경 내용을 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-109">Instead, deploying a database involves applying the changes made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="a4d83-110">이 자습서에서는 이러한 문제를 검토 하 고, 마지막 배포 이후 데이터베이스의 변경 내용을 적용 하 고 chronicling을 지원 하기 위한 다양 한 전략을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-110">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>

## <a name="introduction"></a><span data-ttu-id="a4d83-111">소개</span><span class="sxs-lookup"><span data-stu-id="a4d83-111">Introduction</span></span>

<span data-ttu-id="a4d83-112">이전 자습서에서 설명한 대로 ASP.NET 응용 프로그램을 배포 하는 경우 개발 환경에서 프로덕션 환경으로 관련 콘텐츠를 복사 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-112">As discussed in previous tutorials, deploying an ASP.NET application entails copying the pertinent content from the development environment to the production environment.</span></span> <span data-ttu-id="a4d83-113">배포는 일회성 이벤트가 아니라 새 버전의 소프트웨어가 출시 될 때마다 또는 버그 또는 보안 문제를 식별 하 고 해결 한 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-113">Deployment is not a one-time event, but rather something that happens every time a new version of the software is released or when bugs or security concerns have been identified and addressed.</span></span> <span data-ttu-id="a4d83-114">ASP.NET 페이지, 이미지, JavaScript 파일 및 기타 이러한 파일을 프로덕션 환경에 복사 하는 경우 마지막 배포 이후 이러한 파일이 변경 된 방식에 대해 걱정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-114">When copying ASP.NET pages, images, JavaScript files, and other such files to the production environment you do not need to concern yourself with how these file have been changed since the last deployment.</span></span> <span data-ttu-id="a4d83-115">기존 내용을 덮어써서 프로덕션에 파일을 무조건 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-115">You can blindly copy the file to production, overwriting the existing content.</span></span> <span data-ttu-id="a4d83-116">아쉽게도 이러한 단순성은 데이터베이스 배포로 확장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-116">Unfortunately, this simplicity does not extend to deploying the database.</span></span>

<span data-ttu-id="a4d83-117">처음으로 데이터 기반 응용 프로그램을 배포 하는 경우 개발 환경의 데이터베이스를 프로덕션 환경에 무조건 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-117">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="a4d83-118">그러나 후속 배포에서 블라인드 복사를 수행 하면 프로덕션 데이터베이스에 입력 된 데이터를 덮어쓰게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-118">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="a4d83-119">대신 데이터베이스를 배포 하는 경우 프로덕션 데이터베이스에 마지막으로 배포 된 이후 개발 데이터베이스의 *변경 내용을* 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-119">Instead, deploying a database involves applying the *changes* made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="a4d83-120">이 자습서에서는 이러한 문제를 검토 하 고, 마지막 배포 이후 데이터베이스의 변경 내용을 적용 하 고 chronicling을 지원 하기 위한 다양 한 전략을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-120">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>

## <a name="the-challenges-of-deploying-a-database"></a><span data-ttu-id="a4d83-121">데이터베이스 배포 문제</span><span class="sxs-lookup"><span data-stu-id="a4d83-121">The Challenges of Deploying a Database</span></span>

<span data-ttu-id="a4d83-122">처음으로 데이터 기반 응용 프로그램을 배포 하기 전에는 데이터베이스 (즉, 개발 환경에 데이터베이스)가 하나 뿐입니다. 즉, 데이터 기반 응용 프로그램을 처음 배포 하는 경우에서 데이터베이스를 무조건 복사할 수 있습니다. 프로덕션 환경에 대 한 개발 환경.</span><span class="sxs-lookup"><span data-stu-id="a4d83-122">Before a data-driven application has been deployed for the first time, there is only one database, namely the database in the development environment, which is why when deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="a4d83-123">그러나 응용 프로그램이 배포 되 면 데이터베이스의 복사본 두 개가 있습니다. 즉, 개발 중인 데이터베이스와 프로덕션 환경에 하나씩 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-123">But once the application has been deployed there are two copies of the database: one in development and one in production.</span></span>

<span data-ttu-id="a4d83-124">배포 간 개발 및 프로덕션 데이터베이스는 동기화 되지 않을 수 있습니다. 프로덕션 데이터베이스 스키마가 변경 되지 않은 상태로 유지 되는 동안에는 새로운 기능이 추가 되 면 개발 데이터베이스의 스키마가 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-124">Between deployments the development and production databases can become out of sync. While the production database s schema remains unchanged, the development database s schema may change as new features are added.</span></span> <span data-ttu-id="a4d83-125">열, 테이블, 뷰 또는 저장 프로시저를 추가 하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-125">You might add or remove columns, tables, views, or stored procedures.</span></span> <span data-ttu-id="a4d83-126">또한 개발 데이터베이스에 추가 되는 중요 한 데이터가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-126">There may also be important data that gets added to the development database.</span></span> <span data-ttu-id="a4d83-127">많은 데이터 기반 응용 프로그램에는 사용자가 편집할 수 없는 하드 코딩 된 응용 프로그램 관련 데이터로 채워진 조회 테이블이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-127">Many data-driven applications include lookup tables populated with hard-coded, application-specific data that are not user-editable.</span></span> <span data-ttu-id="a4d83-128">예를 들어, 경매 웹 사이트에는 auctioned 되는 항목의 조건을 설명 하는 선택 항목이 포함 된 드롭다운 목록이 있을 수 있습니다. 새로 만들기, 양호, 공평 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-128">For example, an auction website might have a drop-down list with choices that describe the condition of the item being auctioned: New, Like New, Good, and Fair.</span></span> <span data-ttu-id="a4d83-129">이러한 옵션은 드롭다운 목록에서 직접 하드 코딩 하는 대신 데이터베이스 테이블에 저장 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-129">Rather than hard-coding these options directly in the drop-down list it is usually better to place them in a database table.</span></span> <span data-ttu-id="a4d83-130">개발 하는 동안 테이블에 불량 이라는 새 조건이 추가 되 면 응용 프로그램을 배포할 때이 레코드를 프로덕션 데이터베이스의 조회 테이블에 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-130">If, during development, a new condition named Poor is added to the table then when deploying the application this same record needs to be added to the lookup table in the production database.</span></span>

<span data-ttu-id="a4d83-131">데이터베이스를 배포 하는 경우 데이터베이스를 개발 환경에서 프로덕션으로 복사 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-131">Ideally, deploying the database would involve copying the database from development to production.</span></span> <span data-ttu-id="a4d83-132">그러나 응용 프로그램을 배포 하 고 개발을 다시 시작한 후 프로덕션 데이터베이스는 실제 사용자의 실제 데이터로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-132">But keep in mind that after you have deployed the application and resumed development, the production database is being populated with real data from real users.</span></span> <span data-ttu-id="a4d83-133">따라서 다음 배포 시 개발 환경에서 프로덕션 환경으로 데이터베이스를 복사 하는 경우 프로덕션 데이터베이스를 덮어쓰고 기존 데이터를 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-133">Therefore, if you were to simply copy the database from development to production at the next deployment you would overwrite the production database and lose its existing data.</span></span> <span data-ttu-id="a4d83-134">결과적으로 데이터베이스를 배포 하면 마지막 배포 이후 개발 데이터베이스의 변경 내용을 적용 하는 구축 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-134">The net result is that deploying the database boils down to applying the changes made to the development database since the last deployment.</span></span>

<span data-ttu-id="a4d83-135">데이터베이스를 배포 하려면 스키마의 변경 내용을 적용 하는 것이 포함 되 고, 마지막 배포 이후 데이터의 경우에는 변경 기록을 유지 해야 합니다 .이 경우에는 해당 변경 내용이 프로덕션에 적용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-135">Because deploying a database involves applying the changes in the schema and, possibly, the data since the last deployment, a history of changes must be maintained (or determined at deploy-time) so that those changes can be applied on production.</span></span> <span data-ttu-id="a4d83-136">데이터 모델에 대 한 변경 내용을 관리 및 적용 하는 다양 한 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-136">There are a variety of techniques for managing and applying changes to the data model.</span></span>

### <a name="defining-the-baseline"></a><span data-ttu-id="a4d83-137">기준선 정의</span><span class="sxs-lookup"><span data-stu-id="a4d83-137">Defining the Baseline</span></span>

<span data-ttu-id="a4d83-138">응용 프로그램 데이터베이스에 대 한 변경 내용을 유지 하려면 변경 내용이 적용 되는 기준이 되는 시작 상태가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-138">To maintain the changes to your application s database you need to have some starting state, a baseline to which the changes are applied to.</span></span> <span data-ttu-id="a4d83-139">한 가지 극단적인 경우 시작 상태는 테이블, 뷰 또는 저장 프로시저가 없는 빈 데이터베이스가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-139">At one extreme the starting state could be an empty database with no tables, views, or stored procedures.</span></span> <span data-ttu-id="a4d83-140">이러한 기준은 모든 데이터베이스 테이블, 뷰 및 저장 프로시저의 생성을 초기 배포 후에 수행 된 변경 내용과 함께 포함 해야 하므로 변경 로그가 크게 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-140">Such a baseline results in a large change log because it must include the creation of all of the database s tables, views, and stored procedures along with any changes made after the initial deployment.</span></span> <span data-ttu-id="a4d83-141">스펙트럼의 다른 쪽 끝에 초기 계획을 프로덕션 환경에 배포 되는 데이터베이스 버전으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-141">At the other end of the spectrum you could set the baseline as the version of the database that is initially deployed to the production environment.</span></span> <span data-ttu-id="a4d83-142">이 옵션을 선택 하면 첫 번째 배포 후에 데이터베이스에 적용 된 변경 내용만 포함 되므로 훨씬 더 작은 변경 로그가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-142">This choice results in a much smaller change log because it only includes the changes made to the database following the first deployment.</span></span> <span data-ttu-id="a4d83-143">이것이 선호 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-143">This is the approach I prefer.</span></span> <span data-ttu-id="a4d83-144">물론, 데이터베이스를 처음 만들 때와 데이터베이스를 처음 배포할 때의 시점으로 기준선을 정의 하 여 더 높은 로드맵 방법을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-144">And of course you can choose a more middle of the road approach, defining the baseline as some point between the initial creation of the database and when the database is first deployed.</span></span>

<span data-ttu-id="a4d83-145">기준을 선택한 후에는 기준선 버전을 다시 만들기 위해 실행할 수 있는 SQL 스크립트를 생성 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-145">Once you have chosen a baseline consider generating a SQL script that can be executed to recreate the baseline version.</span></span> <span data-ttu-id="a4d83-146">이러한 스크립트를 사용 하면 데이터베이스의 기준선 버전을 신속 하 게 다시 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-146">Such a script makes it possible to quickly recreate the baseline version of the database.</span></span> <span data-ttu-id="a4d83-147">이 기능은 대규모 프로젝트에서 특히 유용 합니다 .이 경우 프로젝트에서 작업 하는 여러 개발자 또는 테스트 또는 스테이징 등의 추가 환경에서 각각 고유한 데이터베이스 복사본을 필요로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-147">This functionality is especially useful in larger projects, where there may be multiple developers working on the project or additional environments, such as testing or staging, that each need their own copy of the database.</span></span>

<span data-ttu-id="a4d83-148">기준 버전의 SQL 스크립트를 생성 하는 데는 다양 한 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-148">There are a variety of tools at your disposal to generate a SQL script of the baseline version.</span></span> <span data-ttu-id="a4d83-149">SSMS (SQL Server Management Studio)에서 데이터베이스를 마우스 오른쪽 단추로 클릭 하 고 작업 하위 메뉴로 이동 하 여 스크립트 생성 옵션을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-149">From SQL Server Management Studio (SSMS) you can right-click on the database, go to the Tasks submenu, and choose the Generate Scripts option.</span></span> <span data-ttu-id="a4d83-150">그러면 데이터베이스의 개체를 만드는 SQL 명령이 포함 된 파일을 생성 하도록 지시할 수 있는 스크립트 마법사가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-150">This launches the Script Wizard, which you can instruct to generate a file that contains the SQL commands to create your database s objects.</span></span> <span data-ttu-id="a4d83-151">또 다른 옵션은 데이터베이스 게시 마법사입니다 .이 마법사는 데이터베이스 스키마 뿐만 아니라 데이터베이스 테이블의 데이터를 만들 뿐 아니라 SQL 명령을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-151">Another option is the Database Publishing Wizard, which can generate the SQL commands to not only create the database schema, but also the data in the database tables.</span></span> <span data-ttu-id="a4d83-152">데이터베이스 게시 마법사는 *데이터베이스 배포* 자습서에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-152">The Database Publishing Wizard was examined in detail back in the *Deploying a Database* tutorial.</span></span> <span data-ttu-id="a4d83-153">사용 하는 도구에 관계 없이, 필요한 경우 데이터베이스의 기준선 버전을 다시 만드는 데 사용할 수 있는 스크립트 파일을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-153">Regardless of what tool you use, in the end you should have a script file that you can use to recreate the baseline version of your database, should the need arise.</span></span>

## <a name="documenting-the-database-changes-in-prose"></a><span data-ttu-id="a4d83-154">Prose의 데이터베이스 변경 내용 문서화</span><span class="sxs-lookup"><span data-stu-id="a4d83-154">Documenting the Database Changes in Prose</span></span>

<span data-ttu-id="a4d83-155">개발 단계에서 데이터 모델에 대 한 변경 로그를 유지 관리 하는 가장 간단한 방법은 prose의 변경 내용을 기록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-155">The simplest way to maintain a log of changes to the data model during the development phase is to record the changes in prose.</span></span> <span data-ttu-id="a4d83-156">예를 들어 이미 배포 된 응용 프로그램을 개발 하는 동안 `Employees` 테이블에 새 열을 추가 하 고, `Orders` 테이블에서 열을 제거 하 고, 새 테이블 (`ProductCategories`)을 추가 하면 다음 기록이 포함 된 텍스트 파일이 나 Microsoft Word 문서를 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-156">For example, if during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`), you would maintain a text file or Microsoft Word document with the following history:</span></span>

<a id="0.8_table01"></a>

| <span data-ttu-id="a4d83-157">**날짜 변경**</span><span class="sxs-lookup"><span data-stu-id="a4d83-157">**Change Date**</span></span> | <span data-ttu-id="a4d83-158">**세부 정보 변경**</span><span class="sxs-lookup"><span data-stu-id="a4d83-158">**Change Details**</span></span> |
| --- | --- |
| <span data-ttu-id="a4d83-159">2009-02-03:</span><span class="sxs-lookup"><span data-stu-id="a4d83-159">2009-02-03:</span></span> | <span data-ttu-id="a4d83-160">`Employees` 테이블에 열 `DepartmentID``int`(NULL이 아님)을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-160">Added column `DepartmentID` (`int`, NOT NULL) to the `Employees` table.</span></span> <span data-ttu-id="a4d83-161">`Departments.DepartmentID`에서 `Employees.DepartmentID`에 foreign key 제약 조건을 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-161">Added a foreign key constraint from `Departments.DepartmentID` to `Employees.DepartmentID`.</span></span> |
| <span data-ttu-id="a4d83-162">2009-02-05:</span><span class="sxs-lookup"><span data-stu-id="a4d83-162">2009-02-05:</span></span> | <span data-ttu-id="a4d83-163">`Orders` 테이블에서 열 `TotalWeight` 제거 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-163">Removed column `TotalWeight` from the `Orders` table.</span></span> <span data-ttu-id="a4d83-164">연결 된 `OrderDetails` 레코드에 이미 캡처된 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-164">Data already captured in associated `OrderDetails` records.</span></span> |
| <span data-ttu-id="a4d83-165">2009-02-12:</span><span class="sxs-lookup"><span data-stu-id="a4d83-165">2009-02-12:</span></span> | <span data-ttu-id="a4d83-166">`ProductCategories` 테이블을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-166">Created the `ProductCategories` table.</span></span> <span data-ttu-id="a4d83-167">열에는 `ProductCategoryID` (`int`, `IDENTITY`, `NOT NULL`), `CategoryName` (`nvarchar(50)`, `NOT NULL`) 및 `Active` (`bit`, `NOT NULL`)의 세 가지 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-167">There are three columns: `ProductCategoryID` (`int`, `IDENTITY`, `NOT NULL`), `CategoryName` (`nvarchar(50)`, `NOT NULL`), and `Active` (`bit`, `NOT NULL`).</span></span> <span data-ttu-id="a4d83-168">`ProductCategoryID`에 기본 키 제약 조건을 추가 하 고 기본값 1을 `Active`에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-168">Added a primary key constraint to `ProductCategoryID`, and a default value of 1 to `Active`.</span></span> |

<span data-ttu-id="a4d83-169">이 접근 방식에는 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-169">There are a number of drawbacks to this approach.</span></span> <span data-ttu-id="a4d83-170">처음에는 자동화가 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-170">For starters, there is no hope for automation.</span></span> <span data-ttu-id="a4d83-171">이러한 변경 내용을 데이터베이스에 적용 해야 할 때 (예: 응용 프로그램이 배포 된 경우) 개발자가 각 변경 내용을 한 번에 하나씩 수동으로 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-171">Anytime these changes need to be applied to a database - such as when the application is deployed - a developer must manually implement each change, one at a time.</span></span> <span data-ttu-id="a4d83-172">또한 변경 로그를 사용 하 여 기준에서 특정 버전의 데이터베이스를 다시 생성 해야 하는 경우 로그 크기가 증가 함에 따라 더 많은 시간이 소요 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-172">Moreover, if you need to reconstruct a particular version of the database from the baseline using the change log, doing so will take more and more time as the size of the log grows.</span></span> <span data-ttu-id="a4d83-173">이 방법의 또 다른 단점은 각 변경 로그 항목에 대 한 세부 정보 및 수준을 변경 내용을 기록 하는 사람에 게 유지 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-173">Another drawback to this method is that the clarity and level of detail of each change log entry is left to the person recording the change.</span></span> <span data-ttu-id="a4d83-174">여러 개발자가 있는 팀에서 일부는 다른 항목 보다 더 자세 하 고 더 읽기 쉽고 더 정확한 항목을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-174">In a team with multiple developers some may make more detailed, more readable, or more precise entries than others.</span></span> <span data-ttu-id="a4d83-175">또한 오타 및 기타 사용자 관련 데이터 입력 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-175">Also, typos and other human-related data entry errors are possible.</span></span>

<span data-ttu-id="a4d83-176">Prose의 데이터베이스 변경 내용을 문서화 하는 주요 장점은 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-176">The primary benefit of documenting the database changes in prose is simplicity.</span></span> <span data-ttu-id="a4d83-177">데이터베이스 개체를 만들고 변경 하기 위한 SQL 구문에 대해 잘 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-177">You don t need familiarity with the SQL syntax for creating and altering database objects.</span></span> <span data-ttu-id="a4d83-178">대신 prose의 변경 내용을 기록 하 고 SQL Server Management Studio s 그래픽 사용자 인터페이스를 통해 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-178">Instead, you can record the changes in prose and implement them through SQL Server Management Studio s graphical user interface.</span></span>

<span data-ttu-id="a4d83-179">Prose에서 변경 로그를 유지 관리 하는 것은 매우 정교 하지 않으며, 범위 내에 있는 것과 같은 특정 프로젝트에서 제대로 작동 하지 않으며, 데이터 모델을 자주 변경 하거나, 여러 개발자를 포함 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-179">Maintaining your change log in prose is, admittedly, not very sophisticated and won't work well with certain projects, such as ones that are large in scope, have frequent changes to the data model, or involve multiple developers.</span></span> <span data-ttu-id="a4d83-180">그러나이 접근 방식은 데이터 모델을 가끔 변경 하 고, 솔로 개발자가 데이터베이스 개체를 만들고 변경 하기 위한 SQL 구문에서 강력한 배경을 갖지 않는 작은 남자 프로젝트에서 매우 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-180">But I have seen this approach work quite well in small, one-man projects that have only occasional changes to the data model and where the solo developer does not have a strong background in the SQL syntax for creating and altering database objects.</span></span>

> [!NOTE]
> <span data-ttu-id="a4d83-181">변경 로그의 정보는 기술적으로 배포 시간 까지만 필요 하지만 변경 기록을 유지 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-181">While the information in the change log is, technically, only needed until deploy-time, I recommend keeping a history of changes.</span></span> <span data-ttu-id="a4d83-182">하지만 증가 하는 단일 변경 로그 파일을 유지 관리 하는 대신 각 데이터베이스 버전에 대해 다른 변경 로그 파일을 유지 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-182">But rather than maintaining a single, ever growing change log file, consider having a different change log file for each database version.</span></span> <span data-ttu-id="a4d83-183">일반적으로 배포할 때마다 데이터베이스의 버전을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-183">Typically you will want to version the database each time it is deployed.</span></span> <span data-ttu-id="a4d83-184">기본에서 시작 하 여 변경 로그 로그를 유지 관리 함으로써 버전 1부터 변경 로그 스크립트를 실행 하 고 다시 만들어야 하는 버전에 도달할 때까지 계속 하 여 데이터베이스 버전을 다시 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-184">By maintaining a log of change logs you can, starting from the baseline, recreate any database version by executing the change log scripts starting from version 1 and continuing until you reach the version you need to recreate.</span></span>

## <a name="recording-the-sql-change-statements"></a><span data-ttu-id="a4d83-185">SQL 변경 문 기록</span><span class="sxs-lookup"><span data-stu-id="a4d83-185">Recording the SQL Change Statements</span></span>

<span data-ttu-id="a4d83-186">Prose에서 변경 로그를 유지 관리 하는 경우의 주요 단점은 자동화가 없다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-186">The primary drawback of maintaining the change log in prose is the lack of automation.</span></span> <span data-ttu-id="a4d83-187">이상적으로 배포 시 프로덕션 데이터베이스에 데이터베이스 변경 내용을 구현 하는 것은 명령 목록을 수동으로 수행 하는 대신 단추를 클릭 하 여 스크립트를 실행 하는 것 만큼 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-187">Ideally, implementing the database changes to the production database at deploy-time would be as easy as clicking a button to execute a script rather than having to manually perform a list of instructions.</span></span> <span data-ttu-id="a4d83-188">이러한 자동화는 데이터 모델을 변경 하는 데 사용 되는 SQL 명령이 포함 된 변경 로그를 유지 관리 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-188">Such automation is possible by maintaining a change log that contains those SQL commands used to alter the data model.</span></span>

<span data-ttu-id="a4d83-189">SQL 구문에는 다양 한 데이터베이스 개체를 만들고 수정 하기 위한 여러 문이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-189">The SQL syntax includes a number of statements for creating and modifying various database objects.</span></span> <span data-ttu-id="a4d83-190">예를 들어 [*CREATE TABLE 문이*](https://msdn.microsoft.com/library/ms174979.aspx)실행 되 면 지정 된 열과 제약 조건을 사용 하 여 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-190">For example, the [*CREATE TABLE statement*](https://msdn.microsoft.com/library/ms174979.aspx), when executed, creates a new table with the specified columns and constraints.</span></span> <span data-ttu-id="a4d83-191">[*ALTER TABLE 문은*](https://msdn.microsoft.com/library/ms190273.aspx) 기존 테이블을 수정 하거나 열 또는 제약 조건을 추가, 제거 또는 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-191">The [*ALTER TABLE statement*](https://msdn.microsoft.com/library/ms190273.aspx) modifies an existing table, adding, removing, or modifying its columns or constraints.</span></span> <span data-ttu-id="a4d83-192">인덱스, 뷰, 사용자 정의 함수, 저장 프로시저, 트리거 및 기타 데이터베이스 개체를 만들고 수정 하 고 삭제 하는 문도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-192">There are also statements to create, modify, and drop indexes, views, user-defined functions, stored procedures, triggers, and other database objects.</span></span>

<span data-ttu-id="a4d83-193">이전 예제로 돌아가서 이미 배포 된 응용 프로그램을 개발 하는 동안 `Employees` 테이블에 새 열을 추가 하 고 `Orders` 테이블에서 열을 제거 하 고 새 테이블 (`ProductCategories`)을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-193">Returning to our earlier example, image that during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`).</span></span> <span data-ttu-id="a4d83-194">이러한 작업을 수행 하면 다음 SQL 명령을 사용 하 여 변경 로그 파일이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-194">Such actions would result in a change log file with the following SQL commands:</span></span>

[!code-sql[Main](strategies-for-database-development-and-deployment-vb/samples/sample1.sql)]

<span data-ttu-id="a4d83-195">배포 시간에 이러한 변경 내용을 프로덕션 데이터베이스에 푸시하는 작업은 한 번 클릭 작업입니다. SQL Server Management Studio을 열고, 프로덕션 데이터베이스에 연결 하 고, 새 쿼리 창을 열고, 변경 로그의 내용을 붙여넣고, 실행을 클릭 하 여 스크립트를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-195">Pushing these changes to the production database at deploy-time is a one-click operation: open SQL Server Management Studio, connect to your production database, open a New Query window, paste the contents of the change log, and click Execute to run the script.</span></span>

## <a name="using-a-comparison-tool-to-synchronize-the-data-models"></a><span data-ttu-id="a4d83-196">비교 도구를 사용 하 여 데이터 모델 동기화</span><span class="sxs-lookup"><span data-stu-id="a4d83-196">Using a Comparison Tool to Synchronize the Data Models</span></span>

<span data-ttu-id="a4d83-197">Prose에서 데이터베이스 변경 내용을 문서화 하는 것은 쉽지만 변경 내용을 구현 하려면 개발자가 프로덕션 데이터베이스에서 한 번에 하나씩 변경 해야 합니다. SQL 변경 명령을 문서화 하면 단추를 클릭 하는 것 처럼 간단 하 고 빠르게 프로덕션 데이터베이스에서 변경 내용을 구현할 수 있지만, 데이터베이스 개체를 만들고 변경 하기 위한 SQL 문과 구문을 학습 하 고 마스터링 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-197">Documenting database changes in prose is easy, but implementing the changes requires a developer to make each change on the production database one at a time; documenting the change SQL commands makes implementing those changes on the production database as easy and quick as clicking a button, but requires learning and mastering the SQL statements and syntax for creating and altering database objects.</span></span> <span data-ttu-id="a4d83-198">데이터베이스 비교 도구는 두 가지 방법 모두에서 가장 잘 사용 되며 최악의 경우를 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-198">Database comparison tools take the best from both approaches and discard the worst.</span></span>

<span data-ttu-id="a4d83-199">데이터베이스 비교 도구는 두 데이터베이스의 스키마 또는 데이터를 비교 하 고 데이터베이스의 차이점을 보여 주는 요약 보고서를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-199">A database comparison tool compares the schema or data of two databases and displays a summary report showing you how the databases differ.</span></span> <span data-ttu-id="a4d83-200">그런 다음 단추를 클릭 하 여 하나 이상의 데이터베이스 개체를 동기화 하는 SQL 명령을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-200">Then, with the click of a button, you can generate the SQL commands for synchronizing one or more database objects.</span></span> <span data-ttu-id="a4d83-201">간단히 말해서, 데이터베이스 비교 도구를 사용 하 여 배포 시 개발 및 프로덕션 데이터베이스를 비교할 수 있습니다 .이 경우 실행 시 프로덕션 데이터베이스의 스키마에 변경 내용을 적용 하는 SQL 명령이 포함 된 파일이 생성 됩니다. 개발 데이터베이스의 스키마를 미러링합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-201">In a nutshell, you can use a database comparison tool to compare the development and production databases at deploy-time, generating a file that contains the SQL commands that, when executed, will apply the changes to the production database s schema so that it mirrors the development database s schema.</span></span>

<span data-ttu-id="a4d83-202">다양 한 공급 업체에서 제공 하는 다양 한 타사 데이터베이스 비교 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-202">There are a variety of third-party database comparison tools offered by many different vendors.</span></span> <span data-ttu-id="a4d83-203">이러한 예 중 하나는 [*Red Gate 소프트웨어로*](http://www.red-gate.com/) [*SQL 비교*](http://www.red-gate.com/products/SQL_Compare/)입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-203">One such example is [*SQL Compare*](http://www.red-gate.com/products/SQL_Compare/), by [*Red Gate Software*](http://www.red-gate.com/).</span></span> <span data-ttu-id="a4d83-204">에서 SQL 비교를 사용 하 여 개발 및 프로덕션 데이터베이스 스키마를 비교 하 고 동기화 하는 과정을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-204">Let s walk through the process of using SQL Compare to compare and synchronize the development and production databases schemas.</span></span>

> [!NOTE]
> <span data-ttu-id="a4d83-205">이 문서를 작성할 당시에는 최신 버전의 SQL 비교를 버전 7.1로, Standard Edition 비용 $395을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-205">At the time of this writing the current version of SQL Compare was version 7.1, with the Standard Edition costing $395.</span></span> <span data-ttu-id="a4d83-206">14 일 무료 평가판을 다운로드 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-206">You can follow along by downloading a free 14-day trial.</span></span>

<span data-ttu-id="a4d83-207">SQL 비교를 시작 하면 저장 된 SQL 비교 프로젝트가 표시 되는 비교 프로젝트 대화 상자가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-207">When SQL Compare starts the Comparison Projects dialog box opens, showing the saved SQL Compare projects.</span></span> <span data-ttu-id="a4d83-208">새 프로젝트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-208">Create a new project.</span></span> <span data-ttu-id="a4d83-209">그러면 비교할 데이터베이스에 대 한 정보를 묻는 프로젝트 구성 마법사가 시작 됩니다 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="a4d83-209">This launches the Project Configuration wizard, which prompts for information about the databases to compare (see Figure 1).</span></span> <span data-ttu-id="a4d83-210">개발 및 프로덕션 환경 데이터베이스에 대 한 정보를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-210">Enter the information for the development and production environment databases.</span></span>

<span data-ttu-id="a4d83-211">[개발 및 프로덕션 데이터베이스 비교 ![](strategies-for-database-development-and-deployment-vb/_static/image2.jpg)](strategies-for-database-development-and-deployment-vb/_static/image1.jpg)</span><span class="sxs-lookup"><span data-stu-id="a4d83-211">[![Compare the Development and Production Databases](strategies-for-database-development-and-deployment-vb/_static/image2.jpg)](strategies-for-database-development-and-deployment-vb/_static/image1.jpg)</span></span>

<span data-ttu-id="a4d83-212">**그림 1**: 개발 및 프로덕션 데이터베이스 비교 ([전체 크기 이미지를 보려면 클릭](strategies-for-database-development-and-deployment-vb/_static/image3.jpg))</span><span class="sxs-lookup"><span data-stu-id="a4d83-212">**Figure 1**: Compare the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-vb/_static/image3.jpg))</span></span>

> [!NOTE]
> <span data-ttu-id="a4d83-213">개발 환경 데이터베이스가 웹 사이트의 `App_Data` 폴더에 있는 SQL Express Edition 데이터베이스 파일이 면 그림 1에 표시 된 대화 상자에서 선택 하기 위해 데이터베이스를 SQL Server Express 데이터베이스 서버에 등록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-213">If your development environment database is a SQL Express Edition database file in the `App_Data` folder of your website you will need to register the database in the SQL Server Express database server in order to select it from the dialog box shown in Figure 1.</span></span> <span data-ttu-id="a4d83-214">이를 수행 하는 가장 쉬운 방법은 SSMS (SQL Server Management Studio)를 열고 SQL Server Express 데이터베이스 서버에 연결한 후 데이터베이스를 연결 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-214">The easiest way to accomplish this is to open SQL Server Management Studio (SSMS), connect to the SQL Server Express database server, and attach the database.</span></span> <span data-ttu-id="a4d83-215">컴퓨터에 SSMS가 설치 되어 있지 않은 경우 무료 [*SQL Server 2008 Management Studio Basic 버전*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en)을 다운로드 하 여 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-215">If you do not have SSMS installed on your computer you can download and install the free [*SQL Server 2008 Management Studio Basic version*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en).</span></span>

<span data-ttu-id="a4d83-216">비교할 데이터베이스를 선택 하는 것 외에도 옵션 탭에서 다양 한 비교 설정을 지정할 수 있습니다. 설정할 수 있는 한 가지 옵션은 "제약 조건 및 인덱스 이름 무시"입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-216">In addition to selecting the databases to compare, you can also specify a variety of comparison settings from the Options tab. One option you may want to turn on is the "Ignore constraint and index names."</span></span> <span data-ttu-id="a4d83-217">이전 자습서에서는 응용 프로그램 서비스 데이터베이스 개체를 개발 및 프로덕션 데이터베이스에 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-217">Recall that in the preceding tutorial we added the application services database objects to the development and production databases.</span></span> <span data-ttu-id="a4d83-218">`aspnet_regsql.exe` 도구를 사용 하 여 프로덕션 데이터베이스에 이러한 개체를 만든 경우 개발 데이터베이스와 프로덕션 데이터베이스 간에 기본 키 및 unique 제약 조건 이름이 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-218">If you used the `aspnet_regsql.exe` tool to create these objects on the production database then you will find that the primary key and unique constraint names differ between the development and production databases.</span></span> <span data-ttu-id="a4d83-219">따라서 SQL 비교는 모든 응용 프로그램 서비스 테이블에 다른 것으로 플래그를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-219">Consequently, SQL Compare will flag all of the application services tables as differing.</span></span> <span data-ttu-id="a4d83-220">"제약 조건 및 인덱스 이름 무시"를 선택 취소 하 고 제약 조건 이름을 동기화 하거나 SQL 비교에 이러한 차이를 무시 하도록 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-220">You can either leave the "Ignore constraint and index names" unchecked and synchronize the constraint names, or instruct SQL Compare to ignore these differences.</span></span>

<span data-ttu-id="a4d83-221">비교할 데이터베이스를 선택 하 고 비교 옵션을 검토 한 후에 지금 비교 단추를 클릭 하 여 비교를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-221">After selecting the databases to compare (and reviewing the comparison options), click the Compare Now button to begin the comparison.</span></span> <span data-ttu-id="a4d83-222">다음 몇 초 동안 SQL 비교는 두 데이터베이스의 스키마를 검사 하 고 어떻게 다른 지에 대 한 보고서를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-222">Over the next several seconds, SQL Compare examines the schemas of the two databases and generates a report of how they differ.</span></span> <span data-ttu-id="a4d83-223">이러한 불일치를 SQL 비교 인터페이스에 표시 하는 방법을 보여 주기 위해 개발 데이터베이스를 의도적으로 수정 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-223">I ve purposefully made some modifications to the development database to show how such discrepancies are noted in the SQL Compare interface.</span></span> <span data-ttu-id="a4d83-224">그림 2에 나와 있는 것 처럼, `Authors` 테이블에 `BirthDate` 열을 추가 하 고, `Books` 테이블에서 `ISBN` 열을 제거 하 고, 사용자가 검토 된 책의 사이트 요금을 방문할 수 있도록 하는 새 테이블 `Ratings`를 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-224">As Figure 2 shows, I ve added a `BirthDate` column to the `Authors` table, removed the `ISBN` column from the `Books` table, and added a new table, `Ratings`, which is meant to let users visiting the site rate the reviewed books.</span></span>

> [!NOTE]
> <span data-ttu-id="a4d83-225">이 자습서에서 변경한 데이터 모델은 데이터베이스 비교 도구를 사용 하 여 설명 하기 위해 수행 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-225">The data model changes made in this tutorial were done to illustrate using a database comparison tool.</span></span> <span data-ttu-id="a4d83-226">이후 자습서에서는 데이터베이스에서 이러한 변경 내용을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-226">You will not find these changes in the database in future tutorials.</span></span>

<span data-ttu-id="a4d83-227">[![SQL 비교는 개발 데이터베이스와 프로덕션 데이터베이스 간의 차이점을 나열 합니다.](strategies-for-database-development-and-deployment-vb/_static/image5.jpg)](strategies-for-database-development-and-deployment-vb/_static/image4.jpg)</span><span class="sxs-lookup"><span data-stu-id="a4d83-227">[![SQL Compare Lists the Differences Between the Development and Production Databases](strategies-for-database-development-and-deployment-vb/_static/image5.jpg)](strategies-for-database-development-and-deployment-vb/_static/image4.jpg)</span></span>

<span data-ttu-id="a4d83-228">**그림 2**: SQL 비교에는 개발 데이터베이스와 프로덕션 데이터베이스의 차이점이 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](strategies-for-database-development-and-deployment-vb/_static/image6.jpg)).</span><span class="sxs-lookup"><span data-stu-id="a4d83-228">**Figure 2**: SQL Compare Lists the Differences Between the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-vb/_static/image6.jpg))</span></span>

<span data-ttu-id="a4d83-229">SQL 비교는 데이터베이스 개체를 그룹으로 분할 하 여 두 데이터베이스에 있는 개체를 신속 하 게 표시 하 고 다른 데이터베이스에는 존재 하는 개체를 신속 하 게 표시 하는 것과 동일한 개체를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-229">SQL Compare breaks down the database objects into groups, quickly showing you what objects exist in both databases but are different, which objects exist in one database but not the other, and which objects are identical.</span></span> <span data-ttu-id="a4d83-230">여기에서 볼 수 있듯이 두 데이터베이스에 모두 존재 하지만 다른 두 개의 개체가 있습니다. 열이 추가 된 `Authors` 테이블과 `Books` 테이블이 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-230">As you can see, there are two objects that exist in both databases but are different: the `Authors` table, which had a column added, and the `Books` table, which had one removed.</span></span> <span data-ttu-id="a4d83-231">개발 데이터베이스에만 존재 하는 하나의 개체, 즉 새로 만든 `Ratings` 테이블만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-231">There is one object that exists only in the development database, namely the newly created `Ratings` table.</span></span> <span data-ttu-id="a4d83-232">두 데이터베이스에서 동일 하 게 117 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-232">And there are 117 objects that are identical in both databases.</span></span>

<span data-ttu-id="a4d83-233">데이터베이스 개체를 선택 하면 이러한 개체의 차이점을 보여 주는 SQL 차이점 창이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-233">Selecting a database object displays the SQL Differences window, which shows how these objects differ.</span></span> <span data-ttu-id="a4d83-234">그림 2의 아래쪽에 표시 된 SQL 차이점 창에는 개발 데이터베이스의 `Authors` 테이블에 `BirthDate` 열이 있으며이 열은 프로덕션 데이터베이스의 `Authors` 테이블에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-234">The SQL Differences window, displayed at the bottom in Figure 2, highlights that the `Authors` table in the development database has the `BirthDate` column, which is not found in the `Authors` table on the production database.</span></span>

<span data-ttu-id="a4d83-235">차이점을 검토 하 고 동기화 할 개체를 선택 하 고 나면 다음 단계는 프로덕션 데이터베이스의 스키마를 개발 데이터베이스와 일치 하도록 업데이트 하는 데 필요한 SQL 명령을 생성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-235">After reviewing the differences and selecting which objects you want to synchronize, the next step is to generate the SQL commands needed to update the production database s schema to match the development database.</span></span> <span data-ttu-id="a4d83-236">이는 동기화 마법사를 통해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-236">This is accomplished through the Synchronization Wizard.</span></span> <span data-ttu-id="a4d83-237">동기화 마법사는 동기화 할 개체를 확인 하 고 작업 계획을 요약 합니다 (그림 3 참조).</span><span class="sxs-lookup"><span data-stu-id="a4d83-237">The Synchronization Wizard confirms what objects to synchronize and summarizes the action plan (see Figure 3).</span></span> <span data-ttu-id="a4d83-238">데이터베이스를 즉시 동기화 하거나 레저에서 실행할 수 있는 SQL 명령을 사용 하 여 스크립트를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-238">You can synchronize the databases immediately or generate a script with the SQL commands that can be run at your leisure.</span></span>

<span data-ttu-id="a4d83-239">[동기화 마법사를 사용 하 여 데이터베이스 스키마를 동기화 ![](strategies-for-database-development-and-deployment-vb/_static/image8.jpg)](strategies-for-database-development-and-deployment-vb/_static/image7.jpg)</span><span class="sxs-lookup"><span data-stu-id="a4d83-239">[![Use the Synchronization Wizard to Synchronize Your Databases Schemas](strategies-for-database-development-and-deployment-vb/_static/image8.jpg)](strategies-for-database-development-and-deployment-vb/_static/image7.jpg)</span></span>

<span data-ttu-id="a4d83-240">**그림 3**: 동기화 마법사를 사용 하 여 데이터베이스 스키마 동기화 ([전체 크기 이미지를 보려면 클릭](strategies-for-database-development-and-deployment-vb/_static/image9.jpg))</span><span class="sxs-lookup"><span data-stu-id="a4d83-240">**Figure 3**: Use the Synchronization Wizard to Synchronize Your Databases Schemas ([Click to view full-size image](strategies-for-database-development-and-deployment-vb/_static/image9.jpg))</span></span>

<span data-ttu-id="a4d83-241">Red Gate Software s SQL 비교와 같은 데이터베이스 비교 도구를 사용 하면 개발 데이터베이스 스키마에 변경 내용을 프로덕션 데이터베이스에 쉽게 적용 하 고 클릭할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-241">Database comparison tools like Red Gate Software s SQL Compare make applying the changes to the development database schema to the production database as easy as point and click.</span></span>

> [!NOTE]
> <span data-ttu-id="a4d83-242">SQL 비교는 두 데이터베이스 *스키마*를 비교 하 고 동기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-242">SQL Compare compares and synchronizes two databases *schemas*.</span></span> <span data-ttu-id="a4d83-243">그러나 두 데이터베이스 테이블의 데이터를 비교 하 고 동기화 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-243">Unfortunately, it does not compare and synchronize the data within two databases tables.</span></span> <span data-ttu-id="a4d83-244">빨간색 게이트 소프트웨어는 두 데이터베이스 간에 데이터를 비교 하 고 동기화 하는 [*Sql 데이터 비교*](http://www.red-gate.com/products/SQL_Data_Compare/) 라는 제품을 제공 하지만, sql 비교 및 $395 다른의 별도 제품입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-244">Red Gate Software does offer a product named [*SQL Data Compare*](http://www.red-gate.com/products/SQL_Data_Compare/) that compares and synchronizes the data between two databases, but it is a separate product from SQL Compare and costs another $395.</span></span>

## <a name="taking-the-application-offline-during-deployment"></a><span data-ttu-id="a4d83-245">배포 하는 동안 응용 프로그램을 오프 라인 상태로 만들기</span><span class="sxs-lookup"><span data-stu-id="a4d83-245">Taking the Application Offline During Deployment</span></span>

<span data-ttu-id="a4d83-246">이러한 자습서에서 볼 수 있듯이, 배포는 ASP.NET 페이지, 마스터 페이지, CSS 파일, JavaScript 파일, 이미지 및 기타 필요한 콘텐츠를 개발 환경에서 프로덕션 환경으로 복사 하는 여러 단계를 포함 하는 프로세스입니다. 개발 필요한 경우 프로덕션 환경 관련 구성 정보를 복사 하는 중 마지막 배포 이후 데이터 모델에 변경 내용을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-246">As we ve seen throughout these tutorials, deployment is a process that involves multiple steps: copying the ASP.NET pages, master pages, CSS files, JavaScript files, images, and other necessary content from the development environment to the production environment; copying up the production environment-specific configuration information, if needed; and applying the changes to the data model since the last deployment.</span></span> <span data-ttu-id="a4d83-247">파일 수와 데이터베이스 변경의 복잡도에 따라 이러한 단계를 완료 하는 데 몇 초에서 몇 분 정도 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-247">Depending on the number of files and the complexity of your database changes, these steps can take anywhere from a few seconds to several minutes to complete.</span></span> <span data-ttu-id="a4d83-248">이 기간 동안에는 웹 응용 프로그램이 flux에 있고 사이트를 방문 하는 사용자에 게 오류 또는 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-248">During this window the web application is in flux and users visiting the site may experience errors or unexpected behavior.</span></span>

<span data-ttu-id="a4d83-249">웹 사이트를 배포 하는 경우 배포가 완료 될 때까지 "오프 라인" 웹 응용 프로그램을 사용 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-249">When deploying a website it is best to take the web application "offline" until deployment has completed.</span></span> <span data-ttu-id="a4d83-250">응용 프로그램을 오프 라인 상태로 만들기 (배포 프로세스가 완료 된 후 백업 가능)는 파일을 업로드 한 후 삭제 하는 것 만큼 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-250">Taking the application offline (and bringing it back up once the deployment process has finished) is as easy as uploading a file and then deleting it.</span></span> <span data-ttu-id="a4d83-251">ASP.NET 2.0부터 응용 프로그램의 루트 디렉터리에 `app_offline.htm` 이라는 파일의 존재 여부는 전체 웹 사이트 "오프 라인"을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-251">Starting with ASP.NET 2.0, the mere presence of a file named `app_offline.htm` in the application s root directory takes the entire website "offline."</span></span> <span data-ttu-id="a4d83-252">해당 사이트의 ASP.NET 페이지에 대 한 모든 요청은 `app_offline.htm` 파일의 내용에 자동으로 응답 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-252">Any request to an ASP.NET page on that site is automatically responded with the contents of the `app_offline.htm` file.</span></span> <span data-ttu-id="a4d83-253">파일이 제거 되 면 응용 프로그램이 다시 온라인 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-253">Once that file is removed, the application comes back online.</span></span>

<span data-ttu-id="a4d83-254">배포 하는 동안 응용 프로그램을 오프 라인으로 전환 하는 것은 배포 프로세스를 시작 하기 전에 프로덕션 환경의 루트 디렉터리에 `app_offline.htm` 파일을 업로드 하는 것 만큼 간단 하 고, 배포가 완료 된 후에는 해당 파일을 삭제 하거나 다른 이름으로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-254">Taking an application offline during deployment, then, is as simple as uploading an `app_offline.htm` file to the production environment s root directory prior to beginning the deployment process and then deleting it (or renaming it to something else) once deployment is complete.</span></span> <span data-ttu-id="a4d83-255">이 기술에 대 한 자세한 내용은 John Peterson s 문서를 참조 하세요. [*ASP.NET 응용 프로그램을 오프 라인으로 전환*](http://www.15seconds.com/issue/061207.htm)합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-255">For more information on this technique refer to John Peterson s article, Taking an [*ASP.NET Application Offline*](http://www.15seconds.com/issue/061207.htm).</span></span>

## <a name="summary"></a><span data-ttu-id="a4d83-256">요약</span><span class="sxs-lookup"><span data-stu-id="a4d83-256">Summary</span></span>

<span data-ttu-id="a4d83-257">데이터 기반 응용 프로그램을 배포할 때의 주요 문제는 데이터베이스 배포를 중심으로 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-257">The main challenge in deploying a data-driven application centers around deploying the database.</span></span> <span data-ttu-id="a4d83-258">개발 환경에는 두 가지 버전의 데이터베이스가 있고 프로덕션 환경에는 데이터베이스가 있기 때문에 새 기능이 개발에 추가 되 면 이러한 두 데이터베이스 스키마가 동기화 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-258">Because there are two versions of the database - one in the development environment and one in the production environment - these two databases schemas can become out of sync as new features are added in development.</span></span> <span data-ttu-id="a4d83-259">프로덕션 데이터베이스는 실제 사용자의 실제 데이터로 채워지기 때문에 응용 프로그램을 구성 하는 파일 (ASP.NET 페이지)을 배포할 때와 같이 수정 된 개발 데이터베이스로 프로덕션 데이터베이스를 덮어쓸 수 없습니다. 이미지 파일 등).</span><span class="sxs-lookup"><span data-stu-id="a4d83-259">What s more, because the production database as being populated with real data from real users, you cannot overwrite the production database with the modified development database like you can when deploying the files that make up the application (the ASP.NET pages, image files, and so forth).</span></span> <span data-ttu-id="a4d83-260">대신 데이터베이스를 배포 하는 경우에는 마지막 배포 이후 프로덕션 데이터베이스에 대 한 개발 데이터베이스의 정확한 변경 내용 집합을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-260">Instead, deploying a database entails implementing the precise set of changes made to the development database on the production database since the last deployment.</span></span>

<span data-ttu-id="a4d83-261">이 자습서에서는 데이터베이스 변경 내용의 로그를 유지 관리 하 고 적용 하는 세 가지 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-261">This tutorial looked at three techniques for maintaining and applying a log of database changes.</span></span> <span data-ttu-id="a4d83-262">가장 간단한 방법은 prose의 변경 내용을 기록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-262">The simplest approach is to record the changes in prose.</span></span> <span data-ttu-id="a4d83-263">이 방법을 사용 하는 경우 프로덕션 데이터베이스에서 수동 프로세스로 이러한 변경 사항을 구현할 수 있지만, 데이터베이스 개체를 만들고 변경 하는 SQL 명령에 대 한 지식이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-263">While this tactic makes implementing these changes on the production database a manual process, it does not require knowledge of the SQL commands for creating and altering database objects.</span></span> <span data-ttu-id="a4d83-264">더 복잡 한 접근 방식으로, 여러 개발자를 포함 하는 대규모 프로젝트 또는 프로젝트에서 훨씬 더 palatable 되는 방법 중 하나는 일련의 SQL 명령으로 변경 내용을 기록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-264">A more sophisticated approach, and one that is much more palatable in larger projects or projects with multiple developers, is to record the changes as a series of SQL commands.</span></span> <span data-ttu-id="a4d83-265">이러한 변경 내용을 대상 데이터베이스에 배포 하는 것은 크게 hastens.</span><span class="sxs-lookup"><span data-stu-id="a4d83-265">This greatly hastens rolling out these changes to the target database.</span></span> <span data-ttu-id="a4d83-266">두 방법 중에서 가장 좋은 방법은 Red Gate Software s SQL 비교와 같은 데이터베이스 비교 도구를 사용 하 여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-266">The best of both approaches can be achieved by using a database comparison tool, such as Red Gate Software s SQL Compare.</span></span>

<span data-ttu-id="a4d83-267">이 자습서에서는 데이터 기반 응용 프로그램 배포에 중점을 두고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-267">This tutorial concludes our focus on deploying a data-driven application.</span></span> <span data-ttu-id="a4d83-268">다음 자습서 집합은 프로덕션 환경에서 오류에 대응 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-268">The next set of tutorials looks at how to respond to errors in the production environment.</span></span> <span data-ttu-id="a4d83-269">노란색 화면이 아닌 간단한 오류 페이지를 표시 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-269">We'll look at how to display a friendly error page rather instead of the Yellow Screen of Death.</span></span> <span data-ttu-id="a4d83-270">또한 오류 정보를 기록 하는 방법 및 이러한 오류가 발생 하는 경우 경고 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="a4d83-270">And we'll see how to log the error s details and how to alert you when such errors occur.</span></span>

<span data-ttu-id="a4d83-271">행복 한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="a4d83-271">Happy Programming!</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="a4d83-272">[이전](configuring-a-website-that-uses-application-services-vb.md)
> [다음](displaying-a-custom-error-page-vb.md)</span><span class="sxs-lookup"><span data-stu-id="a4d83-272">[Previous](configuring-a-website-that-uses-application-services-vb.md)
[Next](displaying-a-custom-error-page-vb.md)</span></span>
