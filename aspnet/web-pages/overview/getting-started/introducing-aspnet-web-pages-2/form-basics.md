---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
title: ASP.NET 웹 페이지 소개 - HTML 양식 기본 사항 | 마이크로 소프트 문서
author: Rick-Anderson
description: 이 자습서에서는 입력 양식을 만드는 방법과 ASP.NET 웹 페이지(Razor)를 사용할 때 사용자의 입력을 처리하는 방법에 대한 기본 정보를 보여 주며, 이 자습서에서는 입력 양식을 만드는 방법에 대해 설명합니다. 그리고 지금 당신은 ...
ms.author: riande
ms.date: 05/28/2015
ms.assetid: 81ed82bf-b940-44f1-b94a-555d0cb7cc98
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
msc.type: authoredcontent
ms.openlocfilehash: f57661077ec3bb13f3d4ec41b130bda4d2fb9070
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675924"
---
# <a name="introducing-aspnet-web-pages---html-form-basics"></a>ASP.NET 웹 페이지 소개 - HTML 양식 기본 사항

[Tom FitzMacken](https://github.com/tfitzmac)

> 이 자습서에서는 입력 양식을 만드는 방법과 ASP.NET 웹 페이지(Razor)를 사용할 때 사용자의 입력을 처리하는 방법에 대한 기본 정보를 보여 주며, 이 자습서에서는 입력 양식을 만드는 방법에 대해 설명합니다. 이제 데이터베이스가 있으므로 양식 기술을 사용하여 사용자가 데이터베이스에서 특정 동영상을 찾을 수 있도록 합니다. 웹 페이지를 사용하여 데이터 표시 소개를 통해 시리즈를 완료했다고 [가정 ASP.NET합니다.](/aspnet/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/displaying-data)
> 
> 학습할 내용:
> 
> - 표준 HTML 요소를 사용하여 양식을 만드는 방법.
> - 양식에서 사용자의 입력을 읽는 방법.
> - 사용자가 제공하는 검색어를 사용하여 데이터를 선택적으로 가져옵니다.
> - 페이지에 사용자가 입력한 내용을 "기억"하는 필드를 갖도록 하는 방법
>   
> 
> 논의된 기능/기술:
> 
> - `Request` 개체입니다.
> - SQL `Where` 절입니다.

## <a name="what-youll-build"></a>만들 내용

이전 자습서에서는 데이터베이스를 만들고, 데이터를 추가한 다음, 도우미를 `WebGrid` 사용하여 데이터를 표시했습니다. 이 자습서에서는 특정 장르의 영화를 찾을 수 있는 검색 상자를 추가하거나 제목에 입력한 단어가 포함되어 있습니다. (예를 들어 장르가 "액션"이거나 제목에 "해리" 또는 "어드벤처"가 포함된 모든 영화를 찾을 수 있습니다.)

이 자습서를 완료하면 다음과 같은 페이지가 표시됩니다.

![장르 및 제목 검색이 있는 동영상 페이지](form-basics/_static/image1.png)

페이지의 목록 부분은 마지막 자습서 &mdash; 그리드와 동일합니다. 차이점은 그리드에 검색한 영화만 표시된다는 것입니다.

## <a name="about-html-forms"></a>HTML 양식 정보

HTML 양식을 만든 경험이 있고 `GET` 이 `POST`섹션과 의 차이점이 있는 경우 이 섹션을 건너뛸 수 있습니다.

양식에는 사용자 입력 &mdash; 요소 텍스트 상자, 단추, 라디오 단추, 확인란, 드롭다운 목록 등이 있습니다. 사용자는 이러한 컨트롤을 입력하거나 선택한 다음 단추를 클릭하여 양식을 제출합니다.

양식의 기본 HTML 구문은 이 예제에서 설명합니다.

[!code-html[Main](form-basics/samples/sample1.html)]

이 태그가 페이지에서 실행되면 다음과 같은 간단한 양식을 만듭니다.

![브라우저에서 렌더링된 기본 HTML 양식](form-basics/_static/image2.png)

요소는 `<form>` 제출할 HTML 요소를 둘러싸는다. (쉬운 실수는 페이지에 요소를 추가한 다음 `<form>` 요소 안에 넣는 것을 잊어 버리는 것입니다. 이 경우 아무 것도 제출되지 않습니다.) 속성은 `method` 브라우저에 사용자 입력을 제출하는 방법을 알려줍니다. 서버에서 업데이트를 `post` 수행하는 경우 또는 서버에서 데이터를 `get` 가져오는 경우로 설정합니다.

<a id="GET,_POST,_and_HTTP_Verb_Safety"></a>

> [!TIP] 
> 
> **GET, POST 및 HTTP 동사 안전**
> 
> 브라우저와 서버가 정보를 교환하는 데 사용하는 프로토콜인 HTTP는 기본 작업에서 매우 간단합니다. 브라우저는 몇 개의 동사만 사용하여 서버에 요청을 합니다. 웹에 대한 코드를 작성할 때 이러한 동사와 브라우저및 서버에서 코드를 사용하는 방법을 이해하는 것이 좋습니다. 가장 일반적으로 사용되는 동사는 다음과 같습니다.
> 
> - `GET`. 브라우저는 이 동사를 사용하여 서버에서 무언가를 가져옵니다. 예를 들어 브라우저에 URL을 입력하면 브라우저에서 `GET` 원하는 페이지를 요청하는 작업을 수행합니다. 페이지에 그래픽이 포함된 경우 브라우저는 이미지를 얻기 위해 추가 `GET` 작업을 수행합니다. `GET` 작업이 서버에 정보를 전달해야 하는 경우 정보는 쿼리 문자열의 URL의 일부로 전달됩니다.
> - `POST`. 브라우저는 서버에 `POST` 추가하거나 변경할 데이터를 제출하기 위해 요청을 보냅니다. 예를 들어 `POST` 동사는 데이터베이스에서 레코드를 만들거나 기존 레코드를 변경하는 데 사용됩니다. 대부분의 경우 양식을 작성하고 제출 단추를 클릭하면 브라우저에서 작업을 `POST` 수행합니다. `POST` 작업에서 서버로 전달되는 데이터는 페이지 본문에 있습니다.
> 
> 이러한 동사 간의 중요한 차이점은 `GET` 작업이 서버에서 아무 것도 변경하지 않거나 약간 추상적인 방식으로 `GET` 작업하면 서버의 상태가 변경되지 않는다는 것입니다. 동일한 리소스에서 `GET` 작업을 원하는 횟수만큼 수행할 수 있으며 이러한 리소스는 변경되지 않습니다. `GET` (수술은 종종 "안전"이라고하거나 기술 용어를 사용하는 것은 *idempotent입니다.)* 반대로 작업을 수행할 때마다 `POST` 요청이 서버에서 변경됩니다.
> 
> 두 가지 예는 이러한 구분을 설명하는 데 도움이 됩니다. Bing 또는 Google과 같은 엔진을 사용하여 검색을 수행하면 하나의 텍스트 상자로 구성된 양식을 입력한 다음 검색 단추를 클릭합니다. 브라우저는 입력한 `GET` 상자에 입력한 값이 URL의 일부로 전달되는 작업을 수행합니다. 검색 `GET` 작업은 서버의 리소스를 변경하지 않으므로 이러한 형식의 양식에 대한 작업을 사용하는 것은 괜찮습니다.
> 
> 이제 온라인으로 무언가를 주문하는 과정을 고려하십시오. 주문 세부 정보를 입력한 다음 제출 단추를 클릭합니다. 이 작업은 새 `POST` 주문 레코드, 계정 정보 변경 및 기타 여러 변경 사항과 같은 서버에서 변경되므로 요청이 됩니다. 작업과 `GET` 달리 `POST` 요청을 반복할 수 없습니다. (이와 같은 경우 웹 사이트는 제출 단추를 두 번 이상 클릭하지 말라고 경고하거나 실수로 양식을 다시 제출하지 않도록 제출 단추를 비활성화합니다.)
> 
> 이 자습서에서는 HTML 양식으로 `GET` 작업하는 작업과 `POST` 작업을 모두 사용합니다. 각 경우에 사용하는 동사가 적절한 동사인 이유를 설명합니다.
> 
> HTTP 동사에 대한 자세한 내용은 W3C 사이트의 [메서드 정의](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) 문서를 참조하십시오.

대부분의 사용자 입력 `<input>` 요소는 HTML 요소입니다. *형식은* `<input type="type" name="name">,` 원하는 사용자 입력 컨트롤의 종류를 나타내는 위치처럼 보입니다. 이러한 요소는 다음과 같은 일반적인 요소입니다.

- 텍스트 상자:`<input type="text">`
- 확인란:`<input type="check">`
- 라디오 버튼:`<input type="radio">`
- 단추:`<input type="button">`
- 제출 버튼:`<input type="submit">`

`<textarea>` 요소를 사용하여 다중 줄 텍스트 상자와 `<select>` 요소를 만들어 드롭다운 목록 또는 스크롤 가능한 목록을 만들 수도 있습니다. HTML 양식 요소에 대한 자세한 내용은 W3Schools 사이트의 [HTML 양식 및 입력을](http://www.w3schools.com/html/html_forms.asp) 참조하십시오.

`name` 이름은 나중에 요소의 값을 얻는 방법이므로 곧 볼 수 있으므로 특성이 매우 중요합니다.

흥미로운 부분은 페이지 개발자인 사용자가 사용자의 입력을 통해 수행하는 것입니다. 이러한 요소와 관련된 기본 제공 동작은 없습니다. 대신 사용자가 입력하거나 선택한 값을 얻고 그들과 함께 작업을 수행해야합니다. 이것이 이 자습서에서 배울 수 있는 내용입니다.

> [!TIP] 
> 
> **HTML5 및 입력 양식**
> 
> 아시다시피 HTML은 전환 중이며 최신 버전(HTML5)에는 사용자가 정보를 입력할 수 있는 보다 직관적인 방법에 대한 지원이 포함되어 있습니다. 예를 들어 HTML5에서 페이지 개발자는 사용자가 날짜를 입력하도록 페이지를 알릴 수 있습니다. 그러면 브라우저는 사용자가 수동으로 날짜를 입력하도록 요구하지 않고 캘린더를 자동으로 표시할 수 있습니다. 그러나 HTML5는 새 것이며 아직 모든 브라우저에서 지원되지 않습니다.
> 
> ASP.NET 웹 페이지는 사용자의 브라우저가 수행하는 범위까지 HTML5 입력을 지원합니다. HTML5의 `<input>` 요소에 대한 새 특성에 대한 아이디어는 W3Schools 사이트의 [HTML &lt;&gt; 입력 유형 특성을](http://www.w3schools.com/html/html_form_input_types.asp) 참조하십시오.

## <a name="creating-the-form"></a>폼 만들기

WebMatrix에서 **파일** 작업 영역에서 *Movies.cshtml* 페이지를 엽니다.

닫는 `</h1>` 태그 후 호출의 `<div>` `grid.GetHtml` 열기 태그 앞에 다음 태그를 추가합니다.

[!code-html[Main](form-basics/samples/sample2.html)]

이 태그는 명명된 `searchGenre` 텍스트 상자와 제출 단추가 있는 양식을 만듭니다. 텍스트 상자와 제출 단추는 `<form>` `method` 특성이 `get`로 설정된 요소에 동봉됩니다. (텍스트 상자를 넣고 요소 안에 단추를 `<form>` 제출하지 않으면 단추를 클릭하면 아무 것도 제출되지 않습니다.) 서버에서 `GET` 변경하지 않는 양식을 만들기 때문에 여기에서 동사를 사용합니다. (이전 자습서에서는 서버에 변경 `post` 내용을 제출 하는 메서드를 사용 했습니다. 다음 자습서에서 다시 볼 수 있습니다.)

페이지를 실행합니다. 양식에 대한 동작을 정의하지는 않았지만 다음과 같은 모양을 볼 수 있습니다.

![장르에 대한 검색 상자가있는 영화 페이지](form-basics/_static/image3.png)

텍스트 상자에 '코미디'와 같은 값을 입력합니다. 그런 다음 **검색 장르를 클릭합니다.**

페이지의 URL을 기록해 둡것입니다. 요소의 `<form>` `method` 특성을 `get`에 설정하기 때문에 입력한 값은 이제 다음과 같이 URL의 쿼리 문자열의 일부입니다.

`http://localhost:45661/Movies.cshtml?searchGenre=Comedy`

## <a name="reading-form-values"></a>양식 값 읽기

페이지에는 데이터베이스 데이터를 얻고 결과를 그리드에 표시하는 일부 코드가 이미 포함되어 있습니다. 이제 검색어가 포함된 SQL 쿼리를 실행할 수 있도록 텍스트 상자의 값을 읽는 코드를 추가해야 합니다.

양식의 메서드를 `get`으로 설정하면 다음과 같은 코드를 사용하여 텍스트 상자에 입력된 값을 읽을 수 있습니다.

`var searchTerm = Request.QueryString["searchGenre"];`

개체(개체의 `QueryString` 속성)에는 `GET` 작업의 일부로 제출된 요소의 값이 포함됩니다. `Request.QueryString` `Request` 속성에는 `Request.QueryString` 양식에 제출된 값의 컬렉션(목록)이 포함되어 있습니다. *collection* 개별 값을 얻으려면 원하는 요소의 이름을 지정합니다. 그래서 텍스트 상자를 만드는 `name` `<input>` 요소 ()에`searchTerm`특성이 있어야합니다. 개체에 `Request` 대한 자세한 내용은 나중에 [사이드바를](#BKMK_TheRequestObject) 참조하십시오.

텍스트 상자의 값을 읽을 수 있을 만큼 간단합니다. 그러나 사용자가 텍스트 상자에 아무 것도 입력하지 않았지만 어쨌든 **검색을** 클릭한 경우 검색할 항목이 없기 때문에 해당 클릭을 무시할 수 있습니다.

다음 코드는 이러한 조건을 구현하는 방법을 보여 주는 예제입니다. (이 코드를 아직 추가할 필요는 없습니다.

[!code-csharp[Main](form-basics/samples/sample3.cs)]

테스트는 다음과 같은 방식으로 분해됩니다.

- `Request.QueryString["searchGenre"]`의 값을 가져옵니다. `<input>` `searchGenre`
- 메서드를 `IsEmpty` 사용하여 비어 있는지 확인합니다. 이 메서드는 무언가(예: 양식 요소)에 값이 포함되어 있는지 여부를 확인하는 표준 방법입니다. 그러나 정말, 당신은 따라서, 비어 *있지 않은* 경우에만 관심 ...
- 테스트 `!` 앞에 연산자를 `IsEmpty` 추가합니다. (연산자는 `!` 논리적 NOT을 의미합니다).

일반 영어에서 전체 `if` 조건은 다음과 같습니다 : *양식의 searchGenre 요소가 비어 있지 않으면 ...*

이 블록은 검색어를 사용하는 쿼리를 만들기 위한 단계를 설정합니다. 다음 섹션에서 구성을 완료합니다.

<a id="BKMK_TheRequestObject"></a>

> [!TIP] 
> 
> **요청 개체**
> 
> 개체에는 `Request` 페이지를 요청하거나 제출할 때 브라우저가 응용 프로그램에 보내는 모든 정보가 들어 있습니다. 이 개체에는 텍스트 상자 값또는 업로드할 파일과 같이 사용자가 제공하는 모든 정보가 포함됩니다. 또한 쿠키, URL 쿼리 문자열의 값(있는 경우), 실행 중인 페이지의 파일 경로, 사용자가 사용하는 브라우저 유형, 브라우저에서 설정된 언어 목록 등모든 종류의 추가 정보가 포함됩니다.
> 
> 개체는 `Request` 값의 컬렉션(목록)입니다. *collection* 이름을 지정하여 컬렉션에서 개별 값을 가져옵니다.
> 
> `var someValue = Request["name"];`
> 
> 개체는 `Request` 실제로 여러 하위 집합을 노출합니다. 예를 들어:
> 
> - `Request.Form`요청이 `POST` 요청인 경우 `<form>` 제출된 요소 내의 요소에서 값을 제공합니다.
> - `Request.QueryString`URL의 쿼리 문자열에 있는 값만 제공합니다. (와 같은 `http://mysite/myapp/page?searchGenre=action&page=2`URL에서 `?searchGenre=action&page=2` URL의 섹션은 쿼리 문자열입니다.)
> - `Request.Cookies`컬렉션은 브라우저가 전송한 쿠키에 대한 액세스를 제공합니다.
> 
> 제출된 양식에 있는 값을 얻으려면 을 사용할 `Request["name"]`수 있습니다. 또는 보다 구체적인 버전(요청의 `Request.Form["name"]` `POST` 경우) 또는 `Request.QueryString["name"]` (요청의 경우) `GET` 사용할 수 있습니다. 물론, *이름은* 얻을 항목의 이름입니다.
> 
> 원하는 항목의 이름은 사용 하려는 컬렉션 내에서 고유 해야 합니다. 객체가 `Request` 와 `Request.Form` `Request.QueryString`같은 하위 집합을 제공하는 이유입니다. 페이지에 라는 `userName` 양식 요소가 포함되어 있고 `userName`라는 *쿠키도* 포함되어 있다고 가정합니다. 이 경우 `Request["userName"]`양식 값또는 쿠키를 사용할지 여부가 모호합니다. 그러나 얻을 `Request.Form["userName"]` 경우 `Request.Cookie["userName"]`또는 ' 얻을 값에 대 한 명시 적 되 고.
> 
> 구체적으로 설정하고 관심 `Request` `Request.Form` `Request.QueryString`있는 하위 집합을 사용하는 것이 좋습니다. 이 자습서에서 만드는 간단한 페이지의 경우 실제로 아무런 차이가 없을 수 있습니다. 그러나 더 복잡한 페이지를 만들 때 명시적 버전을 `Request.Form` 사용하거나 `Request.QueryString` 페이지에 양식(또는 여러 양식), 쿠키, 쿼리 문자열 값 등이 포함될 때 발생할 수 있는 문제를 방지할 수 있습니다.

## <a name="creating-a-query-by-using-a-search-term"></a>검색어를 사용하여 쿼리 만들기

이제 사용자가 입력한 검색어를 얻는 방법을 알고 있으므로 이를 사용하는 쿼리를 만들 수 있습니다. 데이터베이스에서 모든 동영상 항목을 얻으려면 이 명령문과 같은 SQL 쿼리를 사용하고 있습니다.

`SELECT * FROM Movies`

특정 동영상만 얻으려면 절이 포함된 쿼리를 `Where` 사용해야 합니다. 이 절을 사용하면 쿼리에서 반환되는 행조건을 설정할 수 있습니다. 예를 들면 다음과 같습니다.

`SELECT * FROM Movies WHERE Genre = 'Action'`

기본 형식은 `WHERE column = value`. 원하는 항목에 따라 (보다 `=` `>` 큰), `<` (작음), `<>` (같지 않음), `<=` (작거나 같음) 등 외에 다른 연산을 사용할 수 있습니다.

궁금해하는 경우 SQL 문은 대/소문자를 &mdash; `SELECT` 구분하지 `Select` 않는 것이 `select`(또는 심지어)와 동일합니다. 그러나 사람들은 읽기 쉽도록 SQL `SELECT` 문과 `WHERE`의 키워드를 대문자로 대하는 경우가 많습니다.

### <a name="passing-the-search-term-as-a-parameter"></a>검색어를 매개 변수로 전달

특정 장르를 검색하는 것은`WHERE Genre = 'Action'`충분히 쉽지만()는 사용자가 입력하는 모든 장르를 검색할 수 있기를 원합니다. 이렇게 하려면 검색할 값에 대 한 자리 표시자를 포함 하는 SQL 쿼리로 만듭니다. 이 명령처럼 보입니다.

`SELECT * FROM Movies WHERE Genre = @0`

자리 표시자는 `@` 문자 다음에 0입니다. 추측할 수 있듯이 쿼리에는 여러 자리 표시자가 포함될 `@0`수 `@1` `@2`있으며 쿼리의 이름은 ', 등입니다.

쿼리를 설정하고 실제로 값을 전달하려면 다음과 같은 코드를 사용합니다.

[!code-sql[Main](form-basics/samples/sample4.sql)]

이 코드는 그리드에 데이터를 표시하기 위해 이미 수행한 것과 유사합니다. 유일한 차이점은 다음과 같습니다.

- 쿼리에는 자리 표시자()가`WHERE Genre = @0"`포함되어 있습니다.
- 쿼리가 변수 ()`selectCommand`에 넣습니다. 이전에는 쿼리를 `db.Query` 메서드에 직접 전달했습니다.
- 메서드를 `db.Query` 호출하면 자리 표시자에 사용할 쿼리와 값을 모두 전달합니다. 쿼리에 여러 자리 표시자가 있는 경우 모두 메서드에 별도의 값으로 전달합니다.

이러한 모든 요소를 함께 넣으면 다음 코드가 표시됩니다.

[!code-csharp[Main](form-basics/samples/sample5.cs)]

> [!NOTE] 
> 
> **중요!** 자리 표시자(예: `@0`)를 사용하여 SQL 명령에 값을 전달하는 것은 보안을 위해 *매우 중요합니다.* 변수 데이터에 대한 자리 표시자를 사용하여 여기에서 보는 방법은 SQL 명령을 생성해야 하는 유일한 방법입니다.
> 
> 사용자에게서 얻은 리터럴 텍스트와 값을 함께 (연결) 하여 SQL 문을 구성하지 마십시오. 사용자 입력을 SQL 문에 연결하면 악의적인 사용자가 데이터베이스를 해킹하는 페이지에 값을 제출하는 *SQL 주입 공격이* 사이트를 엽니다. (자세한 내용은 MSDN 웹 사이트 [SQL 주입](https://msdn.microsoft.com/library/ms161953.aspx) 문서에서 확인할 수 있습니다.)

## <a name="updating-the-movies-page-with-search-code"></a>검색 코드로 동영상 페이지 업데이트

이제 *Movies.cshtml* 파일에서 코드를 업데이트할 수 있습니다. 시작하려면 페이지 상단의 코드 블록의 코드를 이 코드로 바꿉니다.

[!code-csharp[Main](form-basics/samples/sample6.cs)]

여기서 차이점은 쿼리를 `selectCommand` 변수에 넣으면 `db.Query` 나중에 전달된다는 것입니다. SQL 문을 변수에 넣으면 검색을 수행하기 위해 수행할 명령문을 변경할 수 있습니다.

또한 이 두 줄을 제거했는데 나중에 다시 배치할 것입니다.

[!code-csharp[Main](form-basics/samples/sample7.cs)]

쿼리를 아직 실행하지 않으려는 경우(즉, `db.Query`호출) `WebGrid` 도우미를 초기화하고 싶지도 않습니다. 어떤 SQL 문을 실행해야 할지 파악한 후에 이러한 작업을 수행합니다.

이 다시 작성된 블록 후에 검색을 처리하기 위한 새 논리를 추가할 수 있습니다. 완성된 코드는 다음과 같습니다. 이 예제와 일치되도록 페이지의 코드를 업데이트합니다.

[!code-cshtml[Main](form-basics/samples/sample8.cshtml)]

이제 이 페이지가 다음과 같이 작동합니다. 페이지가 실행될 때마다 코드가 데이터베이스를 열고 `selectCommand` 변수는 `Movies` 테이블에서 모든 레코드를 가져옵니다 SQL 문으로 설정됩니다. 또한 코드는 변수를 `searchTerm` 초기화합니다.

그러나 현재 요청에 `searchGenre` 요소에 대한 값이 포함된 경우 `selectCommand` 코드는 장르를 검색하는 `Where` 절을 포함하는 쿼리와 같은 다른 쿼리로 설정됩니다. 또한 검색 `searchTerm` 상자에 대해 전달된 대로 설정합니다(아무 것도 아닐 수도 있음).

에 있는 SQL 문에 `selectCommand`관계 없이 `db.Query` 코드는 쿼리를 실행 하기 `searchTerm`위해 호출 하 고 에 있는 모든 것을 전달 합니다. `searchTerm`에 아무 것도 없는 경우 아무 것도 중요하지 `selectCommand` 않습니다.

마지막으로 코드는 이전과 `WebGrid` 마찬가지로 쿼리 결과를 사용하여 도우미를 초기화합니다.

SQL 문과 검색어를 변수에 배치하면 코드에 유연성을 추가했습니다. 이 자습서의 왼쪽 에서 볼 수 있듯이 이 기본 프레임 워크를 사용 하 여 다른 유형의 검색에 대 한 논리를 계속 추가할 수 있습니다.

## <a name="testing-the-search-by-genre-feature"></a>장르별 검색 기능 테스트

웹매트릭스에서 *Movies.cshtml 페이지를 실행합니다.* 장르에 대한 텍스트 상자가 있는 페이지가 표시됩니다.

테스트 레코드 중 하나에 입력한 장르를 입력한 다음 **검색을**클릭합니다. 이번에는 해당 장르와 일치하는 영화 목록만 표시됩니다.

![장르 '코미디'를 검색 한 후 영화 페이지 목록](form-basics/_static/image4.png)

다른 장르를 입력하고 다시 검색합니다. 검색에 대소문자를 구분하지 않도록 모든 소문자 또는 모든 대문자문자를 사용하여 장르를 입력해 보십시오.

## <a name="remembering-what-the-user-entered"></a>사용자가 입력한 내용 "기억"

장르를 입력하고 **검색 장르를**클릭한 후 해당 장르에 대한 목록을 보았습니다. 그러나 검색 텍스트 상자는 &mdash; 비어 있었고 입력한 내용을 기억하지 못했습니다.

이 문제가 발생하는 이유를 이해하는 것이 중요합니다. 페이지를 제출하면 브라우저가 웹 서버에 요청을 보냅니다. ASP.NET 요청을 받으면 페이지의 새 인스턴스를 만들고, 페이지에서 코드를 실행한 다음 페이지를 브라우저로 다시 렌더링합니다. 그러나 실제로 페이지는 이전 버전의 자체 작업만 했다는 것을 알지 못합니다. 알고있는 것은 양식 데이터가있는 요청을 받았다는 것입니다.

페이지를 처음 요청할 &mdash; 때마다 또는 페이지를 제출하여 &mdash; 새 페이지를 얻게 됩니다. 웹 서버에 마지막 요청에 대한 메모리가 없습니다. 어느 쪽도 ASP.NET 않으며 브라우저도 하지 않습니다. 페이지의 이러한 개별 인스턴스 간에 만 연결되는 것은 페이지 간에 전송하는 모든 데이터입니다. 예를 들어 페이지를 제출하는 경우 새 페이지 인스턴스는 이전 인스턴스에서 보낸 양식 데이터를 얻을 수 있습니다. (페이지 간에 데이터를 전달하는 또 다른 방법은 쿠키를 사용하는 것입니다.)

이 상황을 설명하는 공식적인 방법은 웹 페이지가 *상태 비수라고*말하는 것입니다. 웹 서버와 페이지 자체 및 페이지의 요소는 페이지의 이전 상태에 대한 정보를 유지 관리하지 않습니다. 웹은 개별 요청에 대한 상태를 유지 관리하면 초당 수천, 심지어 수십만 개의 요청을 처리하는 웹 서버의 리소스가 빠르게 소모되기 때문에 이러한 방식으로 설계되었습니다.

그래서 텍스트 상자가 비어 있는 이유입니다. 페이지를 제출한 ASP.NET 페이지의 새 인스턴스를 만들고 코드와 태그를 실행했습니다. ASP.NET 텍스트 상자에 값을 넣으라고 말한 코드에는 아무것도 없었습니다. 그래서 ASP.NET 아무것도하지 않았고, 텍스트 상자는 값없이 렌더링되었습니다.

실제로이 문제를 해결할 수있는 쉬운 방법이 있습니다. 텍스트 상자에 입력한 *장르는* &mdash; `Request.QueryString["searchGenre"]`의 코드에서 사용할 수 있습니다.

이 예제와 같이 `value` 특성에서 값을 `searchTerm`얻습니다.

[!code-html[Main](form-basics/samples/sample9.html?highlight=1)]

이 페이지에서는 해당 `value` `searchTerm` 변수에 입력한 장르도 포함되어 있으므로 변수에 속성을 설정할 수도 있습니다. 그러나 여기에 `Request` 표시된 대로 `value` 속성을 설정하는 개체를 사용하는 것이 이 작업을 수행하는 표준 방법입니다. (경우에 따라 이 &mdash; 작업을 수행하려는 경우 필드에 값이 *없는* 페이지를 렌더링할 수도 있습니다. 모든 앱에서 무슨 일이 일어나고 있는지에 따라 달라집니다.)

> [!NOTE]
> 암호에 사용되는 텍스트 상자의 값은 "기억"할 수 없습니다. 사람들이 코드를 사용하여 암호 필드를 채울 수 있도록 하는 보안 구멍이 될 것입니다.

페이지를 다시 실행하고 장르를 입력한 다음 **검색 장르를**클릭합니다. 이번에는 검색 결과가 표시될 뿐만 아니라 텍스트 상자에 마지막으로 입력한 내용을 기억합니다.

![텍스트 상자가 이전 항목을 '기억'했다는 페이지 표시](form-basics/_static/image5.png)

## <a name="searching-for-any-word-in-the-title"></a>제목에 있는 모든 단어 검색

이제 모든 장르를 검색할 수 있지만 제목을 검색할 수도 있습니다. 검색할 때 제목을 정확하게 얻기가 어렵기 때문에 제목 안에 나타나는 단어를 검색할 수 있습니다. SQL에서 이렇게 하려면 `LIKE` 다음과 같이 연산자와 구문을 사용합니다.

`SELECT * FROM Movies WHERE Title LIKE '%adventure%'`

이 명령은 제목에 "모험"이 포함된 모든 영화를 가져옵니다. 연산자사용 `LIKE` 시 와일드카드 문자를 `%` 검색어의 일부로 포함합니다. 검색은 `LIKE 'adventure%'` '모험'으로 시작'을 의미합니다. (기술적으로, 그것은 "문자열 '모험'뒤에 아무것도 를 의미합니다.) 마찬가지로 검색어는 `LIKE '%adventure'` '어드벤처'라는 문자열다음에 '모험'이라는 의미로,'모험'으로 끝나는 또 다른 방법입니다.

따라서 검색어는 `LIKE '%adventure%'` "제목의 어느 곳에서나 '모험'을 의미합니다." (기술적으로, "제목에 있는 모든 것, '모험', 그 다음에 무엇이든 뒤따릅니다.)

`<form>` 요소 내부에 장르 검색을 위한 닫기 `</div>` 태그 바로 아래에 다음 태그(닫기 `</form>` 요소 바로 앞)를 추가합니다.

[!code-html[Main](form-basics/samples/sample10.html)]

이 검색을 처리하는 코드는 검색을 어셈블해야 한다는 점을 제외하면 장르 `LIKE` 검색의 코드와 유사합니다. 페이지 상단의 코드 블록 안에 장르 `if` 검색 블록 `if` 바로 바로 다음의 이 블록을 추가합니다.

[!code-csharp[Main](form-basics/samples/sample11.cs)]

이 코드는 검색에서 `LIKE` 연산자 및 코드는 검색 용어 앞과 후에 "를`%`넣는다는 점을 제외하고는 앞에서 본 것과 동일한 논리를 사용합니다.

페이지에 다른 검색을 쉽게 추가하는 방법을 확인합니다. 여러분이 해야 할 일은 다음과 같은 것이었습니다.

- 테스트된 `if` 블록을 만들어 관련 검색 상자에 값이 있는지 확인합니다.
- 변수를 `selectCommand` 새 SQL 문으로 설정합니다.
- 쿼리에 `searchTerm` 전달할 값으로 변수를 설정합니다.

다음은 제목 검색에 대한 새 논리를 포함하는 전체 코드 블록입니다.

[!code-cshtml[Main](form-basics/samples/sample12.cshtml)]

이 코드에서 수행하는 기능을 요약하면 다음과 같습니다.

- 변수와 `selectCommand` `searchTerm` 맨 위에 초기화됩니다. 이러한 변수를 페이지의 사용자에 따라 적절한 검색어(있는 경우)와 적절한 SQL 명령으로 설정합니다. 기본 검색은 데이터베이스에서 모든 동영상을 가져오는 간단한 경우입니다.
- 에 대 `searchGenre` `searchTitle`한 테스트에서 코드는 검색 할 값으로 설정 `searchTerm` 합니다. 또한 이러한 코드 `selectCommand` 블록은 해당 검색에 적합한 SQL 명령으로 설정됩니다.
- 메서드는 `db.Query` SQL `selectedCommand` 명령이 있고 `searchTerm`에 있는 값을 사용하여 한 번만 호출됩니다. 검색어가 없는 경우(장르및 제목 단어가 없음) `searchTerm` 값은 빈 문자열입니다. 그러나 이 경우 쿼리에 매개 변수가 필요하지 않기 때문에 이는 중요하지 않습니다.

## <a name="testing-the-title-search-feature"></a>제목 검색 기능 테스트

이제 완료된 검색 페이지를 테스트할 수 있습니다. *동영상 실행.cshtml*.

장르를 입력하고 **검색 장르를 클릭합니다.** 그리드는 이전과 같이 해당 장르의 영화를 표시합니다.

제목 단어를 입력하고 **제목 검색을**클릭합니다. 표는 제목에 해당 단어가 있는 동영상을 표시합니다.

![제목에서 'The'를 검색한 후 동영상 페이지 목록](form-basics/_static/image6.png)

두 텍스트 상자를 모두 비워 두고 두 단추를 클릭합니다. 그리드에 모든 동영상이 표시됩니다.

## <a name="combining-the-queries"></a>쿼리 결합

수행할 수 있는 검색은 배타적일 수 있습니다. 두 검색 상자에 값이 있는 경우에도 제목과 장르를 동시에 검색할 수 없습니다. 예를 들어 제목에 "Adventure"가 포함된 모든 액션 영화를 검색할 수 없습니다. (페이지가 지금 코딩되었으므로 장르와 제목 모두에 대한 값을 입력하면 제목 검색이 우선합니다.) 조건을 결합하는 검색을 만들려면 다음과 같은 구문이 있는 SQL 쿼리를 만들어야 합니다.

`SELECT * FROM Movies WHERE Genre = @0 AND Title LIKE @1`

그리고 다음과 같은 문을 사용하여 쿼리를 실행해야합니다 (대략 말하기).

`var selectedData = db.Query(selectCommand, searchGenre, searchTitle);`

검색 조건의 많은 순열을 허용하는 논리를 만들면 볼 수 있듯이 약간의 관련이 있을 수 있습니다. 따라서 여기서 멈추겠습니다.

## <a name="coming-up-next"></a>다음 단계로 올라오기

다음 자습서에서는 사용자가 데이터베이스에 동영상을 추가할 수 있도록 폼을 사용하는 페이지를 만듭니다.

## <a name="complete-listing-for-movie-page-updated-with-search"></a>동영상 페이지 전체 목록(검색으로 업데이트)

[!code-cshtml[Main](form-basics/samples/sample13.cshtml)]

## <a name="additional-resources"></a>추가 리소스

- [Razor 구문을 사용하는 ASP.NET 웹 프로그래밍 소개](https://go.microsoft.com/fwlink/?LinkID=202890)
- W3Schools 사이트의 [SQL WHERE 절](http://www.w3schools.com/sql/sql_where.asp)
- W3C 사이트의 [메서드 정의](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) 문서

> [!div class="step-by-step"]
> [이전](displaying-data.md)
> [다음](entering-data.md)
